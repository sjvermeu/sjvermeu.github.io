<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Simplicity is a form of art... - SELinux</title><link href="https://blog.siphos.be/" rel="alternate"></link><link href="https://blog.siphos.be/category/selinux/feed/atom.xml" rel="self"></link><id>https://blog.siphos.be/</id><updated>2021-01-06T20:00:00+01:00</updated><entry><title>SELinux System Administration 3rd Edition</title><link href="https://blog.siphos.be/2021/01/selinux-system-administration-3rd-edition/" rel="alternate"></link><published>2021-01-06T20:00:00+01:00</published><updated>2021-01-06T20:00:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2021-01-06:/2021/01/selinux-system-administration-3rd-edition/</id><content type="html">&lt;p&gt;As I mentioned previously, recently my latest installment of "SELinux System
Administration" has been released by Packt Publishing. This is already the
third edition of the book, after the first (2013) and second (2016) editions
have gotten reasonable success given the technical and often hard nature of
full SELinux administration.&lt;/p&gt;
&lt;p&gt;Like with the previous editions, this book remains true to the public of
system administrators, rather than SELinux policy developers. Of course,
SELinux policy development is not ignored in the book.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What has changed&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First and foremost, it of course updates the content of the previous edition
to be up to date with the latest evolutions within SELinux. There are no earth
shattering changes, so the second edition isn't suddenly deprecated. The examples
are brought up to date with a recent distribution setup, for which I used
Gentoo Linux and CentOS.&lt;/p&gt;
&lt;p&gt;The latter is, given the recent announcement of CentOS stopping support for
CentOS version 8 in general, a bit confrontational, although it doesn't
really matter that much for the scope of the book. I hope that &lt;a href="https://rockylinux.org/"&gt;Rocky
Linux&lt;/a&gt; will get the focus and support it deserves.&lt;/p&gt;
&lt;p&gt;Anyway, I digress. A significant part of the updates on the existing content
is on SELinux-enabled applications, applications that act as a so-called object
manager themselves. While quite a few were already covered in the past, these
applications continue to enhance their SELinux support, and in the third edition
a few of these receive a full dedicated chapter.&lt;/p&gt;
&lt;p&gt;There are also a small set of SELinux behavioral changes, like SELinux' NNP
support, as well as SELinux userspace changes like specific extended attributes
for restorecon.&lt;/p&gt;
&lt;p&gt;Most of the book though isn't about changes, but about new content.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What has been added&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As administrators face SELinux-aware applications more and more, the book
goes into much more detail on how to tune SELinux with those SELinux-aware
applications. If we look at the book's structure, you'll find that it has
roughly three parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Using SELinux, which covers the fundamentals of using SELinux and
   understanding what SELinux is.&lt;/li&gt;
&lt;li&gt;SELinux-aware platforms, which dives into the SELinux-aware application
   suites that administrators might come in contact with&lt;/li&gt;
&lt;li&gt;Policy management, which focuses on managing, analyzing and even
   developing SELinux policies.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By including additional content on SEPostgreSQL, libvirt, container
platforms like Kubernetes, and even Xen Security Modules (which is not
SELinux itself, but strongly influenced and aligned to it to the level
that it even uses the SELinux userspace utilities) the book is showing how
wide SELinux is being used.&lt;/p&gt;
&lt;p&gt;Even on policy development, the book now includes more support than before.
While another book of mine, SELinux Cookbook, is more applicable to policy
development, I did not want to keep administrators out of the loop on how
to develop SELinux policies at all. Especially not since there are more
tools available nowadays that support policy creation, like udica.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELinux CIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One of the changes I also introduced in the book is to include SELinux
Common Intermediate Language (CIL) information and support. When we need
to add in a small SELinux policy change, the book will suggest CIL based
changes as well.&lt;/p&gt;
&lt;p&gt;SELinux CIL is not commonly used in large-scale policy development. Or at
least, not directly. The most significant policy development out there,
the &lt;a href="https://github.com/SELinuxProject/refpolicy/wiki"&gt;SELinux Reference Policy&lt;/a&gt;,
does not use CIL directly itself, and the level of support you find for
the current development approach is very much the default way of working. So
I do not ignore this more traditional approach.&lt;/p&gt;
&lt;p&gt;The reason I did include more CIL focus is because CIL has a few advantages
up its sleeve that is harder to get with the traditional language. Nothing
major perhaps, but enough that I feel it should be more actively promoted
anyway. And this book is hopefully a nice start to it.&lt;/p&gt;
&lt;p&gt;I hope the book is a good read for administrators or even architects that
would like to know more about the technology.&lt;/p&gt;
</content><category term="SELinux"></category><category term="selinux"></category><category term="packt"></category><category term="book"></category></entry><entry><title>SELinux and extended permissions</title><link href="https://blog.siphos.be/2017/11/selinux-and-extended-permissions/" rel="alternate"></link><published>2017-11-20T17:00:00+01:00</published><updated>2017-11-20T17:00:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-11-20:/2017/11/selinux-and-extended-permissions/</id><summary type="html">&lt;p&gt;One of the features present in the &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Releases"&gt;August release&lt;/a&gt; of the SELinux user space is its support for ioctl xperm rules in modular policies. In the past, this was only possible in monolithic ones (and CIL). Through this, allow rules can be extended to not only cover source (domain) and target (resource) identifiers, but also a specific number on which it applies. And ioctl's are the first (and currently only) permission on which this is implemented.&lt;/p&gt;
&lt;p&gt;Note that ioctl-level permission controls isn't a new feature by itself, but the fact that it can be used in modular policies is.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;One of the features present in the &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Releases"&gt;August release&lt;/a&gt; of the SELinux user space is its support for ioctl xperm rules in modular policies. In the past, this was only possible in monolithic ones (and CIL). Through this, allow rules can be extended to not only cover source (domain) and target (resource) identifiers, but also a specific number on which it applies. And ioctl's are the first (and currently only) permission on which this is implemented.&lt;/p&gt;
&lt;p&gt;Note that ioctl-level permission controls isn't a new feature by itself, but the fact that it can be used in modular policies is.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;What is ioctl?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Many interactions on a Linux system are done through system calls. From a security perspective, most system calls can be properly categorized based on who is executing the call and what the target of the call is. For instance, the unlink() system call has the following prototype:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int unlink(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Considering that a process (source) is executing unlink (system call) against a target (path) is sufficient for most security implementations. Either the source has the permission to unlink that file or directory, or it hasn't. SELinux maps this to the unlink permission within the file or directory classes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : { file dir }  unlink;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, &lt;code&gt;ioctl()&lt;/code&gt; is somewhat different. It is a system call that allows device-specific operations which cannot be expressed by regular system calls. Devices can have multiple functions/capabilities, and with &lt;code&gt;ioctl()&lt;/code&gt; these capabilities can be interrogated or updated. It has the following interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int ioctl(int fd, unsigned long request, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The file descriptor is the target device on which an operation is launched. The second argument is the request, which is an integer whose value identifiers what kind of operation the &lt;code&gt;ioctl()&lt;/code&gt; call is trying to execute. So unlike regular system calls, where the operation itself is the system call, &lt;code&gt;ioctl()&lt;/code&gt; actually has a parameter that identifies this.&lt;/p&gt;
&lt;p&gt;A list of possible parameter values on a socket for instance is available in the Linux kernel source code, under &lt;a href="https://elixir.free-electrons.com/linux/latest/source/include/uapi/linux/sockios.h"&gt;include/uapi/linnux/sockios.h&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELinux allowxperm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For SELinux, having the purpose of the call as part of a parameter means that a regular mapping isn't sufficient. Allowing &lt;code&gt;ioctl()&lt;/code&gt; commands for a domain against a resource is expressed as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : &amp;lt;class&amp;gt; ioctl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This of course does not allow policy developers to differentiate between harmless or informative calls (like SIOCGIFHWADDR to obtain the hardware address associated with a network device) and impactful calls (like SIOCADDRT to add a routing table entry).&lt;/p&gt;
&lt;p&gt;To allow for a fine-grained policy approach, the SELinux developers introduced an extended allow permission, which is capable of differentiating based on an integer value.&lt;/p&gt;
&lt;p&gt;For instance, to allow a domain to get a hardware address (SIOCGIFHWADDR, which is 0x8927) from a TCP socket:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allowxperm &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : tcp_socket ioctl 0x8927;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This additional parameter can also be ranged:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allowxperm &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : &amp;lt;class&amp;gt; ioctl 0x8910-0x8927;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And of course, it can also be used to complement (i.e. allow all ioctl parameters except a certain value):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allowxperm &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : &amp;lt;class&amp;gt; ioctl ~0x8927;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Small or negligible performance hit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;According to a &lt;a href="http://kernsec.org/files/lss2015/vanderstoep.pdf"&gt;presentation given by Jeff Vander Stoep&lt;/a&gt; on the Linux Security Summit in 2015, the performance impact of this addition in SELinux is well under control, which helped in the introduction of this capability in the Android SELinux implementation.&lt;/p&gt;
&lt;p&gt;As a result, interested readers can find examples of allowxperm invocations in the SELinux policy in Android, such as in the &lt;a href="https://android.googlesource.com/platform/system/sepolicy/+/master/private/app.te"&gt;app.te&lt;/a&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# only allow unprivileged socket ioctl commands
allowxperm { appdomain -bluetooth } self:{ rawip_socket tcp_socket udp_socket } ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with that, we again show how fine-grained the SELinux access controls can be.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="ioctl"></category></entry><entry><title>SELinux Userspace 2.7</title><link href="https://blog.siphos.be/2017/09/selinux-userspace-2.7/" rel="alternate"></link><published>2017-09-26T14:50:00+02:00</published><updated>2017-09-26T14:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-09-26:/2017/09/selinux-userspace-2.7/</id><summary type="html">&lt;p&gt;A few days ago, &lt;a href="http://blog.perfinion.com/"&gt;Jason "perfinion" Zaman&lt;/a&gt; stabilized the 2.7 SELinux userspace on
Gentoo. This release has quite a &lt;a href="https://raw.githubusercontent.com/wiki/SELinuxProject/selinux/files/releases/20170804/RELEASE-20170804.txt"&gt;few new features&lt;/a&gt;, which I'll cover in later
posts, but for distribution packagers the main change is that the userspace
now has many more components to package. The project has split up the
policycoreutils package in separate packages so that deployments can be made
more specific.&lt;/p&gt;
&lt;p&gt;Let's take a look at all the various userspace packages again, learn what their
purpose is, so that you can decide if they're needed or not on a system. Also,
when I cover the contents of a package, be aware that it is based on the deployment
on my system, which might or might not be a complete installation (as with Gentoo,
different USE flags can trigger different package deployments).&lt;/p&gt;
</summary><content type="html">&lt;p&gt;A few days ago, &lt;a href="http://blog.perfinion.com/"&gt;Jason "perfinion" Zaman&lt;/a&gt; stabilized the 2.7 SELinux userspace on
Gentoo. This release has quite a &lt;a href="https://raw.githubusercontent.com/wiki/SELinuxProject/selinux/files/releases/20170804/RELEASE-20170804.txt"&gt;few new features&lt;/a&gt;, which I'll cover in later
posts, but for distribution packagers the main change is that the userspace
now has many more components to package. The project has split up the
policycoreutils package in separate packages so that deployments can be made
more specific.&lt;/p&gt;
&lt;p&gt;Let's take a look at all the various userspace packages again, learn what their
purpose is, so that you can decide if they're needed or not on a system. Also,
when I cover the contents of a package, be aware that it is based on the deployment
on my system, which might or might not be a complete installation (as with Gentoo,
different USE flags can trigger different package deployments).&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;libsepol - manipulating SELinux binary policies&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The first package, known in Gentoo as &lt;code&gt;sys-libs/libsepol&lt;/code&gt;, is the library that
enables manipulating the SELinux binary policies. This is a core library, and is
the first SELinux userspace package that is installed on a system.&lt;/p&gt;
&lt;p&gt;It contains one command, &lt;code&gt;chkcon&lt;/code&gt;, which allows users to validate if a specific
security context exists within a binary policy file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ chkcon policy.29 user_u:user_r:mozilla_t:s0
user_u:user_r:mozilla_t:s0 is valid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The package does contain two manpages of old commands which are no longer available
(or I'm blind, either way, they're not installed and not found in the SELinux userspace
repository either) such as genpolusers and genpolbools.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libselinux - the main SELinux handling library&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The libselinux library, known in Gentoo as &lt;code&gt;sys-libs/libselinux&lt;/code&gt;, is the main SELinux
library. Almost all applications that are SELinux-aware (meaning they not only know SELinux
is a thing, but are actively modifying their behavior with SELinux-specific code) will
link to libselinux.&lt;/p&gt;
&lt;p&gt;Because it is so core, the package also provides the necessary bindings for different
scripting languages besides the standard shared objects approach, namely Python (as
many SELinux related tooling is written in Python) and Ruby.&lt;/p&gt;
&lt;p&gt;Next to the bindings and libraries, libselinux also offers quite a few executables
to query and manipulate SELinux settings on the system, which are shortly described
on the &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Tools"&gt;SELinux userspace wiki&lt;/a&gt; but repeated here for convenience. Most of these
are meant for debugging purposes, as they are simple wrappers toward the libselinux
provided functions, but some of them are often used by administrations.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;avcstat&lt;/code&gt; gives statistics about the in-kernel access vector cache, such as number
  of lookups, hits and misses&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_create&lt;/code&gt; queries the kernel security server for a transition decision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_av&lt;/code&gt; queries the kernel security server for an access vector decision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_relabel&lt;/code&gt; queries the kernel security server for a relabel decision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_member&lt;/code&gt; queries the kernel security server for a labeling decision on a
  polyinstantiated object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getconlist&lt;/code&gt; uses the &lt;code&gt;security\_compute\_user()&lt;/code&gt; function, and orders the resulting
  list based on the &lt;code&gt;default\_contexts&lt;/code&gt; file and per-user context files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getdefaultcon&lt;/code&gt; is like &lt;code&gt;getconlist&lt;/code&gt; but only returns the first context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_user&lt;/code&gt; queries the kernel security server fo a set of reachable user contexts
  from a source context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getfilecon&lt;/code&gt; gets the context of a file by path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getpidcon&lt;/code&gt; gets the context of a process by PID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getseuser&lt;/code&gt; queries the &lt;code&gt;seuser&lt;/code&gt; file for the resulting SELinux user and contxt for a
  particular linux login and login context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getsebool&lt;/code&gt; gets the current state of a SELinux boolean in the SELinux security server&lt;/li&gt;
&lt;li&gt;&lt;code&gt;matchpathcon&lt;/code&gt; queries the active filecontext file for how a particular path should
  be labeled&lt;/li&gt;
&lt;li&gt;&lt;code&gt;policyvers&lt;/code&gt; queries the kernel security server for the maximum policy version supported&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getenforce&lt;/code&gt; gets the enforcing state of the kernel access vector cache&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sefcontext_compile&lt;/code&gt; generates binary filecontext files, optimized for fast querying&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_lookup&lt;/code&gt; looks up what the target default context is for various classes
  (supporting the X related SELinux types, database types, etc.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_digest&lt;/code&gt; calculates the SHA1 digest of spec files, and returns a list
  of the specfiles used to calculate the digest. This is used by Android.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_partial_match&lt;/code&gt; determines if a direct or partial match is possible
  on a file path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_lookup_best_match&lt;/code&gt; obtains the best matching SELinux security context
  for file-based operations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinux_check_securetty_context&lt;/code&gt; checks whether a SELinux tty security context
  is defined as a securetty context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinux_check_access&lt;/code&gt; checks if the source context has the access permission
  for the specified class on the target context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinuxexeccon&lt;/code&gt; reports the SELinux context for an executable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinuxenabled&lt;/code&gt; returns if SELinux is enabled or not&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setfilecon&lt;/code&gt; sets the context of a path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setenforce&lt;/code&gt; sets the enforcing state of the kernel access vector cache&lt;/li&gt;
&lt;li&gt;&lt;code&gt;togglesebool&lt;/code&gt; toggles a SELinux boolean, but only runtime (so it does not
  persist across reboots)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;checkpolicy - policy compiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The checkpolicy package, known in Gentoo as &lt;code&gt;sys-apps/checkpolicy&lt;/code&gt;, provides two
main applications, &lt;code&gt;checkpolicy&lt;/code&gt; and &lt;code&gt;checkmodule&lt;/code&gt;. Both applications are compilers
(unlike what the name implies) which build a binary SELinux policy. The main difference
between these two is that one builds a policy binary, whereas the other one builds a 
SELinux module binary.&lt;/p&gt;
&lt;p&gt;Developers don't often call these applications themselves, but use the build scripts.
For instance, the &lt;code&gt;semodule_package&lt;/code&gt; binary would be used to combine the binary policy
with additional files such as file contexts.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libsemanage - facilitating use of SELinux overall&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The libsemanage library, known in Gentoo as &lt;code&gt;sys-libs/libsemanage&lt;/code&gt;, contains SELinux
supporting functions that are needed for any regular SELinux use. Whereas libselinux
would be used everywhere, even for embedded systems, libsemanage is generally not for
embedded systems but is very important for Linux systems in overall.&lt;/p&gt;
&lt;p&gt;Most SELinux management applications that administrators come in contact with will be
linked with the libsemanage library. As can be expected, the &lt;code&gt;semanage&lt;/code&gt; application
as offered by the &lt;code&gt;selinux-python&lt;/code&gt; package is one of them.&lt;/p&gt;
&lt;p&gt;The only application that is provided by libsemanage is the &lt;code&gt;semanage_migrate_store&lt;/code&gt;,
used to migrate the policy store from the &lt;code&gt;/etc/selinux&lt;/code&gt; to the &lt;code&gt;/var/lib/selinux&lt;/code&gt;
location. This was done with the introduction of the 2.4 userspace.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-python - Python-based command-line management utilities&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-python package, known in Gentoo as &lt;code&gt;sys-apps/selinux-python&lt;/code&gt;, is one of
the split packages that originally where part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. It
contains the majority of management utilities that administrators use for handling
SELinux on their systems.&lt;/p&gt;
&lt;p&gt;The most known application here is &lt;code&gt;semanage&lt;/code&gt;, but it contains quite a few others
as well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sepolgen&lt;/code&gt; generates an initial SELinux policy module template, and is short for
  the &lt;code&gt;sepolicy generate&lt;/code&gt; command&lt;/li&gt;
&lt;li&gt;&lt;code&gt;audit2why&lt;/code&gt; translates SELinux audit messages into a description of why the access
  was denied. It is short for the &lt;code&gt;audit2allow -w&lt;/code&gt; command.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;audit2allow&lt;/code&gt; generates SELinux policy allow/dontaudit rules from logs of denied
  operations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sepolgen-ifgen&lt;/code&gt; generates an overview of available interfaces. This overview is used
  by &lt;code&gt;audit2allow&lt;/code&gt; to guess the right interface to use when allowing or dontauditing certain
  operations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sepolicy&lt;/code&gt; is the SELinux policy inspection tool, allowing to query various aspects of
  a SELinux configuration (namely booleans, communication flows, interfaces, network information
  and transition information). It also provides the ability to generate skeleton policies (as
  described with &lt;code&gt;sepolgen&lt;/code&gt;) and manual pages.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chcat&lt;/code&gt; changes a file's SELinux security category&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sepolgen-ifgen-attr-helper&lt;/code&gt; generates an overview of attributes and attribute mappings.
  This overview is used by &lt;code&gt;audit2allow&lt;/code&gt; to guess the right attribute to use when allowing
  or dontauditing certain operations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semanage&lt;/code&gt; is a SELinux policy management tool, allowing a multitude of operations
  against the SELinux policy and the configuration. This includes definition import/export,
  login mappings, user definitions, ports and interface management, module handling, 
  file contexts, booleans and more.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;semodule-utils - Developing SELinux modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The semodule-utils package, known in Gentoo as &lt;code&gt;sys-apps/semodule-utils&lt;/code&gt;, is another split package
that originally was part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. In it, SELinux policy module
development utilities are provided. The package is not needed for basic operations such
as loading and unloading modules though.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;semodule_expand&lt;/code&gt; expands a SELinux base module package into a kernel binary policy file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_deps&lt;/code&gt; shows the dependencies between SELinux policy packages&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_link&lt;/code&gt; links SELinux policy module packages together into a single SELinux policy
  module&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_unpackage&lt;/code&gt; extracts a SELinux module into the binary policy and its associated
  files (such as file context definitions)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_package&lt;/code&gt; combines a modular binary policy file with its associated files (such
  as file context definitions) into a module package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;mcstrans - Translate context info in human readable names&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The mcstrans package, known in Gentoo as &lt;code&gt;sys-apps/mcstrans&lt;/code&gt;, is another split package
that originally was part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. In it, the MCS translation
daemon is hosted. This daemon translates the SELinux-specific context ranges, like 
&lt;code&gt;s0-s0:c0.c1024&lt;/code&gt; to a human-readable set, like &lt;code&gt;SystemLow-SystemHigh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is a purely cosmetic approach (as SELinux internally always uses the sensitivity
and category numbers) but helps when dealing with a large number of separate categories.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;restorecond - Automatically resetting file contexts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The restorecond package, known in Gentoo as &lt;code&gt;sys-apps/restorecond&lt;/code&gt;, is another split
package that originally was part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. It contains the
&lt;code&gt;restorecond&lt;/code&gt; daemon, which watches over files and directories and forces the right
SELinux label on it.&lt;/p&gt;
&lt;p&gt;This daemon was originally intended to resolve a missing feature in SELinux (having
more fine-grained rules for label naming) but with the named file transition support, the
need for this daemon has diminished a lot.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;secilc - SELinux common intermediate language compiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The secilc package, known in Gentoo as &lt;code&gt;sys-apps/secilc&lt;/code&gt;, is the CIL compiler which
builds kernel binary policies based on the passed on CIL code. Although the majority
of policy development still uses the more traditional SELinux language (and supporting
macro's from the reference policy), developers can already use CIL code for policy generation.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;secilc&lt;/code&gt;, a final policy file can be generated through the CIL code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-dbus - SELinux DBus server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-dbus package (not packaged in Gentoo at this moment) provides a SELinux DBus
service which systems can use to query and interact with SELinux management utilities
on the system. If installed, the &lt;code&gt;org.selinux&lt;/code&gt; domain is used for various supported
operations (such as listing SELinux modules, through &lt;code&gt;org.selinux.semodule_list&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-gui - Graphical SELinux settings manager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-gui package (not packaged in Gentoo at this moment) provides the
&lt;code&gt;system-config-selinux&lt;/code&gt; application which offers basic SELinux management support
in a graphical application. It supports boolean handling, file labeling, user mapping,
SELinux user management, network port definitions and module handling. As such, it can
be seen as the graphical helper utility for the &lt;code&gt;semanage&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-sandbox - Sandbox utility utilizing SELinux sandbox domains&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-sandbox package (not packaged in Gentoo at this moment) is a set of scripts
to facilitate the creation of SELinux sandboxes. With these utilities, which not only
use SELinux sandbox domains like &lt;code&gt;sandbox_t&lt;/code&gt; but also Linux namespaces, end users can
launch applications in a restricted environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;policycoreutils - Core SELinux management utilities&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The policycoreutils package, known in Gentoo as &lt;code&gt;sys-apps/policycoreutils&lt;/code&gt;, contains 
basic SELinux tooling which is necessary to handle SELinux in a regular environment.
Supported utilities are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newrole&lt;/code&gt; to switch a user session from one role to another&lt;/li&gt;
&lt;li&gt;&lt;code&gt;secon&lt;/code&gt; to query the SELinux context of a file, program or user input&lt;/li&gt;
&lt;li&gt;&lt;code&gt;genhomedircon&lt;/code&gt; to regenerate home directory context files, necessary when new users are
  defined on the system&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setfiles&lt;/code&gt; to set SELinux file security contexts on resources&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule&lt;/code&gt; to list, load and unload SELinux modules&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run_init&lt;/code&gt; to launch an init script in the right domain&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open_init_pty&lt;/code&gt; to run a program under a pseudo terminal with the right context set&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sestatus&lt;/code&gt; to query current policy status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setsebool&lt;/code&gt; to set and, if wanted, persist a SELinux boolean value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinuxconfig&lt;/code&gt; to display the current active configuration paths&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restorecon&lt;/code&gt; to set SELinux file security contexts on resources&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load_policy&lt;/code&gt; to load the SELinux policy, generally called from initramfs systems if the
  init system is not SELinux-aware&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restorecon_xattr&lt;/code&gt; manages the &lt;code&gt;security.restorecon_last&lt;/code&gt; extended attribute which is set
  by &lt;code&gt;setfiles&lt;/code&gt; or &lt;code&gt;restorecon&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gentoo also adds in two additional scripts:
* &lt;code&gt;rlpkg&lt;/code&gt; to reset file contexts on files provided by a Gentoo package
* &lt;code&gt;selocal&lt;/code&gt; to easily handle small SELinux rule additions to the active policy&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There are even more&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Attentive readers will notice that the &lt;code&gt;setools&lt;/code&gt; package is not discussed here. This package
is not provided by the SELinux userspace project, but is an important package for SELinux
policy developers as it contains the &lt;code&gt;sesearch&lt;/code&gt; command - an often used command to query
the active policy.&lt;/p&gt;
&lt;p&gt;The above list is thus a picture of the SELinux userspace utilities, which is becoming
quite a big application set now that some functionality is split off from the &lt;code&gt;policycoreutils&lt;/code&gt;
package.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="userspace"></category></entry><entry><title>Using nVidia with SELinux</title><link href="https://blog.siphos.be/2017/08/using-nvidia-with-selinux/" rel="alternate"></link><published>2017-08-23T19:04:00+02:00</published><updated>2017-08-23T19:04:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-08-23:/2017/08/using-nvidia-with-selinux/</id><summary type="html">&lt;p&gt;Yesterday I've &lt;a href="http://blog.siphos.be/2017/08/switch-to-gentoo-sources/"&gt;switched to the gentoo-sources kernel package&lt;/a&gt; on Gentoo Linux.
And with that, I also attempted (succesfully) to use the propriatary nvidia drivers
so that I can enjoy both a smoother 3D experience while playing minecraft, as well
as use the CUDA support so I don't need to use cloud-based services for small
exercises.&lt;/p&gt;
&lt;p&gt;The move to nvidia was quite simple, as the &lt;a href="https://wiki.gentoo.org/wiki/NVidia/nvidia-drivers"&gt;nvidia-drivers wiki article&lt;/a&gt; on
the Gentoo wiki was quite easy to follow.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Yesterday I've &lt;a href="http://blog.siphos.be/2017/08/switch-to-gentoo-sources/"&gt;switched to the gentoo-sources kernel package&lt;/a&gt; on Gentoo Linux.
And with that, I also attempted (succesfully) to use the propriatary nvidia drivers
so that I can enjoy both a smoother 3D experience while playing minecraft, as well
as use the CUDA support so I don't need to use cloud-based services for small
exercises.&lt;/p&gt;
&lt;p&gt;The move to nvidia was quite simple, as the &lt;a href="https://wiki.gentoo.org/wiki/NVidia/nvidia-drivers"&gt;nvidia-drivers wiki article&lt;/a&gt; on
the Gentoo wiki was quite easy to follow.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Signing the modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One difference I found with the article (which I've promply changed) is that
the signing command, necessary to sign the Linux kernel modules so that they
can be loaded (as unsigned or wrongly signed modules are not allowed on the
system), was different.&lt;/p&gt;
&lt;p&gt;It used to be as follows (example for a single module, it had to be repeated
for each affected kernel module):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# perl /usr/src/linux/scripts/sign-file sha512 \
      /usr/src/linux/signing_key.priv \
      /usr/src/linux/signing_key.x509 \
      /lib/modules/4.12.5-gentoo/video/nvidia-uvm.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, from version 4.3.3 onward (as also explained by this excellent
&lt;a href="https://wiki.gentoo.org/wiki/Signed_kernel_module_support"&gt;Signed kernel module support article&lt;/a&gt; on the Gentoo wiki) this command
no longer uses a Perl script, but is an ELF binary. Also, the location
of the default signing key is moved into a &lt;code&gt;certs/&lt;/code&gt; subdirectory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enabling nvidia device files&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When the nvidia modules are loaded, additional device files are enabled.
One is the &lt;code&gt;nvidia0&lt;/code&gt; character device file, while the other is the
&lt;code&gt;nvidiactl&lt;/code&gt; character device file. And although I can imagine that the
&lt;code&gt;nvidiactl&lt;/code&gt; one is a control-related device file, I don't exactly know
for sure.&lt;/p&gt;
&lt;p&gt;However, attempts to use 3D applications showed (through SELinux denials)
that access to these device files is needed. Without that, applications just
crashed, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;org.lwjgl.LWJGLException: X Error - disp: 0x7fd164907b00 serial: 150 error: BadValue (integer parameter out of range for operation) request_code: 153 minor_code: 24
        at org.lwjgl.opengl.LinuxDisplay.globalErrorHandler(LinuxDisplay.java:320)
        at org.lwjgl.opengl.LinuxContextImplementation.nCreate(Native Method)
        at org.lwjgl.opengl.LinuxContextImplementation.create(LinuxContextImplementation.java:51)
        at org.lwjgl.opengl.ContextGL.&amp;lt;init&amp;gt;(ContextGL.java:132)
        at org.lwjgl.opengl.Display.create(Display.java:850)
        at org.lwjgl.opengl.Display.create(Display.java:757)
        at org.lwjgl.opengl.Display.create(Display.java:739)
        at bib.at(SourceFile:635)
        at bib.aq(SourceFile:458)
        at bib.a(SourceFile:404)
        at net.minecraft.client.main.Main.main(SourceFile:123)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Not really useful to debug for me, but the SELinux denials were a bit more obvious,
showing requests for read and write to the &lt;code&gt;nvidiactl&lt;/code&gt; character device.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;code&gt;matchpathcon&lt;/code&gt; I found out that the device files had to have the
&lt;code&gt;xserver_misc_device_t&lt;/code&gt; type (which they didn't have to begin with, as the device
files were added after the automated &lt;code&gt;restorecon&lt;/code&gt; was done on the &lt;code&gt;/dev&lt;/code&gt; location).&lt;/p&gt;
&lt;p&gt;So, adding the following command to my local init script fixed the context setting
at boot up:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;restorecon /dev/nvidiactl /dev/nvidia0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Also, the domains that needed to use nVidia had to receive the following
addition SELinux-policy-wise:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dev_rw_xserver_misc(...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Perhaps this can be made more fine-grained (as there are several other device
files marked as &lt;code&gt;xserver_misc_device_t&lt;/code&gt;) but for now this should suffice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Optimus usage with X server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The other challenge I had was that my workstation uses an integrated Intel
device, and offloads calculations and rendering to nVidia. The detection by
X server did not work automatically though, and it took some fiddling to get
it to work.&lt;/p&gt;
&lt;p&gt;In the end, I had to add in an &lt;code&gt;nvidia.conf&lt;/code&gt; file inside &lt;code&gt;/etc/X11/xorg.conf.d&lt;/code&gt;
with the following content:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Section &amp;quot;ServerLayout&amp;quot;
        Identifier      &amp;quot;layout&amp;quot;
        Screen  0       &amp;quot;nvidia&amp;quot;
        Inactive        &amp;quot;intel&amp;quot;
EndSection

Section &amp;quot;Device&amp;quot;
        Identifier      &amp;quot;nvidia&amp;quot;
        Driver          &amp;quot;nvidia&amp;quot;
        BusID           &amp;quot;PCI:1:0:0&amp;quot;
EndSection

Section &amp;quot;Screen&amp;quot;
        Identifier      &amp;quot;nvidia&amp;quot;
        Device          &amp;quot;nvidia&amp;quot;
        Option          &amp;quot;AllowEmptyInitialConfiguration&amp;quot;
EndSection

Section &amp;quot;Device&amp;quot;
        Identifier      &amp;quot;intel&amp;quot;
        Driver          &amp;quot;modesetting&amp;quot;
EndSection

Section &amp;quot;Screen&amp;quot;
        Identifier      &amp;quot;intel&amp;quot;
        Device          &amp;quot;intel&amp;quot;
EndSection
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with a single &lt;code&gt;xrandr&lt;/code&gt; command I re-enabled split screen support (as by
default it now showed the same output on both screens):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ xrandr --output eDP-1-1 --left-of HDMI-1-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I also had to set the output source to the nVidia device, by adding the following
lines to my &lt;code&gt;~/.xinitrc&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xrandr --setprovideroutputsource modesetting NVIDIA-0
xrandr --auto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with that, another thing was crossed off from my TODO list. Which has become
quite large after my holidays (went to Kos, Greece) as I had many books and articles
on my ebook reader with me, which inspired a lot.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="nvidia"></category></entry><entry><title>SELinux System Administration, 2nd Edition</title><link href="https://blog.siphos.be/2016/12/selinux-system-administration-2nd-edition/" rel="alternate"></link><published>2016-12-22T19:26:00+01:00</published><updated>2016-12-22T19:26:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2016-12-22:/2016/12/selinux-system-administration-2nd-edition/</id><content type="html">&lt;p&gt;While still working on a few other projects, one of the time consumers of the
past half year (haven't you noticed? my blog was quite silent) has come to an
end: the &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-system-administration-second-edition"&gt;SELinux System Administration - Second Edition&lt;/a&gt;
book is now available. With almost double the amount of pages and a serious
update of the content, the book can now be bought either through Packt Publishing
itself, or the various online bookstores such as &lt;a href="https://www.amazon.com/SELinux-System-Administration-Sven-Vermeulen-ebook/dp/B01LWM02WI"&gt;Amazon&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With the holidays now approaching, I hope to be able to execute a few tasks
within the Gentoo community (and of the Gentoo Foundation) and get back on track.
Luckily, my absence was not jeopardizing the state of &lt;a href="https://wiki.gentoo.org/wiki/SELinux"&gt;SELinux&lt;/a&gt;
in Gentoo thanks to the efforts of Jason Zaman.&lt;/p&gt;
</content><category term="SELinux"></category><category term="selinux"></category><category term="gentoo"></category><category term="rhel"></category><category term="redhat"></category><category term="packt"></category><category term="book"></category><category term="publishing"></category></entry><entry><title>We do not ship SELinux sandbox</title><link href="https://blog.siphos.be/2016/09/we-do-not-ship-selinux-sandbox/" rel="alternate"></link><published>2016-09-27T20:47:00+02:00</published><updated>2016-09-27T20:47:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2016-09-27:/2016/09/we-do-not-ship-selinux-sandbox/</id><summary type="html">&lt;p&gt;A few days ago a vulnerability was reported in the SELinux sandbox user space
utility. The utility is part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. Luckily, Gentoo's
&lt;code&gt;sys-apps/policycoreutils&lt;/code&gt; package is not vulnerable - and not because we were
clairvoyant about this issue, but because we don't ship this utility.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;A few days ago a vulnerability was reported in the SELinux sandbox user space
utility. The utility is part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. Luckily, Gentoo's
&lt;code&gt;sys-apps/policycoreutils&lt;/code&gt; package is not vulnerable - and not because we were
clairvoyant about this issue, but because we don't ship this utility.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;What is the SELinux sandbox?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SELinux sandbox utility, aptly named &lt;code&gt;sandbox&lt;/code&gt;, is a simple C application which
executes its arguments, but only after ensuring that the task it launches is
going to run in the &lt;code&gt;sandbox_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;This domain is specifically crafted to allow applications most standard privileges
needed for interacting with the user (so that the user can of course still use the
application) but removes many permissions that might be abused to either obtain 
information from the system, or use to try and exploit vulnerabilities to gain
more privileges. It also hides a number of resources on the system through
namespaces.&lt;/p&gt;
&lt;p&gt;It was &lt;a href="http://danwalsh.livejournal.com/28545.html"&gt;developed in 2009&lt;/a&gt; for Fedora
and Red Hat. Given the necessary SELinux policy support though, it was usable on
other distributions as well, and thus became part of the SELinux user space itself.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What is the vulnerability about?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SELinux sandbox utility used an execution approach that did not shield off
the users' terminal access sufficiently. In the &lt;a href="http://www.openwall.com/lists/oss-security/2016/09/25/1"&gt;POC post&lt;/a&gt;
we notice that characters could be sent to the terminal through the &lt;code&gt;ioctl()&lt;/code&gt;
function (which executes the ioctl system call used for input/output operations
against devices) which are eventually executed when the application finishes.&lt;/p&gt;
&lt;p&gt;That's bad of course. Hence the CVE-2016-7545 registration, and of course also
a possible &lt;a href="https://github.com/SELinuxProject/selinux/commit/acca96a135a4d2a028ba9b636886af99c0915379"&gt;fix has been committed upstream&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Why isn't Gentoo vulnerable / shipping with SELinux sandbox?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There's some history involved why Gentoo does not ship the SELinux sandbox (anymore).&lt;/p&gt;
&lt;p&gt;First of all, Gentoo already has a command that is called &lt;code&gt;sandbox&lt;/code&gt;, installed through
the &lt;code&gt;sys-apps/sandbox&lt;/code&gt; application. So back in the days that we still shipped with
the SELinux sandbox, we continuously had to patch &lt;code&gt;policycoreutils&lt;/code&gt; to use a
different name for the sandbox application (we used &lt;code&gt;sesandbox&lt;/code&gt; then).&lt;/p&gt;
&lt;p&gt;But then we had a couple of security issues with the SELinux sandbox application.
In 2011, &lt;a href="http://www.cvedetails.com/cve/CVE-2011-1011/"&gt;CVE-2011-1011&lt;/a&gt;
came up in which the &lt;code&gt;seunshare_mount&lt;/code&gt; function had a security issue. And in 2014,
&lt;a href="http://www.cvedetails.com/cve/CVE-2014-3215/"&gt;CVE-2014-3215&lt;/a&gt; came up with - again -
a security issue with &lt;code&gt;seunshare&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At that point, I had enough of this sandbox utility. First of all, it never quite worked
enough on Gentoo as it is (as it also requires a policy which is not part of the
upstream release) and given its wide open access approach (it was meant to contain
various types of workloads, so security concessions had to be made), I decided to
&lt;a href="http://blog.siphos.be/2014/05/dropping-sesandbox-support/"&gt;no longer support the SELinux sandbox in Gentoo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;None of the Gentoo SELinux users ever approached me with the question to add it back.&lt;/p&gt;
&lt;p&gt;And that is why Gentoo is not vulnerable to this specific issue.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="sandbox"></category><category term="gentoo"></category><category term="vulnerability"></category><category term="seunshare"></category></entry><entry><title>Getting su to work in init scripts</title><link href="https://blog.siphos.be/2015/09/getting-su-to-work-in-init-scripts/" rel="alternate"></link><published>2015-09-14T16:37:00+02:00</published><updated>2015-09-14T16:37:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-09-14:/2015/09/getting-su-to-work-in-init-scripts/</id><summary type="html">&lt;p&gt;While developing an init script which has to switch user, I got a couple of
errors from SELinux and the system itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;~# rc-service hadoop-namenode format&lt;/span&gt;
&lt;span class="go"&gt;Authenticating root.&lt;/span&gt;
&lt;span class="go"&gt; * Formatting HDFS ...&lt;/span&gt;
&lt;span class="go"&gt;su: Authentication service cannot retrieve authentication info&lt;/span&gt;
&lt;span class="gp gp-VirtualEnv"&gt;(Ignored)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</summary><content type="html">&lt;p&gt;While developing an init script which has to switch user, I got a couple of
errors from SELinux and the system itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;~# rc-service hadoop-namenode format&lt;/span&gt;
&lt;span class="go"&gt;Authenticating root.&lt;/span&gt;
&lt;span class="go"&gt; * Formatting HDFS ...&lt;/span&gt;
&lt;span class="go"&gt;su: Authentication service cannot retrieve authentication info&lt;/span&gt;
&lt;span class="gp gp-VirtualEnv"&gt;(Ignored)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;The authentication log shows entries such as the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Sep 14 20:20:05 localhost unix_chkpwd[5522]: could not obtain user info (hdfs)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I've always had issues with getting su to work properly again. Now that I have
what I think is a working set, let me document it for later (as I still need to
review why they are needed):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Allow initrc_t to use unix_chkpwd to check entries&lt;/span&gt;
&lt;span class="c1"&gt;# Without it gives the retrieval failure&lt;/span&gt;
&lt;span class="n"&gt;auth_domtrans_chk_passwd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initrc_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Allow initrc_t to query selinux access, otherwise avc assertion&lt;/span&gt;
&lt;span class="n"&gt;allow&lt;/span&gt; &lt;span class="n"&gt;initrc_t&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="ss"&gt;:netlink_selinux_socket&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;selinux_compute_access_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initrc_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Allow initrc_t to honor the pam_rootok setting&lt;/span&gt;
&lt;span class="n"&gt;allow&lt;/span&gt; &lt;span class="n"&gt;initrc_t&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="ss"&gt;:passwd&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;passwd&lt;/span&gt; &lt;span class="n"&gt;rootok&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With these SELinux rules, switching the user works as expected from within an
init script.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="initrc"></category></entry><entry><title>Doing away with interfaces</title><link href="https://blog.siphos.be/2015/08/doing-away-with-interfaces/" rel="alternate"></link><published>2015-08-29T11:30:00+02:00</published><updated>2015-08-29T11:30:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-29:/2015/08/doing-away-with-interfaces/</id><summary type="html">&lt;p&gt;CIL is SELinux' Common Intermediate Language, which brings on a whole new set of
possibilities with policy development. I hardly know CIL but am (slowly)
learning. Of course, the best way to learn is to try and do lots of things with
it, but real-life work and time-to-market for now forces me to stick with the
M4-based refpolicy one.&lt;/p&gt;
&lt;p&gt;Still, I do try out some things here and there, and one of the things I wanted
to look into was how CIL policies would deal with interfaces.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;CIL is SELinux' Common Intermediate Language, which brings on a whole new set of
possibilities with policy development. I hardly know CIL but am (slowly)
learning. Of course, the best way to learn is to try and do lots of things with
it, but real-life work and time-to-market for now forces me to stick with the
M4-based refpolicy one.&lt;/p&gt;
&lt;p&gt;Still, I do try out some things here and there, and one of the things I wanted
to look into was how CIL policies would deal with interfaces.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Recap on interfaces&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With the M4 based reference policy, interfaces are M4 macros that expand into
the standard SELinux rules. They are used by the reference policy to provide 
a way to isolate module-specific code and to have "public" calls.&lt;/p&gt;
&lt;p&gt;Policy modules are not allowed (by convention) to call types or domains that
are not defined by the same module. If they want to interact with those modules,
then they need to call the interface(s):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# module &amp;quot;ntp&amp;quot;
# domtrans: when executing an ntpd_exec_t binary, the resulting process 
#           runs in ntpd_t
interface(`ntp_domtrans&amp;#39;,`
  domtrans_pattern($1, ntpd_exec_t, ntpd_t)
)

# module &amp;quot;hal&amp;quot;
ntp_domtrans(hald_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above example, the purpose is to have &lt;code&gt;hald_t&lt;/code&gt; be able to execute
binaries labeled as &lt;code&gt;ntpd_exec_t&lt;/code&gt; and have the resulting process run as the
&lt;code&gt;ntpd_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;The following would not be allowed inside the hal module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;domtrans_pattern(hald_t, ntpd_exec_t, ntpd_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This would imply that both &lt;code&gt;hald_t&lt;/code&gt;, &lt;code&gt;ntpd_exec_t&lt;/code&gt; and &lt;code&gt;ntpd_t&lt;/code&gt; are defined
by the same module, which is not the case.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interfaces in CIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It &lt;em&gt;seems&lt;/em&gt; that CIL will not use interface files. Perhaps some convention
surrounding it will be created - to know this, we'll have to wait until a
"cilrefpolicy" is created. However, functionally, this is no longer necessary.&lt;/p&gt;
&lt;p&gt;Consider the &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; declaration from a &lt;a href="http://blog.siphos.be/2015/08/filtering-network-access-per-application/"&gt;previous post&lt;/a&gt;.
In it, we wanted to allow &lt;code&gt;mozilla_t&lt;/code&gt; to send and receive these packets. The 
example didn't use an interface-like construction for this, so let's see
how this would be dealt with.&lt;/p&gt;
&lt;p&gt;First, the module is slightly adjusted to create a &lt;em&gt;macro&lt;/em&gt; called &lt;code&gt;myhttp_sendrecv_client_packet&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;macro&lt;/span&gt; &lt;span class="nv"&gt;myhttp_sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Another module would then call this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call&lt;/span&gt; &lt;span class="nv"&gt;myhttp_sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it. When the policy modules are both loaded, then the &lt;code&gt;mozilla_t&lt;/code&gt; domain is able
to send and receive &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; labeled packets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There's more: namespaces&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But it doesn't end there. Whereas the reference policy had a single namespace
for the interfaces, CIL is able to use namespaces. It allows to create an almost
object-like approach for policy development.&lt;/p&gt;
&lt;p&gt;The above &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; definition could be written as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;myhttp&lt;/span&gt;
  &lt;span class="c1"&gt;; MyHTTP client packet&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;roletype&lt;/span&gt; &lt;span class="nv"&gt;object_r&lt;/span&gt; &lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;client_packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;macro&lt;/span&gt; &lt;span class="nv"&gt;sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="nv"&gt;client_packet_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The other module looks as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;mozilla&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call&lt;/span&gt; &lt;span class="nv"&gt;myhttp.sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The result is similar, but not fully the same. The packet is no longer called
&lt;code&gt;myhttp_client_packet_t&lt;/code&gt; but &lt;code&gt;myhttp.client_packet_t&lt;/code&gt;. In other words, a period (&lt;code&gt;.&lt;/code&gt;)
is used to separate the object name (&lt;code&gt;myhttp&lt;/code&gt;) and the object/type (&lt;code&gt;client_packet_t&lt;/code&gt;)
as well as interface/macro (&lt;code&gt;sendrecv_client_packet&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;~$ sesearch -s mozilla_t -c packet -p send -Ad&lt;/span&gt;
&lt;span class="go"&gt;  ...&lt;/span&gt;
&lt;span class="go"&gt;  allow mozilla_t myhttp.client_packet_t : packet { send recv };&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And it looks that namespace support goes even further than that, but I still
need to learn more about it first.&lt;/p&gt;
&lt;p&gt;Still, I find this a good evolution. With CIL interfaces are no longer separate
from the module definition: everything is inside the CIL file. I secretly hope
that tools such as &lt;code&gt;seinfo&lt;/code&gt; would support querying macros as well.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="cil"></category></entry><entry><title>Why we do confine Firefox</title><link href="https://blog.siphos.be/2015/08/why-we-do-confine-firefox/" rel="alternate"></link><published>2015-08-11T19:18:00+02:00</published><updated>2015-08-11T19:18:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-11:/2015/08/why-we-do-confine-firefox/</id><summary type="html">&lt;p&gt;If you're a bit following the SELinux development community you will know
&lt;a href="http://danwalsh.livejournal.com"&gt;Dan Walsh&lt;/a&gt;, a &lt;a href="http://people.redhat.com/dwalsh/"&gt;Red Hat&lt;/a&gt;
security engineer. Today he &lt;a href="http://danwalsh.livejournal.com/72697.html"&gt;blogged&lt;/a&gt; 
about &lt;em&gt;CVE-2015-4495 and SELinux, or why doesn't SELinux confine Firefox&lt;/em&gt;. He 
should've asked why the &lt;em&gt;reference policy&lt;/em&gt; or &lt;em&gt;Red Hat/Fedora policy&lt;/em&gt; does not
confine Firefox, because SELinux is, as I've
&lt;a href="http://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/"&gt;mentioned before&lt;/a&gt;,
not the same as its policy.&lt;/p&gt;
&lt;p&gt;In effect, Gentoo's SELinux policy &lt;em&gt;does&lt;/em&gt; confine Firefox by default. One of the
principles we focus on in Gentoo Hardened is to
&lt;a href="https://wiki.gentoo.org/wiki/Project:SELinux/Development_policy#Develop_desktop_policies"&gt;develop desktop policies&lt;/a&gt;
in order to reduce exposure and information leakage of user documents. We might
not have the manpower to confine all desktop applications, but I do think it is
worthwhile to at least attempt to do this, even though what Dan Walsh mentioned
is also correct: desktops are notoriously difficult to use a mandatory access
control system on.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;If you're a bit following the SELinux development community you will know
&lt;a href="http://danwalsh.livejournal.com"&gt;Dan Walsh&lt;/a&gt;, a &lt;a href="http://people.redhat.com/dwalsh/"&gt;Red Hat&lt;/a&gt;
security engineer. Today he &lt;a href="http://danwalsh.livejournal.com/72697.html"&gt;blogged&lt;/a&gt; 
about &lt;em&gt;CVE-2015-4495 and SELinux, or why doesn't SELinux confine Firefox&lt;/em&gt;. He 
should've asked why the &lt;em&gt;reference policy&lt;/em&gt; or &lt;em&gt;Red Hat/Fedora policy&lt;/em&gt; does not
confine Firefox, because SELinux is, as I've
&lt;a href="http://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/"&gt;mentioned before&lt;/a&gt;,
not the same as its policy.&lt;/p&gt;
&lt;p&gt;In effect, Gentoo's SELinux policy &lt;em&gt;does&lt;/em&gt; confine Firefox by default. One of the
principles we focus on in Gentoo Hardened is to
&lt;a href="https://wiki.gentoo.org/wiki/Project:SELinux/Development_policy#Develop_desktop_policies"&gt;develop desktop policies&lt;/a&gt;
in order to reduce exposure and information leakage of user documents. We might
not have the manpower to confine all desktop applications, but I do think it is
worthwhile to at least attempt to do this, even though what Dan Walsh mentioned
is also correct: desktops are notoriously difficult to use a mandatory access
control system on.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;How Gentoo wants to support more confined desktop applications&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What Gentoo Hardened tries to do is to support the
&lt;a href="http://standards.freedesktop.org/basedir-spec/basedir-spec-0.8.html"&gt;XDG Base Directory Specification&lt;/a&gt;
for several documentation types. Downloads are marked as &lt;code&gt;xdg_downloads_home_t&lt;/code&gt;,
pictures are marked as &lt;code&gt;xdg_pictures_home_t&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;With those types defined, we grant the regular user domains full access to
those types, but start removing access to user content from applications. Rules
such as the following are commented out or removed from the policies:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# userdom_manage_user_home_content_dirs(mozilla_t)
# userdom_manage_user_home_content_files(mozilla_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Instead, we add in a call to a template we have defined ourselves:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userdom_user_content_access_template(mozilla, { mozilla_t mozilla_plugin_t })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This call makes access to user content optional through SELinux booleans. For
instance, for the &lt;code&gt;mozilla_t&lt;/code&gt; domain (which is used for Firefox), the following
booleans are created:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Read generic (user_home_t) user content
mozilla_read_generic_user_content       -&amp;gt;      true

# Read all user content
mozilla_read_all_user_content           -&amp;gt;      false

# Manage generic (user_home_t) user content
mozilla_manage_generic_user_content     -&amp;gt;      false

# Manage all user content
mozilla_manage_all_user_content         -&amp;gt;      false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, the default setting is that Firefox can read user content, but
only non-specific types. So &lt;code&gt;ssh_home_t&lt;/code&gt;, which is used for the SSH related
files, is not readable by Firefox with our policy &lt;em&gt;by default&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;By changing these booleans, the policy is fine-tuned to the requirements of
the administrator. On my systems, &lt;code&gt;mozilla_read_generic_user_content&lt;/code&gt; is switched
off.&lt;/p&gt;
&lt;p&gt;You might ask how we can then still support a browser if it cannot access user
content to upload or download. Well, as mentioned before, we support the XDG
types. The browser is allowed to manage &lt;code&gt;xdg_download_home_t&lt;/code&gt; files and
directories. For the majority of cases, this is sufficient. I also don't mind
copying over files to the &lt;code&gt;~/Downloads&lt;/code&gt; directory just for uploading files. But
I am well aware that this is not what the majority of users would want, which
is why the default is as it is.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is much more work to be done sadly&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As said earlier, the default policy will allow &lt;em&gt;reading&lt;/em&gt; of user files if those
files are not typed specifically. Types that are protected by our policy (but not
by the reference policy standard) includes SSH related files at &lt;code&gt;~/.ssh&lt;/code&gt; and
GnuPG files at &lt;code&gt;~/.gnupg&lt;/code&gt;. Even other configuration files, such as for my Mutt
configuration (&lt;code&gt;~/.muttrc&lt;/code&gt;) which contains a password for an IMAP server I connect
to, are not reachable.&lt;/p&gt;
&lt;p&gt;However, it is still far from perfect. One of the reasons is that many desktop
applications are not "converted" yet to our desktop policy approach. Yes, Chromium
is also already converted, and policies we've added such as for Skype also do not
allow direct access unless the user explicitly enabled it. But Evolution for instance
isn't yet.&lt;/p&gt;
&lt;p&gt;Converting desktop policies to a more strict setup requires lots of testing, which
translates to many human resources. Within Gentoo, only a few developers and 
contributors are working on policies, and considering that this is not a change
that is already part of the (upstream) reference policy, some contributors also
do not want to put lots of focus on it either. But without having done the works,
it will not be easy (nor probably acceptable) to upstream this (the XDG patch has
been submitted a few times already but wasn't deemed ready yet then).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Having a more restrictive policy isn't the end&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As the blog post of Dan rightly mentioned, there are still quite some other
ways of accessing information that we might want to protect. An application 
might not have access to user files, but can be able to communicate (for instance
through DBus) with an application that does, and through that instruct it to
pass on the data.&lt;/p&gt;
&lt;p&gt;Plugins might require permissions which do not match with the principles set up
earlier. When we tried out Google Talk (needed for proper Google Hangouts support)
we noticed that it requires many, many more privileges. Luckily, we were able to
write down and develop a policy for the Google Talk plugin (&lt;code&gt;googletalk_plugin_t&lt;/code&gt;)
so it is still properly confined. But this is just a single plugin, and I'm sure
that more plugins exist which will have similar requirements. Which leads to more
policy development.&lt;/p&gt;
&lt;p&gt;But having workarounds does not make the effort we do worthless. Being able to
work around a firewall through application data does not make the firewall
useless, it is just one of the many security layers. The same is true with SELinux
policies.&lt;/p&gt;
&lt;p&gt;I am glad that we at least try to confine desktop applications more, and
that Gentoo Hardened users who use SELinux are at least somewhat more protected
from the vulnerability (even with the default case) and that our investment for
this is sound.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="policy"></category><category term="firefox"></category><category term="cve"></category><category term="vulnerability"></category><category term="xdg"></category></entry><entry><title>Can SELinux substitute DAC?</title><link href="https://blog.siphos.be/2015/08/can-selinux-substitute-dac/" rel="alternate"></link><published>2015-08-09T14:48:00+02:00</published><updated>2015-08-09T14:48:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-09:/2015/08/can-selinux-substitute-dac/</id><summary type="html">&lt;p&gt;A nice &lt;a href="https://twitter.com/sjvermeu/status/630107879123623936"&gt;twitter discussion&lt;/a&gt;
with &lt;a href="https://twitter.com/erlheldata"&gt;Erling Hellenäs&lt;/a&gt; caught my full attention later
when I was heading home: Can SELinux substitute DAC? I know it can't and doesn't
in the current implementation, but why not and what would be needed?&lt;/p&gt;
&lt;p&gt;SELinux is implemented through the &lt;a href="https://en.wikipedia.org/wiki/Linux_Security_Modules"&gt;Linux Security Modules framework&lt;/a&gt;
which allows for different security systems to be implemented and integrated
in the Linux kernel. Through LSM, various security-sensitive operations can be
secured further through &lt;em&gt;additional&lt;/em&gt; access checks. This criteria was made to
have LSM be as minimally invasive as possible.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;A nice &lt;a href="https://twitter.com/sjvermeu/status/630107879123623936"&gt;twitter discussion&lt;/a&gt;
with &lt;a href="https://twitter.com/erlheldata"&gt;Erling Hellenäs&lt;/a&gt; caught my full attention later
when I was heading home: Can SELinux substitute DAC? I know it can't and doesn't
in the current implementation, but why not and what would be needed?&lt;/p&gt;
&lt;p&gt;SELinux is implemented through the &lt;a href="https://en.wikipedia.org/wiki/Linux_Security_Modules"&gt;Linux Security Modules framework&lt;/a&gt;
which allows for different security systems to be implemented and integrated
in the Linux kernel. Through LSM, various security-sensitive operations can be
secured further through &lt;em&gt;additional&lt;/em&gt; access checks. This criteria was made to
have LSM be as minimally invasive as possible.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;The LSM design&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The basic LSM design paper, called &lt;a href="http://www.kroah.com/linux/talks/usenix_security_2002_lsm_paper/lsm.pdf"&gt;Linux Security Modules: General Security
Support for the Linux Kernel&lt;/a&gt;
as presented in 2002, is still one of the better references for learning and
understanding LSM. It does show that there was a whish-list from the community
where LSM hooks could override DAC checks, and that it has been partially
implemented through permissive hooks (not to be mistaken with SELinux' 
permissive mode).&lt;/p&gt;
&lt;p&gt;However, this definitely is &lt;em&gt;partially&lt;/em&gt; implemented because there are quite
a few restrictions. One of them is that, if a request is made towards a
resource and the UIDs match (see page 3, figure 2 of the paper) then
the LSM hook is not consulted. When they don't match, a permissive LSM
hook can be implemented. Support for permissive hooks is implemented
for capabilities, a powerful DAC control that Linux supports and which is
implemented &lt;a href="http://www.hep.by/gnu/kernel/lsm/cap.html"&gt;through LSM&lt;/a&gt; as
well. I have &lt;a href="http://blog.siphos.be/tag/capabilities/index.html"&gt;blogged&lt;/a&gt;
about this nice feature a while ago.&lt;/p&gt;
&lt;p&gt;These restrictions are also why some other security-conscious developers,
such as &lt;a href="http://grsecurity.net/lsm.php"&gt;grsecurity's team&lt;/a&gt; and &lt;a href="https://www.rsbac.org/documentation/why_rsbac_does_not_use_lsm"&gt;RSBAC&lt;/a&gt;
do not use the LSM system. Well, it's not only through these restrictions
of course - other reasons play a role in them as well. But knowing what
LSM can (and cannot) do also shows what SELinux can and cannot do.&lt;/p&gt;
&lt;p&gt;The LSM design itself is already a reason why SELinux cannot substitute
DAC controls. But perhaps we could disable DAC completely and thus only
rely on SELinux?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disabling DAC in Linux would be an excessive workload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The discretionary access controls in the Linux kernel are not easy to remove.
They are often part of the code itself (just grep through the source code
after &lt;code&gt;-EPERM&lt;/code&gt;). Some subsystems which use a common standard approach (such
as VFS operations) can rely on good integrated security controls, but these
too often allow the operation if DAC allows it, and will only consult the LSM
hooks otherwise.&lt;/p&gt;
&lt;p&gt;VFS operations are the most known ones, but DAC controls go beyond file access.
It also entails reading program memory, sending signals to applications,
accessing hardware and more. But let's focus on the easier controls (as in,
easier to use examples for), such as sharing files between users, restricting
access to personal documents and authorizing operations in applications based
on the user id (for instance, the owner can modify while other users can only
read the file).&lt;/p&gt;
&lt;p&gt;We could "work around" the Linux DAC controls by running everything as a single user
(the root user) and having all files and resources be fully accessible by this
user. But the problem with that is that SELinux would not be able to take
over controls either, because you will need some user-based access controls,
and within SELinux this implies that a mapping is done from a user to a 
SELinux user. Also, access controls based on the user id would no longer work,
and unless the application is made SELinux-aware it would lack any authorization
system (or would need to implement it itself).&lt;/p&gt;
&lt;p&gt;With DAC Linux also provides quite some "freedom" which is well established
in the Linux (and Unix) environment: a simple security model where the user
and group membership versus the owner-privileges, group-privileges and
"rest"-privileges are validated. Note that SELinux does not really know
what a "group" is. It knows SELinux users, roles, types and sensitivities.&lt;/p&gt;
&lt;p&gt;So, suppose we would keep multi-user support in Linux but completely remove
the DAC controls and rely solely on LSM (and SELinux). Is this something
reusable?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using SELinux for DAC-alike rules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider the use case of two users. One user wants another user to read a few
of his files. With DAC controls, he can "open up" the necessary resources
(files and directories) through &lt;a href="https://wiki.gentoo.org/wiki/Filesystem/Access_Control_List_Guide"&gt;extended access control lists&lt;/a&gt;
so that the other user can access it. No need to involve administrators.&lt;/p&gt;
&lt;p&gt;With a MAC(-only) system, updates on the MAC policy usually require the security
administrator to write additional policy rules to allow something. With SELinux
(and without DAC) it would require the users to be somewhat isolated from each
other (otherwise the users can just access everything from each other), which
SELinux can do through &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Constraints#UBAC_-_User_Based_Access_Control"&gt;User Based Access Control&lt;/a&gt;,
but the target resource itself should be labeled with a type that is not managed
through the UBAC control. Which means that the users will need the privilege to
change labels to this type (which is possible!), &lt;em&gt;assuming&lt;/em&gt; such a type is already
made available for them. Users can't create new types themselves.&lt;/p&gt;
&lt;p&gt;UBAC is by default disabled in many distributions, because it has some nasty
side-effects that need to be taken into consideration. Just recently one of these
&lt;a href="http://oss.tresys.com/pipermail/refpolicy/2015-August/007704.html"&gt;came up on the refpolicy mailinglist&lt;/a&gt;.
But even with UBAC enabled (I have it enabled on most of my systems, but considering
that I only have a couple of users to manage and am administrator on these systems
to quickly "update" rules when necessary) it does not provide equal functionality as
DAC controls.&lt;/p&gt;
&lt;p&gt;As mentioned before, SELinux does not know group membership. In order to create
something group-like, we will probably need to consider roles. But in SELinux,
roles are used to define what types are transitionable towards - it is not a
membership approach. A type which is usable by two roles (for instance, the
&lt;code&gt;mozilla_t&lt;/code&gt; type which is allowed for &lt;code&gt;staff_r&lt;/code&gt; and &lt;code&gt;user_r&lt;/code&gt;) does not care about
the role. This is unlike group membership.&lt;/p&gt;
&lt;p&gt;Also, roles only focus on &lt;em&gt;transitionable&lt;/em&gt; types (known as domains). It does not
care about &lt;em&gt;accessible&lt;/em&gt; resources (regular file types for instance). In order to
allow one person to read a certain file type but not another, SELinux will need
to control that one person can read this file through a particular domain while
the other user can't. And given that domains are part of the SELinux policy, any
situation that the policy has not thought about before will not be easily adaptable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So, we can't do it?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, I'm pretty sure that a very extensive policy and set of rules can be made
for SELinux which would make a number of DAC permissions obsolete, and that we could
theoretically remove DAC from the Linux kernel.&lt;/p&gt;
&lt;p&gt;End users would require a huge training to work with this system, and it would not
be reusable across other systems in different environments, because the policy
will be too specific to the system (unlike the current reference policy based ones,
which are quite reusable across many distributions).&lt;/p&gt;
&lt;p&gt;Furthermore, the effort to create these policies would be extremely high, whereas
the DAC permissions are very simple to implement, and have been proven to be
well suitable for many secured systems. &lt;/p&gt;
&lt;p&gt;So no, unless you do massive engineering, I do not believe it is possible to
substitute DAC with SELinux-only controls.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="refpolicy"></category><category term="linux"></category><category term="dac"></category><category term="lsm"></category></entry><entry><title>Filtering network access per application</title><link href="https://blog.siphos.be/2015/08/filtering-network-access-per-application/" rel="alternate"></link><published>2015-08-07T03:49:00+02:00</published><updated>2015-08-07T03:49:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-07:/2015/08/filtering-network-access-per-application/</id><summary type="html">&lt;p&gt;Iptables (and the successor nftables) is a powerful packet filtering system in
the Linux kernel, able to create advanced firewall capabilities. One of the 
features that it &lt;em&gt;cannot&lt;/em&gt; provide is per-application filtering. Together with
SELinux however, it is possible to implement this on a &lt;em&gt;per domain&lt;/em&gt; basis.&lt;/p&gt;
&lt;p&gt;SELinux does not know applications, but it knows domains. If we ensure that each
application runs in its own domain, then we can leverage the firewall
capabilities with SELinux to only allow those domains access that we need.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Iptables (and the successor nftables) is a powerful packet filtering system in
the Linux kernel, able to create advanced firewall capabilities. One of the 
features that it &lt;em&gt;cannot&lt;/em&gt; provide is per-application filtering. Together with
SELinux however, it is possible to implement this on a &lt;em&gt;per domain&lt;/em&gt; basis.&lt;/p&gt;
&lt;p&gt;SELinux does not know applications, but it knows domains. If we ensure that each
application runs in its own domain, then we can leverage the firewall
capabilities with SELinux to only allow those domains access that we need.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;SELinux network control: packet types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The basic network control we need to enable is SELinux' packet types. Most
default policies will grant application domains the right set of packet types:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# sesearch -s mozilla_t -c packet -A
Found 13 semantic av rules:
   allow mozilla_t ipp_client_packet_t : packet { send recv } ; 
   allow mozilla_t soundd_client_packet_t : packet { send recv } ; 
   allow nsswitch_domain dns_client_packet_t : packet { send recv } ; 
   allow mozilla_t speech_client_packet_t : packet { send recv } ; 
   allow mozilla_t ftp_client_packet_t : packet { send recv } ; 
   allow mozilla_t http_client_packet_t : packet { send recv } ; 
   allow mozilla_t tor_client_packet_t : packet { send recv } ; 
   allow mozilla_t squid_client_packet_t : packet { send recv } ; 
   allow mozilla_t http_cache_client_packet_t : packet { send recv } ; 
 DT allow mozilla_t server_packet_type : packet recv ; [ mozilla_bind_all_unreserved_ports ]
 DT allow mozilla_t server_packet_type : packet send ; [ mozilla_bind_all_unreserved_ports ]
 DT allow nsswitch_domain ldap_client_packet_t : packet recv ; [ authlogin_nsswitch_use_ldap ]
 DT allow nsswitch_domain ldap_client_packet_t : packet send ; [ authlogin_nsswitch_use_ldap ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As we can see, the &lt;code&gt;mozilla_t&lt;/code&gt; domain is able to send and receive packets of
type &lt;code&gt;ipp_client_packet_t&lt;/code&gt;, &lt;code&gt;soundd_client_packet_t&lt;/code&gt;, &lt;code&gt;dns_client_packet_t&lt;/code&gt;, 
&lt;code&gt;speech_client_packet_t&lt;/code&gt;, &lt;code&gt;ftp_client_packet_t&lt;/code&gt;, &lt;code&gt;http_client_packet_t&lt;/code&gt;, 
&lt;code&gt;tor_client_packet_t&lt;/code&gt;, &lt;code&gt;squid_client_packet_t&lt;/code&gt; and &lt;code&gt;http_cache_client_packet_t&lt;/code&gt;.
If the SELinux booleans mentioned at the end are enabled, additional packet
types are alloed to be used as well.&lt;/p&gt;
&lt;p&gt;But even with this default policy in place, SELinux is not being consulted for
filtering. To accomplish this, &lt;code&gt;iptables&lt;/code&gt; will need to be told to label the
incoming and outgoing packets. This is the &lt;a href="http://blog.siphos.be/2013/05/secmark-and-selinux/"&gt;SECMARK&lt;/a&gt;
functionality that I've blogged about earlier.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enabling SECMARK filtering through iptables&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To enable SECMARK filtering, we use the &lt;code&gt;iptables&lt;/code&gt; command and tell it to label
SSH incoming and outgoing packets as &lt;code&gt;ssh_server_packet_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# iptables -t mangle -A INPUT -m state --state ESTABLISHED,RELATED -j CONNSECMARK --restore
~# iptables -t mangle -A INPUT -p tcp --dport 22 -j SECMARK --selctx system_u:object_r:ssh_server_packet_t:s0
~# iptables -t mangle -A OUTPUT -m state --state ESTABLISHED,RELATED -j CONNSECMARK --restore
~# iptables -t mangle -A OUTPUT -p tcp --sport 22 -j SECMARK --selctx system_u:object_r:ssh_server_packet_t:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But be warned: the moment iptables starts with its SECMARK support, &lt;em&gt;all packets&lt;/em&gt;
will be labeled. Those that are not explicitly labeled through one of the above
commands will be labeled with the &lt;code&gt;unlabeled_t&lt;/code&gt; type, and most domains are not
allowed any access to &lt;code&gt;unlabeled_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are two things we can do to improve this situation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Define the necessary SECMARK rules for all supported ports (which is something
   that &lt;a href="https://www.linux.com/learn/tutorials/421152:using-selinux-and-iptables-together"&gt;secmarkgen&lt;/a&gt;
   does), and/or&lt;/li&gt;
&lt;li&gt;Allow &lt;code&gt;unlabeled_t&lt;/code&gt; for all domains.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To allow the latter, we can load a SELinux rule like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="nv"&gt;unlabeled_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This will allow all domains to send and receive packets of the &lt;code&gt;unlabeled_t&lt;/code&gt; type.
Although this is something that might be security-sensitive, it might be a good idea
to allow at start, together with proper auditing (you can use &lt;code&gt;(auditallow ...)&lt;/code&gt; to
audit all granted packet communication) so that the right set of packet types can be
enabled. This way, administrators can iteratively improve the SECMARK rules and finally
remove the &lt;code&gt;unlabeled_t&lt;/code&gt; privilege from the &lt;code&gt;domain&lt;/code&gt; attribute.&lt;/p&gt;
&lt;p&gt;To list the current SECMARK rules, list the firewall rules for the &lt;code&gt;mangle&lt;/code&gt; table:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# iptables -t mangle -nvL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Only granting one application network access&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;These two together allow for creating a firewall that only allows a single domain
access to a particular target.&lt;/p&gt;
&lt;p&gt;For instance, suppose that we only want the &lt;code&gt;mozilla_t&lt;/code&gt; domain to connect to the
company proxy (10.15.10.5). We can't enable the &lt;code&gt;http_client_packet_t&lt;/code&gt; for this
connection, as all other web browsers and other HTTP-aware applications will have
policy rules enabled to send and receive that packet type. Instead, we are going
to create a new packet type to use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;;; Definition of myhttp_client_packet_t&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;roletype&lt;/span&gt; &lt;span class="nv"&gt;object_r&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;client_packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;; Grant the use to mozilla_t&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;mozilla_t&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Putting the above in a &lt;code&gt;myhttppacket.cil&lt;/code&gt; file and loading it allows the type
to be used:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -i myhttppacket.cil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, the &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; type can be used in &lt;code&gt;iptables&lt;/code&gt; rules. Also, 
only the &lt;code&gt;mozilla_t&lt;/code&gt; domain is allowed to send and receive these packets,
effectively creating an application-based firewall, as all we now need to do
is to mark the outgoing packets towards the proxy as &lt;code&gt;myhttp_client_packet_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# iptables -t mangle -A OUTPUT -p tcp --dport 80 -d 10.15.10.5 -j SECMARK --selctx system_u:object_r:myhttp_client_packet_t:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This shows that it is &lt;em&gt;possible&lt;/em&gt; to create such firewall rules with SELinux. It
is however not an out-of-the-box solution, requiring thought and development of
both firewall rules and SELinux code constructions. Still, with some advanced
scripting experience this will lead to a powerful addition to a hardened
system.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="network"></category><category term="iptables"></category></entry><entry><title>Don't confuse SELinux with its policy</title><link href="https://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/" rel="alternate"></link><published>2015-08-03T01:49:00+02:00</published><updated>2015-08-03T01:49:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-03:/2015/08/dont-confuse-selinux-with-its-policy/</id><summary type="html">&lt;p&gt;With the increased attention that SELinux is getting thanks to its inclusion in
recent &lt;a href="https://source.android.com/devices/tech/security/selinux/"&gt;Android&lt;/a&gt;
releases, more and more people are understanding that SELinux is not a singular
security solution. Many administrators are still disabling SELinux on their 
servers because it does not play well with their day-to-day operations. But
the Android inclusion shows that SELinux itself is not the culprit for this:
it is the policy.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;With the increased attention that SELinux is getting thanks to its inclusion in
recent &lt;a href="https://source.android.com/devices/tech/security/selinux/"&gt;Android&lt;/a&gt;
releases, more and more people are understanding that SELinux is not a singular
security solution. Many administrators are still disabling SELinux on their 
servers because it does not play well with their day-to-day operations. But
the Android inclusion shows that SELinux itself is not the culprit for this:
it is the policy.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Policy versus enforcement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELinux has conceptually segregated the enforcement from the rules/policy. 
There is an in-kernel enforcement (the SELinux subsystem) which is configured
through an administrator-provided policy (the SELinux rules). As long as 
SELinux was being used on servers, chances are very high that the policy that
is being used is based on the &lt;a href="https://github.com/TresysTechnology/refpolicy/wiki"&gt;SELinux Reference Policy&lt;/a&gt;
as this is, as far as I know, the only policy implementation for Linux systems
that is widely usable.&lt;/p&gt;
&lt;p&gt;The reference policy project aims to provide a well designed, broadly usable
yet still secure set of rules. And through this goal, it has to play ball with
all possible use cases that the various software titles require. Given the open
ecosystem of the free software world, and the Linux based ones in particular, 
managing such a policy is not for beginners. New policy development requires 
insight in the technology for which the policy is created, as well as knowledge
of how the reference policy works.&lt;/p&gt;
&lt;p&gt;Compare this to the Android environment. Applications have to follow more
rigid guidelines before they are accepted on Android systems. Communication
between applications and services is governed through Intents and Activities
which are managed by the &lt;a href="http://www.cubrid.org/blog/dev-platform/binder-communication-mechanism-of-android-processes/"&gt;Binder&lt;/a&gt;
application. Interactions with the user are based on well defined interfaces.
Heck, the Android OS even holds a number of permissions that applications
have to subscribe to before they can use it.&lt;/p&gt;
&lt;p&gt;Such an environment is much easier to create policies for, because it allows
policies to be created almost on-the-fly, with the application permissions
being mapped to predefined SELinux rules. Because the freedom of
implementations is limited (in order to create a manageable environment which
is used by millions of devices over the world) policies can be made more
strictly and yet enjoy the static nature of the environment: no continuous
updates on existing policies, something that Linux distributions have to do
on an almost daily basis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aiming for a policy development ecosystem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Having SELinux active on Android shows that one should not confuse SELinux
with its policies. SELinux is a nice security subsystem in the Linux kernel,
and can be used and tuned to cover whatever use case is given to it. The slow
adoption of SELinux by Linux distributions might be attributed to its lack
of policy diversification, which results in few ecosystems where additional
(and perhaps innovative) policies could be developed.&lt;/p&gt;
&lt;p&gt;It is however a huge advantage that a reference policy exists, so that
distributions can enjoy a working policy without having to put resources
into its own policy development and maintenance. Perhaps we should try to
further enhance the existing policies while support new policy ecosystems
and development initiatives.&lt;/p&gt;
&lt;p&gt;The maturation of the &lt;a href="https://github.com/SELinuxProject/cil/wiki"&gt;CIL&lt;/a&gt;
language by the &lt;a href="https://github.com/SELinuxProject/selinux"&gt;SELinux userland libraries and tools&lt;/a&gt;
might be a good catalyst for this. At one point, policies will need to be
migrated to CIL (although this can happen gradually as the userland utilities
can deal with CIL and other languages such as the legacy &lt;code&gt;.pp&lt;/code&gt; files 
simultaneously) and there are a few developers considering a renewal
of the reference policy. This would make use of the new benefits of the CIL
language and implementation: some restrictions that where applicable to the legacy
format no longer holds on CIL, such as rules which previously were only allowed
in the base policy which can now be made part of the modules as well.&lt;/p&gt;
&lt;p&gt;But next to renewing existing policies, there is plenty of room left for
innovative policy ideas and developments. The &lt;a href="http://selinuxproject.org/page/PolicyLanguage"&gt;SELinux language&lt;/a&gt;
is very versatile, and just like with programming languages we notice that only
a few set of constructs are used. Some applications might even benefit from
using SELinux as their decision and enforcement system (something that
&lt;a href="https://wiki.postgresql.org/wiki/SEPostgreSQL_Introduction"&gt;SEPostgreSQL&lt;/a&gt; has
tried).&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://freecomputerbooks.com/The-SELinux-Notebook-The-Foundations.html"&gt;SELinux Notebook&lt;/a&gt; by
Richard Haines is an excellent resource for developers that want to work more
closely with the SELinux language constructs. Just skimming through this resource
also shows how very open SELinux itself is, and that most of the users'
experience with SELinux is based on a singular policy implementation. This is
a prime reason why having a more open policy ecosystem makes perfect sense.&lt;/p&gt;
&lt;p&gt;If you don't like a particular car, do you ditch driving at all? No, you try out
another car. Let's create other cars in the SELinux world as well.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="policy"></category><category term="cil"></category></entry><entry><title>Loading CIL modules directly</title><link href="https://blog.siphos.be/2015/07/loading-cil-modules-directly/" rel="alternate"></link><published>2015-07-15T15:54:00+02:00</published><updated>2015-07-15T15:54:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-07-15:/2015/07/loading-cil-modules-directly/</id><summary type="html">&lt;p&gt;In a &lt;a href="http://blog.siphos.be/2015/06/where-does-cil-play-in-the-selinux-system/"&gt;previous
post&lt;/a&gt;
I used the &lt;code&gt;secilc&lt;/code&gt; binary to load an additional test policy. Little did
I know (and that's actually embarrassing because it was one of the
things I complained about) that you can just use the CIL policy as
modules directly.&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMMARY --&gt;

&lt;p&gt;With this I mean that a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In a &lt;a href="http://blog.siphos.be/2015/06/where-does-cil-play-in-the-selinux-system/"&gt;previous
post&lt;/a&gt;
I used the &lt;code&gt;secilc&lt;/code&gt; binary to load an additional test policy. Little did
I know (and that's actually embarrassing because it was one of the
things I complained about) that you can just use the CIL policy as
modules directly.&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMMARY --&gt;

&lt;p&gt;With this I mean that a CIL policy as mentioned in the previous post can
be loaded like a prebuilt &lt;code&gt;.pp&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -i test.cil
~# semodule -l | grep test
test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's all that is to it. Loading the module resulted in the test port
to be immediately declared and available:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage port -l | grep test
test_port_t                    tcp      1440
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In hindsight, it makes sense that it is this easy. After all, support
for the old-style policy language is done by converting it into CIL when
calling &lt;code&gt;semodule&lt;/code&gt; so it makes sense to immediately put the module (in
CIL code) ready to be taken up.&lt;/p&gt;</content><category term="SELinux"></category><category term="cil"></category><category term="selinux"></category></entry><entry><title>Restricting even root access to a folder</title><link href="https://blog.siphos.be/2015/07/restricting-even-root-access-to-a-folder/" rel="alternate"></link><published>2015-07-11T14:09:00+02:00</published><updated>2015-07-11T14:09:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-07-11:/2015/07/restricting-even-root-access-to-a-folder/</id><summary type="html">&lt;p&gt;In a
&lt;a href="http://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/comment-page-1/#comment-143323"&gt;comment&lt;/a&gt;
Robert asked how to use SELinux to prevent even root access to a
directory. The trivial solution would be not to assign an administrative
role to the root account (which is definitely possible, but you want
some way to gain administrative access otherwise ;-)&lt;/p&gt;
&lt;p&gt;Restricting root is one of the commonly referred features of a MAC
(Mandatory Access Control) system. With a well designed user management
and sudo environment, it is fairly trivial - but if you need to start
from the premise that a user has direct root access, it requires some
thought to implement it correctly. The main "issue" is not that it is
difficult to implement policy-wise, but that most users will start from
a pre-existing policy (such as the reference policy) and build on top of
that.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In a
&lt;a href="http://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/comment-page-1/#comment-143323"&gt;comment&lt;/a&gt;
Robert asked how to use SELinux to prevent even root access to a
directory. The trivial solution would be not to assign an administrative
role to the root account (which is definitely possible, but you want
some way to gain administrative access otherwise ;-)&lt;/p&gt;
&lt;p&gt;Restricting root is one of the commonly referred features of a MAC
(Mandatory Access Control) system. With a well designed user management
and sudo environment, it is fairly trivial - but if you need to start
from the premise that a user has direct root access, it requires some
thought to implement it correctly. The main "issue" is not that it is
difficult to implement policy-wise, but that most users will start from
a pre-existing policy (such as the reference policy) and build on top of
that.&lt;/p&gt;


&lt;p&gt;The use of a pre-existing policy means that some roles are already
identified and privileges are already granted to users - often these
higher privileged roles are assigned to the Linux root user as not to
confuse users. But that does mean that restricting root access to a
folder means that some additional countermeasures need to be
implemented.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The policy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But first things first. Let's look at a simple policy for restricting
access to &lt;code&gt;/etc/private&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(myprivate, 1.0)

type etc_private_t;
fs_associate(etc_private_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This simple policy introduces a type (&lt;code&gt;etc_private_t&lt;/code&gt;) which is allowed
to be used for files (it associates with a file system). &lt;em&gt;Do not&lt;/em&gt; use
the &lt;code&gt;files_type()&lt;/code&gt; interface as this would assign a set of attributes
that many user roles get read access on.&lt;/p&gt;
&lt;p&gt;Now, it is not sufficient to have the type available. If we want to
assign it to a type, someone or something needs to have the privileges
to change the security context of a file and directory to this type. If
we would just load this policy and try to do this from a privileged
account, it would fail:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# chcon -t etc_private_t /etc/private
chcon: failed to change context of &amp;#39;/etc/private&amp;#39; to &amp;#39;system_u:object_r:etc_private_t:s0&amp;#39;: Permission denied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With the following rule, the &lt;code&gt;sysadm_t&lt;/code&gt; domain (which I use for system
administration) is allowed to change the context to &lt;code&gt;etc_private_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow sysadm_t etc_private_t:{dir file} relabelto;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this in place, the administrator can label resources as
&lt;code&gt;etc_private_t&lt;/code&gt; without having read access to these resources
afterwards. Also, as long as there are no &lt;em&gt;relabelfrom&lt;/em&gt; privileges
assigned, the administrator cannot revert the context back to a type
that he has read access to.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The countermeasures&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But this policy is not sufficient. One way that administrators can
easily access the resources is to disable SELinux controls (as in, put
the system in permissive mode):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# cat /etc/private/README
cat: /etc/private/README: Permission denied
~# setenforce 0
~# cat /etc/private/README
Hello World!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To prevent this, enable the &lt;em&gt;secure_mode_policyload&lt;/em&gt; SELinux boolean:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# setsebool secure_mode_policyload on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This will prevent any policy and SELinux state manipulation... including
permissive mode, but also including loading additional SELinux policies
or changing booleans. Definitely experiment with this setting without
persisting (i.e. do not use &lt;code&gt;-P&lt;/code&gt; in the above command yet) to make sure
it is manageable for you.&lt;/p&gt;
&lt;p&gt;Still, this isn't sufficient. Don't forget that the administrator is
otherwise a full administrator - if he cannot access the &lt;code&gt;/etc/private&lt;/code&gt;
location directly, then he might be able to access it indirectly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the resource is on a non-critical file system, he can unmount the
    file system and remount it with a &lt;code&gt;context=&lt;/code&gt; mount option. This will
    override the file-level contexts. Bind-mounting does not seem to
    allow overriding the context.&lt;/li&gt;
&lt;li&gt;If the resource is on a file system that cannot be unmounted, the
    administrator can still reboot the system in a mode where he can
    access the file system regardless of SELinux controls (either
    through editing &lt;code&gt;/etc/selinux/config&lt;/code&gt; or by booting with
    &lt;code&gt;enforcing=0&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;The administrator can still access the block device files on which
    the resources are directly. Specialized tools can allow for
    extracting files and directories without actually (re)mounting
    the device.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A more extensive list of methods to potentially gain access to such
resources is iterated in &lt;a href="http://blog.siphos.be/2013/12/limiting-file-access-with-selinux-alone/"&gt;Limiting file access with SELinux
alone&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This set of methods for gaining access is due to the administrative role
already assigned by the existing policy. To further mitigate these risks
with SELinux (although SELinux will never completely mitigate all risks)
the roles assigned to the users need to be carefully revisited. If you
grant people administrative access, but you don't want them to be able
to reboot the system, (re)mount file systems, access block devices, etc.
then create a user role that does not have these privileges at all.&lt;/p&gt;
&lt;p&gt;Creating such user roles does not require leaving behind the policy that
is already active. Additional user domains can be created and granted to
Linux accounts (including root). But in my experience, when you need to
allow a user to log on as the "root" account directly, you probably need
him to have true administrative privileges. Otherwise you'd work with
personal accounts and a well-designed &lt;code&gt;/etc/sudoers&lt;/code&gt; file.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Intermediate policies</title><link href="https://blog.siphos.be/2015/07/intermediate-policies/" rel="alternate"></link><published>2015-07-05T18:17:00+02:00</published><updated>2015-07-05T18:17:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-07-05:/2015/07/intermediate-policies/</id><summary type="html">&lt;p&gt;When developing SELinux policies for new software (or existing ones
whose policies I don't agree with) it is often more difficult to finish
the policies so that they are broadly usable. When dealing with personal
policies, having them "just work" is often sufficient. To make the
policies reusable for distributions (or for the upstream project), a
number of things are necessary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try structuring the policy using the style as suggested by refpolicy
    or Gentoo&lt;/li&gt;
&lt;li&gt;Add the role interfaces that are most likely to be used or required,
    or which are in the current draft implemented differently&lt;/li&gt;
&lt;li&gt;Refactor some of the policies to use refpolicy/Gentoo style
    interfaces&lt;/li&gt;
&lt;li&gt;Remove the comments from the policies (as refpolicy does not want
    too verbose policies)&lt;/li&gt;
&lt;li&gt;Change or update the file context definitions for default
    installations (rather than the custom installations I use)&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;When developing SELinux policies for new software (or existing ones
whose policies I don't agree with) it is often more difficult to finish
the policies so that they are broadly usable. When dealing with personal
policies, having them "just work" is often sufficient. To make the
policies reusable for distributions (or for the upstream project), a
number of things are necessary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try structuring the policy using the style as suggested by refpolicy
    or Gentoo&lt;/li&gt;
&lt;li&gt;Add the role interfaces that are most likely to be used or required,
    or which are in the current draft implemented differently&lt;/li&gt;
&lt;li&gt;Refactor some of the policies to use refpolicy/Gentoo style
    interfaces&lt;/li&gt;
&lt;li&gt;Remove the comments from the policies (as refpolicy does not want
    too verbose policies)&lt;/li&gt;
&lt;li&gt;Change or update the file context definitions for default
    installations (rather than the custom installations I use)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This often takes quite some effort. Some of these changes (such as the
style updates and commenting) are even counterproductive for me
personally (in the sense that I don't gain any value from doing so and
would have to start maintaining two different policy files for the same
policy), and necessary only for upstreaming policies. As a result, I
often finish with policies that I just leave for me personally or
somewhere on a public repository (like these
&lt;a href="https://github.com/sjvermeu/small.coding/tree/master/selinux-modules/neo4j"&gt;Neo4J&lt;/a&gt;
and
&lt;a href="https://github.com/sjvermeu/small.coding/tree/master/selinux-modules/ceph"&gt;Ceph&lt;/a&gt;
policies), without any activities already scheduled to attempt to
upstream those.&lt;/p&gt;
&lt;p&gt;But not contributing the policies to a broader public means that the
effort is not known, and other contributors might be struggling with
creating policies for their favorite (or necessary) technologies. So the
majority of policies that I write I still hope to eventually push them
out. But I noticed that these last few steps for upstreaming (the ones
mentioned above) might only take a few hours of work, but take me over 6
months (or more) to accomplish (as I often find other stuff more
interesting to do).&lt;/p&gt;
&lt;p&gt;I don't know yet how to change the process to make it more interesting
to use. However, I do have a couple of wishes that might make it easier
for me, and perhaps others, to contribute:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of reacting on contribution suggestions, work on a common
    repository together. Just like with a wiki, where we don't aim for a
    100% correct and well designed document from the start, we should
    use the strength of the community to continuously improve policies
    (and to allow multiple people to work on the same policy). Right
    now, policies are a one-man publication with a number of people
    commenting on the suggested changes and asking the one person to
    refactor or update the change himself.&lt;/li&gt;
&lt;li&gt;Document the style guide properly, but don't disallow contributions
    if they do not adhere to the style guide completely. Instead, merge
    and update. On successful wikis there are even people that update
    styles without content updates, and their help is greatly
    appreciated by the community.&lt;/li&gt;
&lt;li&gt;If a naming convention is to be followed (which is the case
    with policies) make it clear. Too often the name of an interface is
    something that takes a few days of discussion. That's not productive
    for policy development.&lt;/li&gt;
&lt;li&gt;Find a way to truly create a "core" part of the policy and a
    modular/serviceable approach to handle additional policies. The idea
    of the &lt;code&gt;contrib/&lt;/code&gt; repository was like that, but failed to live up to
    its expectations: the number of people who have commit access to the
    contrib is almost the same as to the core, a few exceptions
    notwithstanding, and whenever policies are added to contrib they
    often require changes on the core as well. Perhaps even support
    overlay-type approaches to policies so that intermediate policies
    can be "staged" and tested by a larger audience before they are
    vetted into the upstream reference policy.&lt;/li&gt;
&lt;li&gt;Settle on how to deal with networking controls. My suggestion would
    be to immediately support the TCP/UDP ports as assigned by IANA (or
    another set of sources) so that additional policies do not need to
    wait for the base policy to support the ports. Or find and support a
    way for contributions to declare the port types themselves (we
    probably need to focus on CIL for this).&lt;/li&gt;
&lt;li&gt;Document "best practices" on policy development where certain types
    of policies are documented in more detail. For instance, desktop
    application profiles, networked daemons, user roles, etc. These best
    practices should not be mandatory and should in fact support a broad
    set of privilege isolation. With the latter, I mean that there are
    policies who cover an entire category of systems (init systems, web
    servers), a single software package or even the sub-commands and
    sub-daemons of that package. It would surprise me if this can't be
    supported better out-of-the-box (as in, through a well
    thought-through base policy framework and styleguide).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I believe that this might create a more active community surrounding
policy development.&lt;/p&gt;</content><category term="SELinux"></category><category term="community"></category><category term="contributions"></category><category term="policy development"></category><category term="selinux"></category></entry><entry><title>Where does CIL play in the SELinux system?</title><link href="https://blog.siphos.be/2015/06/where-does-cil-play-in-the-selinux-system/" rel="alternate"></link><published>2015-06-13T23:12:00+02:00</published><updated>2015-06-13T23:12:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-06-13:/2015/06/where-does-cil-play-in-the-selinux-system/</id><summary type="html">&lt;p&gt;SELinux policy developers already have a number of file formats to work
with. Currently, policy code is written in a set of three files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;.te&lt;/code&gt; file contains the SELinux policy code (type
    enforcement rules)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.if&lt;/code&gt; file contains functions which turn a set of arguments into
    blocks of SELinux policy code (interfaces). These functions are
    called by other interface files or type enforcement files&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.fc&lt;/code&gt; file contains mappings of file path expressions towards
    labels (file contexts)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These files are compiled into loadable modules (or a base module) which
are then transformed to an active policy. But this is not a single-step
approach.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;SELinux policy developers already have a number of file formats to work
with. Currently, policy code is written in a set of three files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;.te&lt;/code&gt; file contains the SELinux policy code (type
    enforcement rules)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.if&lt;/code&gt; file contains functions which turn a set of arguments into
    blocks of SELinux policy code (interfaces). These functions are
    called by other interface files or type enforcement files&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.fc&lt;/code&gt; file contains mappings of file path expressions towards
    labels (file contexts)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These files are compiled into loadable modules (or a base module) which
are then transformed to an active policy. But this is not a single-step
approach.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Transforming policy code into policy file&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For the Linux kernel SELinux subsystem, only a single file matters - the
&lt;code&gt;policy.##&lt;/code&gt; file (for instance &lt;code&gt;policy.29&lt;/code&gt;). The suffix denotes the
binary format used as higher numbers mean that additional SELinux
features are supported which require different binary formats for the
SELinux code in the Linux kernel.&lt;/p&gt;
&lt;p&gt;With the 2.4 userspace, the transformation of the initial files as
mentioned above towards a policy file is done as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="SELinux transformation diagram" src="http://dev.gentoo.org/~swift/blog/201506/formats_selinux.png"&gt;&lt;/p&gt;
&lt;p&gt;When a developer builds a policy module, first &lt;code&gt;checkmodule&lt;/code&gt; is used to
build a &lt;code&gt;.mod&lt;/code&gt; intermediate file. This file contains the type
enforcement rules with the expanded rules of the various interface
files. Next, &lt;code&gt;semodule_package&lt;/code&gt; is called which transforms this
intermediate file, together with the file context file, into a &lt;code&gt;.pp&lt;/code&gt;
file.&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;.pp&lt;/code&gt; file is, in the 2.4 userspace, called a "high level language"
file. There is little high-level about it, but the idea is that such
high-level language files are then transformed into &lt;code&gt;.cil&lt;/code&gt; files (CIL
stands for &lt;em&gt;Common Intermediate Language&lt;/em&gt;). If at any moment other
frameworks come around, they could create high-level languages
themselves and provide a transformation engine to convert these HLL
files into CIL files.&lt;/p&gt;
&lt;p&gt;For the current &lt;code&gt;.pp&lt;/code&gt; files, this transformation is supported through
the &lt;code&gt;/usr/libexec/selinux/hll/pp&lt;/code&gt; binary which, given a &lt;code&gt;.pp&lt;/code&gt; file,
outputs CIL code.&lt;/p&gt;
&lt;p&gt;Finally, all CIL files (together) are compiled into a binary &lt;code&gt;policy.29&lt;/code&gt;
file. All the steps coming from a &lt;code&gt;.pp&lt;/code&gt; file towards the final binary
file are handled by the &lt;code&gt;semodule&lt;/code&gt; command. For instance, if an
administrator loads an additional &lt;code&gt;.pp&lt;/code&gt; file, its (generated) CIL code
is added to the other active CIL code and together, a new policy binary
file is created.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adding some CIL code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SELinux userspace development repository contains a &lt;code&gt;secilc&lt;/code&gt; command
which can compile CIL code into a binary policy file. As such, it can
perform the (very) last step of the file conversions above. However, it
is not &lt;em&gt;integrated&lt;/em&gt; in the sense that, if additional code is added, the
administrator can "play" with it as he would with SELinux policy
modules.&lt;/p&gt;
&lt;p&gt;Still, that shouldn't prohibit us from playing around with it to
experiment with the CIL language construct. Consider the following CIL
SELinux policy code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;; Declare a test_port_t type
(type test_port_t)
; Assign the type to the object_r role
(roletype object_r test_port_t)

; Assign the right set of attributes to the port
(typeattributeset defined_port_type test_port_t)
(typeattributeset port_type test_port_t)

; Declare tcp:1440 as test_port_t
(portcon tcp 1440 (system_u object_r test_port_t ((s0) (s0))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code declares a port type (&lt;code&gt;test_port_t&lt;/code&gt;) and uses it for the TCP
port 1440.&lt;/p&gt;
&lt;p&gt;In order to use this code, we have to build a policy file which includes
all currently active CIL code, together with the test code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ secilc -c 29 /var/lib/selinux/mcs/active/modules/400/*/cil testport.cil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The result is a &lt;code&gt;policy.29&lt;/code&gt; (the command forces version 29 as the
current Linux kernel used on this system does not support version 30)
file, which can now be copied to &lt;code&gt;/etc/selinux/mcs/policy&lt;/code&gt;. Then, after
having copied the file, load the new policy file using &lt;code&gt;load_policy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And lo and behold, the port type is now available:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage port -l | grep 1440
test_port_t           tcp      1440
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To verify that it really is available and not just parsed by the
userspace, let's connect to it and hope for a nice denial message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ ssh -p 1440 localhost
ssh: connect to host localhost port 1440: Permission denied

~$ sudo ausearch -ts recent
time-&amp;gt;Thu Jun 11 19:35:45 2015
type=PROCTITLE msg=audit(1434044145.829:296): proctitle=737368002D700031343430006C6F63616C686F7374
type=SOCKADDR msg=audit(1434044145.829:296): saddr=0A0005A0000000000000000000000000000000000000000100000000
type=SYSCALL msg=audit(1434044145.829:296): arch=c000003e syscall=42 success=no exit=-13 a0=3 a1=6d4d1ce050 a2=1c a3=0 items=0 ppid=2005 pid=18045 auid=1001 uid=1001 gid=1001 euid=1001 suid=1001 fsuid=1001 egid=1001 sgid=1001 fsgid=1001 tty=pts0 ses=1 comm=&amp;quot;ssh&amp;quot; exe=&amp;quot;/usr/bin/ssh&amp;quot; subj=staff_u:staff_r:ssh_t:s0 key=(null)
type=AVC msg=audit(1434044145.829:296): avc:  denied  { name_connect } for  pid=18045 comm=&amp;quot;ssh&amp;quot; dest=1440 scontext=staff_u:staff_r:ssh_t:s0 tcontext=system_u:object_r:test_port_t:s0 tclass=tcp_socket permissive=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category><category term="cil"></category><category term="selinux"></category><category term="userspace"></category></entry><entry><title>Testing with permissive domains</title><link href="https://blog.siphos.be/2015/05/testing-with-permissive-domains/" rel="alternate"></link><published>2015-05-18T13:40:00+02:00</published><updated>2015-05-18T13:40:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-05-18:/2015/05/testing-with-permissive-domains/</id><summary type="html">&lt;p&gt;When testing out new technologies or new setups, not having (proper)
SELinux policies can be a nuisance. Not only are the number of SELinux
policies that are available through the standard repositories limited,
some of these policies are not even written with the same level of
confinement that an administrator might expect. Or perhaps the
technology to be tested is used in a completely different manner.&lt;/p&gt;
&lt;p&gt;Without proper policies, any attempt to start such a daemon or
application might or will cause permission violations. In many cases,
developers or users tend to disable SELinux enforcing then so that they
can continue playing with the new technology. And why not? After all,
policy development is to be done &lt;em&gt;after&lt;/em&gt; the technology is understood.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;When testing out new technologies or new setups, not having (proper)
SELinux policies can be a nuisance. Not only are the number of SELinux
policies that are available through the standard repositories limited,
some of these policies are not even written with the same level of
confinement that an administrator might expect. Or perhaps the
technology to be tested is used in a completely different manner.&lt;/p&gt;
&lt;p&gt;Without proper policies, any attempt to start such a daemon or
application might or will cause permission violations. In many cases,
developers or users tend to disable SELinux enforcing then so that they
can continue playing with the new technology. And why not? After all,
policy development is to be done &lt;em&gt;after&lt;/em&gt; the technology is understood.&lt;/p&gt;


&lt;p&gt;But completely putting the system in permissive mode is overshooting. It
is much easier to make a very simple policy to start with, and then mark
the domain as a permissive domain. What happens is that the software
then, after transitioning into the "simple" domain, is not part of the
SELinux enforcements anymore whereas the rest of the system remains in
SELinux enforcing mode.&lt;/p&gt;
&lt;p&gt;For instance, create a minuscule policy like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(testdom, 1.0)

type testdom_t;
type testdom_exec_t;
init_daemon_domain(testdom_t, testdom_exec_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Mark the executable for the daemon as &lt;code&gt;testdom_exec_t&lt;/code&gt; (after building
and loading the minuscule policy):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# chcon -t testdom_exec_t /opt/something/bin/daemond
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, tell SELinux that &lt;code&gt;testdom_t&lt;/code&gt; is to be seen as a permissive
domain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage permissive -a testdom_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When finished, don't forget to remove the permissive bit
(&lt;code&gt;semanage permissive -d testdom_t&lt;/code&gt;) and unload/remove the SELinux
policy module.&lt;/p&gt;
&lt;p&gt;And that's it. If the daemon is now started (through a standard init
script) it will run as &lt;code&gt;testdom_t&lt;/code&gt; and everything it does will be
logged, but not enforced by SELinux. That might even help in
understanding the application better.&lt;/p&gt;</content><category term="SELinux"></category><category term="permissive"></category><category term="policy"></category><category term="selinux"></category><category term="semanage"></category><category term="test"></category></entry><entry><title>Use change management when you are using SELinux to its fullest</title><link href="https://blog.siphos.be/2015/04/use-change-management-when-you-are-using-selinux-to-its-fullest/" rel="alternate"></link><published>2015-04-30T20:58:00+02:00</published><updated>2015-04-30T20:58:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-04-30:/2015/04/use-change-management-when-you-are-using-selinux-to-its-fullest/</id><summary type="html">&lt;p&gt;If you are using SELinux on production systems (with which I mean
systems that you offer services with towards customers or other parties
beyond you, yourself and your ego), please consider proper change
management if you don't do already. SELinux is a very sensitive security
subsystem - not in the sense …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you are using SELinux on production systems (with which I mean
systems that you offer services with towards customers or other parties
beyond you, yourself and your ego), please consider proper change
management if you don't do already. SELinux is a very sensitive security
subsystem - not in the sense that it easily fails, but because it is
very fine-grained and as such can easily stop applications from running
when their behavior changes just a tiny bit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sensitivity of SELinux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELinux is a wonderful security measure for Linux systems that can
prevent successful exploitation of vulnerabilities or misconfigurations.
Of course, it is not the sole security measure that systems should take.
Proper secure configuration of services, least privilege accounts,
kernel-level mitigations such as grSecurity and more are other measures
that certainly need to be taken if you really find system security to be
a worthy goal to attain. But I'm not going to talk about those others
right now. What I am going to focus on is SELinux, and how sensitive it
is to changes.&lt;/p&gt;
&lt;p&gt;An important functionality of SELinux to understand is that it
segregates the security control system itself (the SELinux subsystem)
from its configuration (the policy). The security control system itself
is relatively small, and focuses on enforcement of the policy and
logging (either because the policy asks to log something, or because
something is prevented, or because an error occurred). The most
difficult part of handling SELinux on a system is not enabling or
interacting with it. No, it is its policy.&lt;/p&gt;
&lt;p&gt;The policy is also what makes SELinux so darn sensitive for small system
changes (or behavior that is not either normal, or at least not allowed
through the existing policy). Let me explain with a small situation that
I recently had.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case in point: Switching an IP address&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A case that beautifully shows how sensitive SELinux can be is an IP
address change. My systems all obtain their IP address (at least for
IPv4) from a DHCP system. This is of course acceptable behavior as
otherwise my systems would never be able to boot up successfully anyway.
The SELinux policy that I run also allows this without any hindrance. So
that was not a problem.&lt;/p&gt;
&lt;p&gt;Yet recently I had to switch an IP address for a system in production.
All the services I run are set up in a dual-active mode, so I started
with the change by draining the services to the second system, shutting
down the service and then (after reconfiguring the DHCP system to now
provide a different IP address) reload the network configuration. And
then it happened - the DHCP client just stalled.&lt;/p&gt;
&lt;p&gt;As the change failed, I updated the DHCP system again to deliver the old
IP address and then reloaded the network configuration on the client.
Again, it failed. Dumbstruck, I looked at the AVC denials and lo and
behold, I notice a &lt;code&gt;dig&lt;/code&gt; process running in a DHCP client related domain
that is trying to do UDP binds, which the policy (at that time) did not
allow. But why now suddenly, after all - this system was running happily
for more than a year already (and with occasional reboots for kernel
updates).&lt;/p&gt;
&lt;p&gt;I won't bore you with the investigation. It boils down to the fact that
the DHCP client detected a change compared to previous startups, and was
configured to run a few hooks as additional steps in the IP lease setup.
As these hooks were never ran previously, the policy was never
challenged to face this. And since the address change occurred a revert
to the previous situation didn't work either (as its previous state
information was already deleted).&lt;/p&gt;
&lt;p&gt;I was able to revert the client (which is a virtual guest in KVM) to the
situation right before the change (thank you &lt;code&gt;savevm&lt;/code&gt; and &lt;code&gt;loadvm&lt;/code&gt;
functionality) so that I could work on the policy first in a
non-production environment so that the next change attempt was
successful.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Change management&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The previous situation might be "solved" by temporarily putting the DHCP
client domain in permissive mode just for the change and then back. But
that is ignoring the issue, and unless you have perfect operational
documentation that you always read before making system or configuration
changes, I doubt that you'll remember this for the next time.&lt;/p&gt;
&lt;p&gt;The case is also a good example on the sensitivity of SELinux. It is not
just when software is being upgraded. Every change (be it in
configuration, behavior or operational activity) might result in a
situation that is new for the loaded SELinux policy. As the default
action in SELinux is to deny everything, this will result in unexpected
results on the system. Sometimes very visible (no IP address obtained),
sometimes hidden behind some weird behavior (hostname correctly set but
not the domainname) or perhaps not even noticed until far later. Compare
it to the firewall rule configurations: you might be able to easily
confirm that standard flows are still passed through, but how are you
certain that fallback flows or one-in-a-month connection setups are not
suddenly prevented from happening.&lt;/p&gt;
&lt;p&gt;A somewhat better solution than just temporarily disabling SELinux
access controls for a domain is to look into proper change management.
Whenever a change has to be done, make sure that you&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can easily revert the change back to the previous
    situation (backups!)&lt;/li&gt;
&lt;li&gt;have tested the change on a non-vital (preproduction) system first&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These two principles are pretty vital when you are serious about using
SELinux in production. I'm not talking about a system that hardly has
any fine-grained policies, like where most of the system's services are
running in "unconfined" domains (although that's still better than not
running with SELinux at all), but where you are truly trying to put a
least privilege policy in place for all processes and services.&lt;/p&gt;
&lt;p&gt;Being able to revert a change allows you to quickly get a service up and
running again so that customers are not affected by the change (and
potential issues) for long time. First fix the service, then fix the
problem. If you are an engineer like me, you might rather focus on the
problem (and a permanent, correct solution) first. But that's wrong -
always first make sure that the customers are not affected by it. Revert
and put the service back up, and then investigate so that the next
change attempt will not go wrong anymore.&lt;/p&gt;
&lt;p&gt;Having a multi-master setup might give some more leeway into
investigating issues (as the service itself is not disrupted) so in the
case mentioned above I would probably have tried fixing the issue
immediately anyway if it wasn't policy-based. But most users do not have
truly multi-master service setups.&lt;/p&gt;
&lt;p&gt;Being able to test (and retest) changes in non-production also allows
you to focus on automation (so that changes can be done faster and in a
repeated, predictable and qualitative manner), regression testing as
well as change accumulation testing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;You don't have time for that?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Be honest with yourself. If you support services for others (be it in a
paid-for manner or because you support an organization in your free
time) you'll quickly learn that service availability is one of the most
qualitative aspects of what you do. No matter what mess is behind it,
most users don't see all that. All they see is the service itself (and
its performance / features). If a change you wanted to make made a
service unavailable for hours, users will notice. And if the change
wasn't communicated up front or it is the n-th time that this downtime
occurs, they will start asking questions you rather not hear.&lt;/p&gt;
&lt;p&gt;Using a non-production environment is not that much of an issue if the
infrastructure you work with supports bare metal restores, or
snapshot/cloning (in case of VMs). After doing those a couple of times,
you'll easily find that you can create a non-production environment from
the production one. Or, you can go for a permanent non-production
environment (although you'll need to take care that this environment is
at all times representative for the production systems).&lt;/p&gt;
&lt;p&gt;And regarding qualitative changes, I really recommend to use a
configuration management system. I recently switched from Puppet to
Saltstack and have yet to use the latter to its fullest set (most of
what I do is still scripted), but it is growing on me and I'm pretty
convinced that I'll have the majority of my change management scripts
removed by the end of this year towards Saltstack-based configurations.
And that'll allow me to automate changes and thus provide a more
qualitative service offering.&lt;/p&gt;
&lt;p&gt;With SELinux, of course.&lt;/p&gt;</content><category term="SELinux"></category><category term="change management"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>CIL and attributes</title><link href="https://blog.siphos.be/2015/02/cil-and-attributes/" rel="alternate"></link><published>2015-02-15T15:49:00+01:00</published><updated>2015-02-15T15:49:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-02-15:/2015/02/cil-and-attributes/</id><summary type="html">&lt;p&gt;I keep on struggling to remember this, so let's make a blog post out of
it ;-)&lt;/p&gt;
&lt;p&gt;When the SELinux policy is being built, recent userspace (2.4 and
higher) will convert the policy into CIL language, and then build the
binary policy. When the policy supports type attributes, these are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I keep on struggling to remember this, so let's make a blog post out of
it ;-)&lt;/p&gt;
&lt;p&gt;When the SELinux policy is being built, recent userspace (2.4 and
higher) will convert the policy into CIL language, and then build the
binary policy. When the policy supports type attributes, these are of
course also made available in the CIL code. For instance the
&lt;code&gt;admindomain&lt;/code&gt; attribute from the &lt;code&gt;userdomain&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
(typeattribute admindomain)
(typeattribute userdomain)
(typeattribute unpriv_userdomain)
(typeattribute user_home_content_type)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Interfaces provided by the module are also applied. You won't find the
interface CIL code in &lt;code&gt;/var/lib/selinux/mcs/active/modules&lt;/code&gt; though; the
code at that location is already "expanded" and filled in. So for the
&lt;code&gt;sysadm_t&lt;/code&gt; domain we have:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Equivalent of
# gen_require(`
#   attribute admindomain;
#   attribute userdomain;
# &amp;#39;)
# typeattribute sysadm_t admindomain;
# typeattribute sysadm_t userdomain;

(typeattributeset cil_gen_require admindomain)
(typeattributeset admindomain (sysadm_t ))
(typeattributeset cil_gen_require userdomain)
(typeattributeset userdomain (sysadm_t ))
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, when checking which domains use the &lt;code&gt;admindomain&lt;/code&gt; attribute,
notice the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# seinfo -aadmindomain -x
ERROR: Provided attribute (admindomain) is not a valid attribute name.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But don't panic - this has a reason: as long as there is no SELinux rule
applied towards the &lt;code&gt;admindomain&lt;/code&gt; attribute, then the SELinux policy
compiler will drop the attribute from the final policy. This can be
confirmed by adding a single, cosmetic rule, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## allow admindomain admindomain:process sigchld;

~# seinfo -aadmindomain -x
   admindomain
      sysadm_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So there you go. That does mean that if something previously used the
attribute assignation for any decisions (like "for each domain assigned
the userdomain attribute, do something") will need to make sure that the
attribute is really used in a policy rule.&lt;/p&gt;</content><category term="SELinux"></category><category term="attribute"></category><category term="cil"></category><category term="selinux"></category></entry><entry><title>SELinux is great for enterprises (but many don't know it yet)</title><link href="https://blog.siphos.be/2015/01/selinux-is-great-for-enterprises-but-many-dont-know-it-yet/" rel="alternate"></link><published>2015-01-03T13:36:00+01:00</published><updated>2015-01-03T13:36:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-01-03:/2015/01/selinux-is-great-for-enterprises-but-many-dont-know-it-yet/</id><summary type="html">&lt;p&gt;Large companies that handle their own IT often have internal support
teams for many of the technologies that they use. Most of the time, this
is for reusable components like database technologies, web application
servers, operating systems, middleware components (like file transfers,
messaging infrastructure, ...) and more. All components that are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Large companies that handle their own IT often have internal support
teams for many of the technologies that they use. Most of the time, this
is for reusable components like database technologies, web application
servers, operating systems, middleware components (like file transfers,
messaging infrastructure, ...) and more. All components that are used
and deployed multiple times, and thus warrant the expenses of a
dedicated engineering team.&lt;/p&gt;
&lt;p&gt;Such teams often have (or need to write) secure configuration deployment
guides, so that these components are installed in the organization with
as little misconfigurations as possible. A wrongly configured component
is often worse than a vulnerable component, because vulnerabilities are
often fixed with the software upgrades (you do patch your software,
right?) whereas misconfigurations survive these updates and remain
exploitable for longer periods. Also, misuse of components is harder to
detect than exploiting vulnerabilities because they are often seen as
regular user behavior.&lt;/p&gt;
&lt;p&gt;But next to the redeployable components, most business services are
provided by a single application. Most companies don't have the budget
and resources to put dedicated engineering teams on each and every
application that is deployed in the organization. Even worse, many
companies hire external consultants to help in the deployment of the
component, and then the consultants hand over the maintenance of that
software to internal teams. Some consultants don't fully bother with
secure configuration deployment guides, or even feel the need to disable
security constraints put forth by the organization (policies and
standards) because "it is needed". A deployment is often seen as
successful when the software functionally works, which not necessarily
means that it is misconfiguration-free.&lt;/p&gt;
&lt;p&gt;As a recent example that I came across, consider an application that
needs &lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;. A consultancy firm is hired to set
up the infrastructure, and given full administrative rights on the
operating system to make sure that this particular component is deployed
fast (because the company wants to have the infrastructure in production
before the end of the week). Security is initially seen as less of a
concern, and the consultancy firm informs the customer (without any
guarantees though) that it will be set up "according to common best
practices". The company itself has no engineering team for Node.js nor
wants to invest in the appropriate resources (such as training) for
security engineers to review Node.js configurations. Yet the application
that is deployed on the Node.js application server is internet-facing,
so has a higher risk associated with it than a purely internal
deployment.&lt;/p&gt;
&lt;p&gt;So, how to ensure that these applications cannot be exploited or, if an
exploit is done, how to ensure that the risks involved with the exploit
are contained? Well, this is where I believe SELinux has a great
potential. And although I'm talking about SELinux here, the same goes
for other similar technologies like &lt;a href="http://en.wikipedia.org/wiki/TOMOYO_Linux"&gt;TOMOYO
Linux&lt;/a&gt;, &lt;a href="http://en.wikibooks.org/wiki/Grsecurity/The_RBAC_System"&gt;grSecurity's RBAC
system&lt;/a&gt;,
&lt;a href="http://www.rsbac.org/"&gt;RSBAC&lt;/a&gt; and more.&lt;/p&gt;
&lt;p&gt;SELinux can provide a container, decoupled from the application itself
(but of course built for that particular application) which restricts
the behavior of that application on the system to those activities that
are expected. The application itself is not SELinux-aware (or does not
need to be - some applications are, but those that I am focusing on here
usually don't), but the SELinux access controls ensure that exploits on
the application cannot reach beyond those activities/capabilities that
are granted to it.&lt;/p&gt;
&lt;p&gt;Consider the Node.js deployment from before. The Node.js application
server might need to connect to a &lt;a href="http://www.mongodb.org/"&gt;MongoDB&lt;/a&gt;
cluster, so we can configure SELinux to allow just that, but all other
connections that originate from the Node.js deployment should be
forbidden. Worms (if any) cannot use this deployment then to spread out.
Same with access to files - the Node.js application probably only needs
access to the application files and not to other system files. Instead
of trying to run the application in a chroot (which requires engineering
effort from those people implementing Node.js, which could be a
consultancy firm that does not know or want to deploy within a chroot)
SELinux is configured to disallow any file access beyond the application
files.&lt;/p&gt;
&lt;p&gt;With SELinux, the application can be deployed relatively safely while
ensuring that exploits (or abuse of misconfigurations) cannot spread.
All that the company itself has to do is to provide resources for a
SELinux engineering team (which can be just a responsibility of the
Linux engineering teams, but can be specialized as well). Such a team
does not need to be big, as policy development effort is usually only
needed during changes (for instance when the application is updated to
also send e-mails, in which case the SELinux policy can be adjusted to
allow that as well), and given enough experience, the SELinux
engineering team can build flexible policies that the administration
teams (those that do the maintenance of the servers) can tune the policy
as needed (for instance through SELinux booleans) without the need to
have the SELinux team work on the policies again.&lt;/p&gt;
&lt;p&gt;Using SELinux also has a number of additional advantages which other,
sometimes commercial tools (like Symantecs SPE/SCSP - really Symantec,
you ask customers to disable SELinux?) severly lack.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELinux is part of a default Linux installation in many cases.
    RedHat Enterprise Linux ships with SELinux by default, and actively
    supports SELinux when customers have any problems with it. This also
    improves the likelihood for SELinux to be accepted, as other, third
    party solutions might not be supported. Ever tried getting support
    for a system on which both McAfee AV for Linux and Symantec SCSP are
    running (if you got it to work together at all)? At least McAfee
    gives pointers to how to update &lt;a href="https://kc.mcafee.com/corporate/index?page=content&amp;amp;id=KB67360"&gt;SELinux
    settings&lt;/a&gt;
    when they would interfere with McAfee processes.&lt;/li&gt;
&lt;li&gt;SELinux is widely known and many resources exist for users,
    administrators and engineers to learn more about it. The resources
    are freely available, and often kept up2date by a very
    motivated community. Unlike commercial products, whose support pages
    are hidden behind paywalls, customers are usually prevented from
    interacting with each other and tips and tricks for using the
    product are often not found on the Internet, SELinux information can
    be found almost everywhere. And if you like books, I have a couple
    for you to read: &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-system-administration"&gt;SELinux System
    Administration&lt;/a&gt;
    and &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-cookbook"&gt;SELinux
    Cookbook&lt;/a&gt;,
    written by yours truly.&lt;/li&gt;
&lt;li&gt;Using SELinux is widely supported by third party configuration
    management tools, especially in the free software world.
    &lt;a href="http://puppetlabs.com/"&gt;Puppet&lt;/a&gt;, &lt;a href="https://www.chef.io/chef/"&gt;Chef&lt;/a&gt;,
    &lt;a href="http://www.ansible.com/home"&gt;Ansible&lt;/a&gt;,
    &lt;a href="http://www.saltstack.com/"&gt;SaltStack&lt;/a&gt; and others all support
    SELinux and/or have modules that integrate SELinux support in the
    management system.&lt;/li&gt;
&lt;li&gt;Using SELinux incurs no additional licensing costs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, SELinux is definitely not a holy grail. It has its limitations, so
security should still be seen as a global approach where SELinux is just
playing one specific role in. For instance, SELinux does not prevent
application behavior that is allowed by the policy. If a user abuses a
configuration and can have an application expose information that the
user usually does not have access to, but the application itself does
(for instance because other users on that application might) SELinux
cannot do anything about it (well, not as long as the application is not
made SELinux-aware). Also, vulnerabilities that exploit application
internals are not controlled by SELinux access controls. It is the
application behavior ("external view") that SELinux controls. To
mitigate in-application vulnerabilities, other approaches need to be
considered (such as memory protections for free software solutions,
which can protect against some kinds of exploits - see
&lt;a href="http://grsecurity.net/"&gt;grsecurity&lt;/a&gt; as one of the solutions that could
be used).&lt;/p&gt;
&lt;p&gt;Still, I believe that SELinux can definitely provide additional
protections for such "one-time deployments" where a company cannot
invest in resources to provide engineering services on those
deployments. The SELinux security controls do not require engineering on
the application side, making investments in SELinux engineering very
much reusable.&lt;/p&gt;</content><category term="SELinux"></category><category term="companies"></category><category term="configuration"></category><category term="engineering"></category><category term="enterprise"></category><category term="selinux"></category></entry><entry><title>Using multiple priorities with modules</title><link href="https://blog.siphos.be/2014/10/using-multiple-priorities-with-modules/" rel="alternate"></link><published>2014-10-31T18:24:00+01:00</published><updated>2014-10-31T18:24:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-10-31:/2014/10/using-multiple-priorities-with-modules/</id><summary type="html">&lt;p&gt;One of the new features of the 2.4 SELinux userspace is support for
module priorities. The idea is that distributions and administrators can
override a (pre)loaded SELinux policy module with another module without
removing the previous module. This lower-version module will remain in
the store, but will not …&lt;/p&gt;</summary><content type="html">&lt;p&gt;One of the new features of the 2.4 SELinux userspace is support for
module priorities. The idea is that distributions and administrators can
override a (pre)loaded SELinux policy module with another module without
removing the previous module. This lower-version module will remain in
the store, but will not be active until the higher-priority module is
disabled or removed again.&lt;/p&gt;
&lt;p&gt;The "old" modules (pre-2.4) are loaded with priority 100. When policy
modules with the 2.4 SELinux userspace series are loaded, they get
loaded with priority 400. As a result, the following message occurs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -i screen.pp
libsemanage.semanage_direct_install_info: Overriding screen module at lower priority 100 with module at priority 400
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So unlike the previous situation, where the older module is substituted
with the new one, we now have two "screen" modules loaded; the last one
gets priority 400 and is active. To see all installed modules and
priorities, use the &lt;code&gt;--list-modules&lt;/code&gt; option:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule --list-modules=all | grep screen
100 screen     pp
400 screen     pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Older versions of modules can be removed by specifying the priority:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -X 100 -r screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category><category term="priorities"></category><category term="priority"></category><category term="selinux"></category><category term="semodule"></category></entry><entry><title>After SELinux System Administration, now the SELinux Cookbook</title><link href="https://blog.siphos.be/2014/09/after-selinux-system-administration-now-the-selinux-cookbook/" rel="alternate"></link><published>2014-09-24T20:10:00+02:00</published><updated>2014-09-24T20:10:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-09-24:/2014/09/after-selinux-system-administration-now-the-selinux-cookbook/</id><summary type="html">&lt;p&gt;Almost an entire year ago (just a few days apart) I
&lt;a href="http://blog.siphos.be/2013/09/it-has-finally-arrived-selinux-system-administration/"&gt;announced&lt;/a&gt;
my first published book, called &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-system-administration"&gt;SELinux System
Administration&lt;/a&gt;.
The book covered SELinux administration commands and focuses on Linux
administrators that need to interact with SELinux-enabled systems.&lt;/p&gt;
&lt;p&gt;An important part of SELinux was only covered very briefly in the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Almost an entire year ago (just a few days apart) I
&lt;a href="http://blog.siphos.be/2013/09/it-has-finally-arrived-selinux-system-administration/"&gt;announced&lt;/a&gt;
my first published book, called &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-system-administration"&gt;SELinux System
Administration&lt;/a&gt;.
The book covered SELinux administration commands and focuses on Linux
administrators that need to interact with SELinux-enabled systems.&lt;/p&gt;
&lt;p&gt;An important part of SELinux was only covered very briefly in the book:
policy development. So in the spring this year, Packt approached me and
asked if I was interested in authoring a second book for them, called
&lt;a href="https://www.packtpub.com/networking-and-servers/selinux-cookbook"&gt;SELinux
Cookbook&lt;/a&gt;.
This book focuses on policy development and tuning of SELinux to fit the
needs of the administrator or engineer, and as such is a logical
follow-up to the previous book. Of course, given my affinity with the
wonderful Gentoo Linux distribution, it is mentioned in the book (and
even the reference platform) even though the book itself is checked
against Red Hat Enterprise Linux and Fedora as well, ensuring that every
recipe in the book works on all distributions. Luckily (or perhaps not
surprisingly) the approach is quite distribution-agnostic.&lt;/p&gt;
&lt;p&gt;Today, I got word that the &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-cookbook"&gt;SELinux
Cookbook&lt;/a&gt;
is now officially published. The book uses a recipe-based approach to
SELinux development and tuning, so it is quickly hands-on. It gives my
view on SELinux policy development while keeping the methods and
processes aligned with the upstream policy development project (the
&lt;a href="https://github.com/TresysTechnology/refpolicy/wiki"&gt;reference policy&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;It's been a pleasure (but also somewhat a pain, as this is done in free
time, which is scarce already) to author the book. Unlike the first
book, where I struggled a bit to keep the page count to the requested
amount, this book was not limited. Also, I think the various stages of
the book development contributed well to the final result (something
that I overlooked a bit in the first time, so I re-re-reviewed changes
over and over again this time - after the first editorial reviews, then
after the content reviews, then after the language reviews, then after
the code reviews).&lt;/p&gt;
&lt;p&gt;You'll see me blog a bit more about the book later (as the marketing
phase is now starting) but for me, this is a major milestone which
allowed me to write down more of my SELinux knowledge and experience. I
hope it is as good a read for you as I hope it to be.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Segmentation fault when emerging packages after libpcre upgrade?</title><link href="https://blog.siphos.be/2014/07/segmentation-fault-when-emerging-packages-after-libpcre-upgrade/" rel="alternate"></link><published>2014-07-09T20:35:00+02:00</published><updated>2014-07-09T20:35:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-07-09:/2014/07/segmentation-fault-when-emerging-packages-after-libpcre-upgrade/</id><summary type="html">&lt;p&gt;SELinux users might be facing failures when emerge is merging a package
to the file system, with an error that looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Setting SELinux security labels
/usr/lib64/portage/bin/misc-functions.sh: line 1112: 23719 Segmentation fault      /usr/sbin/setfiles &amp;quot;${file_contexts_path}&amp;quot; -r &amp;quot;${D}&amp;quot; &amp;quot;${D}&amp;quot;
 * ERROR: dev-libs/libpcre-8.35::gentoo …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;SELinux users might be facing failures when emerge is merging a package
to the file system, with an error that looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Setting SELinux security labels
/usr/lib64/portage/bin/misc-functions.sh: line 1112: 23719 Segmentation fault      /usr/sbin/setfiles &amp;quot;${file_contexts_path}&amp;quot; -r &amp;quot;${D}&amp;quot; &amp;quot;${D}&amp;quot;
 * ERROR: dev-libs/libpcre-8.35::gentoo failed:
 *   Failed to set SELinux security labels.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This has been &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=516608"&gt;reported as bug
516608&lt;/a&gt; and, after some
investigation, the cause is found. First the quick workaround:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# cd /etc/selinux/strict/contexts/files
~# rm *.bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And do the same for the other SELinux policy stores on the system
(targeted, mcs, mls, ...).&lt;/p&gt;
&lt;p&gt;Now, what is happening... Inside the mentioned directory, binary files
exist such as &lt;code&gt;file_contexts.bin&lt;/code&gt;. These files contain the compiled
regular expressions of the non-binary files (like &lt;code&gt;file_contexts&lt;/code&gt;). By
using the precompiled versions, regular expression matching by the
SELinux utilities is a lot faster. Not that it is massively slow
otherwise, but it is a nice speed improvement nonetheless.&lt;/p&gt;
&lt;p&gt;However, when pcre updates occur, then the basic structures that pcre
uses internally might change. For instance, a number might switch from a
signed integer to an unsigned integer. As pcre is meant to be used
within the same application run, most applications do not have any
issues with such changes. However, the SELinux utilities effectively
serialize these structures and later read them back in. If the new pcre
uses a changed structure, then the read-in structures are incompatible
and even corrupt.&lt;/p&gt;
&lt;p&gt;Hence the segmentation faults.&lt;/p&gt;
&lt;p&gt;To resolve this, &lt;a href="http://marc.info/?l=selinux&amp;amp;m=140492568205937&amp;amp;w=2"&gt;Stephen
Smalley&lt;/a&gt; created a
patch that includes PCRE version checking. This patch is now included in
&lt;a href="http://packages.gentoo.org/package/sys-libs/libselinux"&gt;sys-libs/libselinux&lt;/a&gt;
version 2.3-r1. The package also recompiles the existing &lt;code&gt;*.bin&lt;/code&gt; files
so that the older binary files are no longer on the system. But there is
a significant chance that this update will not trickle down to the users
in time, so the workaround might be needed.&lt;/p&gt;
&lt;p&gt;I considered updating the pcre ebuilds as well with this workaround, but
considering that libselinux is most likely to be stabilized faster than
any libpcre bump I let it go.&lt;/p&gt;
&lt;p&gt;At least we have a solution for future upgrades; sorry for the noise.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit:&lt;/em&gt; &lt;code&gt;libselinux-2.2.2-r5&lt;/code&gt; also has the fix included.&lt;/p&gt;</content><category term="SELinux"></category><category term="file_contexts"></category><category term="fix"></category><category term="Gentoo"></category><category term="libselinux"></category><category term="pcre"></category></entry><entry><title>D-Bus and SELinux</title><link href="https://blog.siphos.be/2014/06/d-bus-and-selinux/" rel="alternate"></link><published>2014-06-30T20:07:00+02:00</published><updated>2014-06-30T20:07:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-06-30:/2014/06/d-bus-and-selinux/</id><summary type="html">&lt;p&gt;After a &lt;a href="http://blog.siphos.be/2014/06/d-bus-quick-recap/"&gt;post about
D-Bus&lt;/a&gt; comes the
inevitable related post about SELinux with D-Bus.&lt;/p&gt;
&lt;p&gt;Some users might not know that D-Bus is an SELinux-aware application.
That means it has SELinux-specific code in it, which has the D-Bus
behavior based on the SELinux policy (and might not necessarily honor
the "permissive …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After a &lt;a href="http://blog.siphos.be/2014/06/d-bus-quick-recap/"&gt;post about
D-Bus&lt;/a&gt; comes the
inevitable related post about SELinux with D-Bus.&lt;/p&gt;
&lt;p&gt;Some users might not know that D-Bus is an SELinux-aware application.
That means it has SELinux-specific code in it, which has the D-Bus
behavior based on the SELinux policy (and might not necessarily honor
the "permissive" flag). This code is used as an additional
authentication control within D-Bus.&lt;/p&gt;
&lt;p&gt;Inside the SELinux policy, a &lt;em&gt;dbus&lt;/em&gt; permission class is supported, even
though the Linux kernel doesn't do anything with this class. The class
is purely for D-Bus, and it is D-Bus that checks the permission
(although work is being made to &lt;a href="https://lwn.net/Articles/580194/"&gt;implement D-Bus in kernel
(kdbus)&lt;/a&gt;). The class supports two
permission checks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;acquire_svc&lt;/em&gt; which tells the domain(s) allowed to "own" a service
    (which might, thanks to the SELinux support, be different from the
    domain itself)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;send_msg&lt;/em&gt; which tells which domain(s) can send messages to a
    service domain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inside the D-Bus security configuration (the &lt;code&gt;busconfig&lt;/code&gt; XML file,
remember) a service configuration might tell D-Bus that the service
itself is labeled differently from the process that owned the service.
The default is that the service inherits the label from the domain, so
when &lt;code&gt;dnsmasq_t&lt;/code&gt; registers a service on the system bus, then this
service also inherits the &lt;code&gt;dnsmasq_t&lt;/code&gt; label.&lt;/p&gt;
&lt;p&gt;The necessary permission checks for the &lt;code&gt;sysadm_t&lt;/code&gt; user domain to send
messages to the dnsmasq service, and the dnsmasq service itself to
register it as a service:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow dnsmasq_t self:dbus { acquire_svc send_msg };
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For the &lt;code&gt;sysadm_t&lt;/code&gt; domain, the two rules are needed as we usually not
only want to send a message to a D-Bus service, but also receive a reply
(which is also handled through a &lt;em&gt;send_msg&lt;/em&gt; permission but in the
inverse direction).&lt;/p&gt;
&lt;p&gt;However, with the following XML snippet inside its service configuration
file, owning a certain resource is checked against a different label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;busconfig&amp;gt;
  &amp;lt;selinux&amp;gt;
    &amp;lt;associate
      own=&amp;quot;uk.org.thekelleys.dnsmasq&amp;quot;
      context=&amp;quot;system_u:object_r:dnsmasq_dbus_t:s0&amp;quot; /&amp;gt;
  &amp;lt;/selinux&amp;gt;
&amp;lt;/busconfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this, the rules would become as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow dnsmasq_t dnsmasq_dbus_t:dbus acquire_svc;
allow dnsmasq_t self:dbus send_msg;
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that &lt;em&gt;only&lt;/em&gt; the access for acquiring a service based on a name
(i.e. owning a service) is checked based on the different label. Sending
and receiving messages is still handled by the domains of the processes
(actually the labels of the connections, but these are always the
process domains).&lt;/p&gt;
&lt;p&gt;I am not aware of any policy implementation that uses a different label
for owning services, and the implementation is more suited to "force"
D-Bus to only allow services with a correct label. This ensures that
other domains that might have enough privileges to interact with D-Bus
and own a service cannot own these particular services. After all, other
services don't usually have the privileges (policy-wise) to
&lt;em&gt;acquire_svc&lt;/em&gt; a service with a different label than their own label.&lt;/p&gt;</content><category term="SELinux"></category><category term="busconfig"></category><category term="d-bus"></category><category term="dbus"></category><category term="linux"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Chroots for SELinux enabled applications</title><link href="https://blog.siphos.be/2014/06/chroots-for-selinux-enabled-applications/" rel="alternate"></link><published>2014-06-22T20:16:00+02:00</published><updated>2014-06-22T20:16:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-06-22:/2014/06/chroots-for-selinux-enabled-applications/</id><summary type="html">&lt;p&gt;Today I had to prepare a chroot jail (thank you grsecurity for the neat
additional chroot protection features) for a SELinux-enabled
application. As a result, "just" making a chroot was insufficient: the
application needed access to &lt;code&gt;/sys/fs/selinux&lt;/code&gt;. Of course, granting
access to &lt;code&gt;/sys&lt;/code&gt; is not something I like …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today I had to prepare a chroot jail (thank you grsecurity for the neat
additional chroot protection features) for a SELinux-enabled
application. As a result, "just" making a chroot was insufficient: the
application needed access to &lt;code&gt;/sys/fs/selinux&lt;/code&gt;. Of course, granting
access to &lt;code&gt;/sys&lt;/code&gt; is not something I like to see for a chroot jail.&lt;/p&gt;
&lt;p&gt;Luckily, all other accesses are not needed, so I was able to create a
static &lt;code&gt;/sys/fs/selinux&lt;/code&gt; directory structure in the chroot, and then
just mount the SELinux file system on that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# mount -t selinuxfs none /var/chroot/sys/fs/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In hindsight, I probably could just have created a &lt;code&gt;/selinux&lt;/code&gt; location
as that location, although deprecated, is still checked by the SELinux
libraries.&lt;/p&gt;
&lt;p&gt;Anyway, there was a second requirement: access to &lt;code&gt;/etc/selinux&lt;/code&gt;.
Luckily it was purely for read operations, so I was first contemplating
of copying the data and doing a &lt;strong&gt;chmod -R a-w
/var/chroot/etc/selinux&lt;/strong&gt;, but then considered a bind-mount:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# mount -o bind,ro /etc/selinux /var/chroot/etc/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Alas, bad luck - the read-only flag is ignored during the mount, and the
bind-mount is still read-write. A &lt;a href="http://lwn.net/Articles/281157/"&gt;simple article on
lwn.net&lt;/a&gt; informed me about the
solution: I need to do a remount afterwards to enable the read-only
state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# mount -o remount,ro /var/chroot/etc/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Great! And because my brain isn't what it used to be, I just make a
quick blog for future reference ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="bind-mount"></category><category term="bindmount"></category><category term="mount"></category><category term="read-only"></category><category term="ro"></category><category term="selinux"></category></entry><entry><title>Visualizing constraints</title><link href="https://blog.siphos.be/2014/05/visualizing-constraints/" rel="alternate"></link><published>2014-05-31T03:47:00+02:00</published><updated>2014-05-31T03:47:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-05-31:/2014/05/visualizing-constraints/</id><summary type="html">&lt;p&gt;SELinux constraints are an interesting way to implement specific, well,
constraints on what SELinux allows. Most SELinux rules that users come
in contact with are purely type oriented: allow something to do
something against something. In fact, most of the SELinux rules applied
on a system are such &lt;code&gt;allow&lt;/code&gt; rules …&lt;/p&gt;</summary><content type="html">&lt;p&gt;SELinux constraints are an interesting way to implement specific, well,
constraints on what SELinux allows. Most SELinux rules that users come
in contact with are purely type oriented: allow something to do
something against something. In fact, most of the SELinux rules applied
on a system are such &lt;code&gt;allow&lt;/code&gt; rules.&lt;/p&gt;
&lt;p&gt;The restriction of such &lt;code&gt;allow&lt;/code&gt; rules is that they only take into
consideration the &lt;em&gt;type&lt;/em&gt; of the contexts that participate. This is the
&lt;a href="https://wiki.gentoo.org/wiki/SELinux/Type_enforcement"&gt;type
enforcement&lt;/a&gt; part
of the SELinux mandatory access control system.&lt;/p&gt;
&lt;p&gt;Constraints on the other hand work on the user, role and type part of a
context. Consider this piece of constraint code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;constrain file all_file_perms (
  u1 == u2
  or u1 == system_u
  or u2 == system_u
  or t1 != ubac_constrained_type
  or t2 != ubac_constrained_type
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This particular constraint definition tells the SELinux subsystem that,
when an operation against a &lt;em&gt;file&lt;/em&gt; class is performed (any operation, as
&lt;em&gt;all_file_perms&lt;/em&gt; is used, but individual, specific permissions can be
listed as well), this is denied if none of the following conditions are
met:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The SELinux user of the subject and object are the same&lt;/li&gt;
&lt;li&gt;The SELinux user of the subject or object is &lt;code&gt;system_u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The SELinux type of the subject does not have the
    &lt;code&gt;ubac_constrained_type&lt;/code&gt; attribute set&lt;/li&gt;
&lt;li&gt;The SELinux type of the object does not have the
    &lt;code&gt;ubac_constrained_type&lt;/code&gt; attribute set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If none of the conditions are met, then the action is denied, regardless
of the &lt;code&gt;allow&lt;/code&gt; rules set otherwise. If at least one condition is met,
then the &lt;code&gt;allow&lt;/code&gt; rules (and other SELinux rules) decide if an action can
be taken or not.&lt;/p&gt;
&lt;p&gt;Constraints are currently difficult to query though. There is &lt;strong&gt;seinfo
--constrain&lt;/strong&gt; which gives all constraints, using the Reverse Polish
Notation - not something easily readable by users:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ seinfo --constrain
constrain { sem } { create destroy getattr setattr read write associate unix_read unix_write  } 
(  u1 u2 ==  u1 system_u ==  ||  u2 system_u ==  ||  t1 { screen_var_run_t gnome_xdg_config_home_t admin_crontab_t 
links_input_xevent_t gpg_pinentry_tmp_t virt_content_t print_spool_t crontab_tmp_t httpd_user_htaccess_t ssh_keysign_t 
remote_input_xevent_t gnome_home_t mozilla_tmpfs_t staff_gkeyringd_t consolekit_input_xevent_t user_mail_tmp_t 
chromium_xdg_config_t mozilla_input_xevent_t chromium_tmp_t httpd_user_script_exec_t gnome_keyring_tmp_t links_tmpfs_t 
skype_tmp_t user_gkeyringd_t svirt_home_t sysadm_su_t virt_home_t skype_home_t wireshark_tmp_t xscreensaver_xproperty_t 
consolekit_xproperty_t user_home_dir_t gpg_pinentry_xproperty_t mplayer_home_t mozilla_plugin_input_xevent_t mozilla_plugin_tmp_t 
mozilla_xproperty_t xdm_input_xevent_t chromium_input_xevent_t java_tmpfs_t googletalk_plugin_xproperty_t sysadm_t gorg_t gpg_t 
java_t links_t staff_dbusd_t httpd_user_ra_content_t httpd_user_rw_content_t googletalk_plugin_tmp_t gpg_agent_tmp_t 
ssh_agent_tmp_t sysadm_ssh_agent_t user_fonts_cache_t user_tmp_t googletalk_plugin_input_xevent_t user_dbusd_t xserver_tmpfs_t 
iceauth_home_t qemu_input_xevent_t xauth_home_t mutt_home_t sysadm_dbusd_t remote_xproperty_t gnome_xdg_config_t screen_home_t 
chromium_xproperty_t chromium_tmpfs_t wireshark_tmpfs_t xdg_videos_home_t pulseaudio_input_xevent_t krb5_home_t 
pulseaudio_xproperty_t xscreensaver_input_xevent_t gpg_pinentry_input_xevent_t httpd_user_script_t gnome_xdg_cache_home_t 
mozilla_plugin_tmpfs_t user_home_t user_sudo_t ssh_input_xevent_t ssh_tmpfs_t xdg_music_home_t gconf_tmp_t flash_home_t 
java_home_t skype_tmpfs_t xdg_pictures_home_t xdg_data_home_t gnome_keyring_home_t wireshark_home_t chromium_renderer_xproperty_t 
gpg_pinentry_t mozilla_t session_dbusd_tmp_t staff_sudo_t xdg_config_home_t user_su_t pan_input_xevent_t user_devpts_t 
mysqld_home_t pan_tmpfs_t root_input_xevent_t links_home_t sysadm_screen_t pulseaudio_tmpfs_t sysadm_gkeyringd_t mail_home_rw_t 
gconf_home_t mozilla_plugin_xproperty_t mutt_tmp_t httpd_user_content_t mozilla_xdg_cache_t mozilla_home_t alsa_home_t 
pulseaudio_t mencoder_t admin_crontab_tmp_t xdg_documents_home_t user_tty_device_t java_tmp_t gnome_xdg_data_home_t wireshark_t 
mozilla_plugin_home_t googletalk_plugin_tmpfs_t user_cron_spool_t mplayer_input_xevent_t skype_input_xevent_t xxe_home_t 
mozilla_tmp_t gconfd_t lpr_t mutt_t pan_t ssh_t staff_t user_t xauth_t skype_xproperty_t mozilla_plugin_config_t 
links_xproperty_t mplayer_xproperty_t xdg_runtime_home_t cert_home_t mplayer_tmpfs_t user_fonts_t user_tmpfs_t mutt_conf_t 
gpg_secret_t gpg_helper_t staff_ssh_agent_t pulseaudio_tmp_t xscreensaver_t googletalk_plugin_xdg_config_t staff_screen_t 
user_fonts_config_t ssh_home_t staff_su_t screen_tmp_t mozilla_plugin_t user_input_xevent_t xserver_tmp_t wireshark_xproperty_t 
user_mail_t pulseaudio_home_t xdg_cache_home_t user_ssh_agent_t xdg_downloads_home_t chromium_renderer_input_xevent_t cronjob_t 
crontab_t pan_home_t session_dbusd_home_t gpg_agent_t xauth_tmp_t xscreensaver_tmpfs_t iceauth_t mplayer_t chromium_xdg_cache_t 
lpr_tmp_t gpg_pinentry_tmpfs_t pan_xproperty_t ssh_xproperty_t xdm_xproperty_t java_xproperty_t sysadm_sudo_t qemu_xproperty_t 
root_xproperty_t user_xproperty_t mail_home_t xserver_t java_input_xevent_t user_screen_t wireshark_input_xevent_t } !=  ||  t2 { 
screen_var_run_t gnome_xdg_config_home_t admin_crontab_t links_input_xevent_t gpg_pinentry_tmp_t virt_content_t print_spool_t 
crontab_tmp_t httpd_user_htaccess_t ssh_keysign_t remote_input_xevent_t gnome_home_t mozilla_tmpfs_t staff_gkeyringd_t 
consolekit_input_xevent_t user_mail_tmp_t chromium_xdg_config_t mozilla_input_xevent_t chromium_tmp_t httpd_user_script_exec_t 
gnome_keyring_tmp_t links_tmpfs_t skype_tmp_t user_gkeyringd_t svirt_home_t sysadm_su_t virt_home_t skype_home_t wireshark_tmp_t 
xscreensaver_xproperty_t consolekit_xproperty_t user_home_dir_t gpg_pinentry_xproperty_t mplayer_home_t 
mozilla_plugin_input_xevent_t mozilla_plugin_tmp_t mozilla_xproperty_t xdm_input_xevent_t chromium_input_xevent_t java_tmpfs_t 
googletalk_plugin_xproperty_t sysadm_t gorg_t gpg_t java_t links_t staff_dbusd_t httpd_user_ra_content_t httpd_user_rw_content_t 
googletalk_plugin_tmp_t gpg_agent_tmp_t ssh_agent_tmp_t sysadm_ssh_agent_t user_fonts_cache_t user_tmp_t 
googletalk_plugin_input_xevent_t user_dbusd_t xserver_tmpfs_t iceauth_home_t qemu_input_xevent_t xauth_home_t mutt_home_t 
sysadm_dbusd_t remote_xproperty_t gnome_xdg_config_t screen_home_t chromium_xproperty_t chromium_tmpfs_t wireshark_tmpfs_t 
xdg_videos_home_t pulseaudio_input_xevent_t krb5_home_t pulseaudio_xproperty_t xscreensaver_input_xevent_t 
gpg_pinentry_input_xevent_t httpd_user_script_t gnome_xdg_cache_home_t mozilla_plugin_tmpfs_t user_home_t user_sudo_t 
ssh_input_xevent_t ssh_tmpfs_t xdg_music_home_t gconf_tmp_t flash_home_t java_home_t skype_tmpfs_t xdg_pictures_home_t 
xdg_data_home_t gnome_keyring_home_t wireshark_home_t chromium_renderer_xproperty_t gpg_pinentry_t mozilla_t session_dbusd_tmp_t 
staff_sudo_t xdg_config_home_t user_su_t pan_input_xevent_t user_devpts_t mysqld_home_t pan_tmpfs_t root_input_xevent_t 
links_home_t sysadm_screen_t pulseaudio_tmpfs_t sysadm_gkeyringd_t mail_home_rw_t gconf_home_t mozilla_plugin_xproperty_t 
mutt_tmp_t httpd_user_content_t mozilla_xdg_cache_t mozilla_home_t alsa_home_t pulseaudio_t mencoder_t admin_crontab_tmp_t 
xdg_documents_home_t user_tty_device_t java_tmp_t gnome_xdg_data_home_t wireshark_t mozilla_plugin_home_t 
googletalk_plugin_tmpfs_t user_cron_spool_t mplayer_input_xevent_t skype_input_xevent_t xxe_home_t mozilla_tmp_t gconfd_t lpr_t 
mutt_t pan_t ssh_t staff_t user_t xauth_t skype_xproperty_t mozilla_plugin_config_t links_xproperty_t mplayer_xproperty_t 
xdg_runtime_home_t cert_home_t mplayer_tmpfs_t user_fonts_t user_tmpfs_t mutt_conf_t gpg_secret_t gpg_helper_t staff_ssh_agent_t 
pulseaudio_tmp_t xscreensaver_t googletalk_plugin_xdg_config_t staff_screen_t user_fonts_config_t ssh_home_t staff_su_t 
screen_tmp_t mozilla_plugin_t user_input_xevent_t xserver_tmp_t wireshark_xproperty_t user_mail_t pulseaudio_home_t 
xdg_cache_home_t user_ssh_agent_t xdg_downloads_home_t chromium_renderer_input_xevent_t cronjob_t crontab_t pan_home_t 
session_dbusd_home_t gpg_agent_t xauth_tmp_t xscreensaver_tmpfs_t iceauth_t mplayer_t chromium_xdg_cache_t lpr_tmp_t 
gpg_pinentry_tmpfs_t pan_xproperty_t ssh_xproperty_t xdm_xproperty_t java_xproperty_t sysadm_sudo_t qemu_xproperty_t 
root_xproperty_t user_xproperty_t mail_home_t xserver_t java_input_xevent_t user_screen_t wireshark_input_xevent_t } !=  ||  t1 
 ==  || );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There RPN notation however isn't the only reason why constraints are
difficult to read. The other reason is that &lt;strong&gt;seinfo&lt;/strong&gt; does not know
(anymore) about the attributes used to generate the constraints. As a
result, we get a huge list of all possible types that match a common
attribute - but we don't know which anymore.&lt;/p&gt;
&lt;p&gt;Not everyone can read the source files in which the constraints are
defined, so I hacked together a script that generates
&lt;a href="http://graphviz.org/"&gt;GraphViz&lt;/a&gt; dot file based on the &lt;strong&gt;seinfo
--constrain&lt;/strong&gt; output for a given &lt;em&gt;class&lt;/em&gt; and &lt;em&gt;permission&lt;/em&gt; and,
optionally, limiting the huge list of types to a set that the user (err,
that is me ;-) is interested in.&lt;/p&gt;
&lt;p&gt;For instance, to generate a graph of the constraints related to file
reads, limited to the &lt;code&gt;user_t&lt;/code&gt; and &lt;code&gt;staff_t&lt;/code&gt; types if huge lists would
otherwise be shown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ seshowconstraint file read &amp;quot;user_t staff_t&amp;quot; &amp;gt; constraint-file.dot
~$ dot -Tsvg -O constraint-file.dot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This generates the following graph:&lt;/p&gt;
&lt;p&gt;!SELinux constraint flow&lt;a href="http://dev.gentoo.org/~swift/blog/201405/constraint-flow.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you're interested in the (ugly) script that does this, you can find
it on my
&lt;a href="https://github.com/sjvermeu/small.coding/blob/master/se_scripts/seshowconstraint"&gt;github&lt;/a&gt;
location.&lt;/p&gt;
&lt;p&gt;There are some patches laying around to support naming constraints and
taking the name up in the policy, so that denials based on constraints
can at least give feedback to the user which constraint is holding an
access back (rather than just a denial that the user doesn't know why).
Hopefully such patches can be made available in the kernel and user
space utilities soon.&lt;/p&gt;</content><category term="SELinux"></category><category term="constrain"></category><category term="constraints"></category><category term="dot"></category><category term="graphviz"></category><category term="seinfo"></category><category term="selinux"></category></entry><entry><title>If things are weird, check for policy.29</title><link href="https://blog.siphos.be/2014/04/if-things-are-weird-check-for-policy-29/" rel="alternate"></link><published>2014-04-17T21:01:00+02:00</published><updated>2014-04-17T21:01:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-04-17:/2014/04/if-things-are-weird-check-for-policy-29/</id><summary type="html">&lt;p&gt;Today we analyzed a weird issue one of our SELinux users had with their
system. He had a denial when calling &lt;strong&gt;audit2allow&lt;/strong&gt;, informing us that
&lt;code&gt;sysadm_t&lt;/code&gt; had no rights to read the SELinux policy. This is a known
issue that has been resolved in our current SELinux policy repository
but …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today we analyzed a weird issue one of our SELinux users had with their
system. He had a denial when calling &lt;strong&gt;audit2allow&lt;/strong&gt;, informing us that
&lt;code&gt;sysadm_t&lt;/code&gt; had no rights to read the SELinux policy. This is a known
issue that has been resolved in our current SELinux policy repository
but which needs to be pushed to the tree (which is my job, sorry about
that). The problem however is when he added the policy - it didn't work.&lt;/p&gt;
&lt;p&gt;Even worse, &lt;strong&gt;sesearch&lt;/strong&gt; told us that the policy has been modified
correctly - but it still doesn't work. Check your policy with
&lt;strong&gt;sestatus&lt;/strong&gt; and &lt;strong&gt;seinfo&lt;/strong&gt; and they're all saying things are working
well. And yet ... things don't. Apparently, all policy changes are
ignored.&lt;/p&gt;
&lt;p&gt;The reason? There was a &lt;code&gt;policy.29&lt;/code&gt; file in &lt;code&gt;/etc/selinux/mcs/policy&lt;/code&gt;
which was always loaded, even though the user already edited
&lt;code&gt;/etc/selinux/semanage.conf&lt;/code&gt; to have &lt;code&gt;policy-version&lt;/code&gt; set to 28.&lt;/p&gt;
&lt;p&gt;It is already a problem that we need to tell users to edit
&lt;code&gt;semanage.conf&lt;/code&gt; to a fixed version (because binary version 29 is not
supported by most Linux kernels as it has been very recently introduced)
but having &lt;strong&gt;load_policy&lt;/strong&gt; (which is called by &lt;strong&gt;semodule&lt;/strong&gt; when a
policy needs to be loaded) loading a stale &lt;code&gt;policy.29&lt;/code&gt; file is just...
disappointing.&lt;/p&gt;
&lt;p&gt;Anyway - if you see weird behavior, check both the &lt;code&gt;semanage.conf&lt;/code&gt; file
(and set &lt;code&gt;policy-version = 28&lt;/code&gt;) as well as the contents of your
&lt;code&gt;/etc/selinux/*/policy&lt;/code&gt; directory. If you see any &lt;code&gt;policy.*&lt;/code&gt; that isn't
version 28, delete them.&lt;/p&gt;</content><category term="SELinux"></category><category term="load_policy"></category><category term="policy"></category><category term="selinux"></category><category term="semanage"></category></entry><entry><title>Decoding the hex-coded path information in AVC denials</title><link href="https://blog.siphos.be/2014/03/decoding-the-hex-coded-path-information-in-avc-denials/" rel="alternate"></link><published>2014-03-30T16:37:00+02:00</published><updated>2014-03-30T16:37:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-30:/2014/03/decoding-the-hex-coded-path-information-in-avc-denials/</id><summary type="html">&lt;p&gt;When investigating AVC denials, some denials show a path that isn't
human readable, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1396189189.734:1913): avc:  denied  { execute } for  pid=17955 comm=&amp;quot;emerge&amp;quot; path=2F7661722F666669737A69596157202864656C6574656429 dev=&amp;quot;dm-3&amp;quot; ino=1838 scontext=staff_u:sysadm_r:portage_t tcontext=staff_u:object_r:var_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To know what this …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When investigating AVC denials, some denials show a path that isn't
human readable, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1396189189.734:1913): avc:  denied  { execute } for  pid=17955 comm=&amp;quot;emerge&amp;quot; path=2F7661722F666669737A69596157202864656C6574656429 dev=&amp;quot;dm-3&amp;quot; ino=1838 scontext=staff_u:sysadm_r:portage_t tcontext=staff_u:object_r:var_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To know what this file is (or actually was, because such encoded paths
mean that the file ~~wasn't accessible anymore at the time that the
denial was shown~~ contains a space), you need to hex-decode the value.
For instance, with python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ python -c &amp;quot;import base64; print(base64.b16decode(\&amp;quot;2F7661722F666669737A69596157202864656C6574656429\&amp;quot;));&amp;quot;;
b&amp;#39;/var/ffisziYaW (deleted)&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above example, &lt;code&gt;/var/ffisziYaW&lt;/code&gt; was the path of the file (note
that, as it starts with ffi, it is caused by libffi which I've blogged
about before). The reason that the file was deleted at the time the
denial was generated is because what libffi does is create a file, get
the file descriptor and unlink the file (so it is deleted and only the
(open) file handle allows for accessing it) before it wants to execute
it. As a result, the execution (which is denied) triggers a denial for
the file whose path is no longer valid (as it is now appended with
"&lt;code&gt;(deleted)&lt;/code&gt;").&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit 1:&lt;/em&gt; Thanks to IooNag who pointed me to the truth that it is due to
a space in the file name, not because it was deleted. Having the file
deleted makes the patch be appended with "&lt;code&gt;(deleted)&lt;/code&gt;" which contains a
space.&lt;/p&gt;</content><category term="SELinux"></category><category term="avc"></category><category term="decode"></category><category term="path"></category><category term="selinux"></category></entry><entry><title>Querying SELinux policy for boolean information</title><link href="https://blog.siphos.be/2014/03/querying-selinux-policy-for-boolean-information/" rel="alternate"></link><published>2014-03-28T23:38:00+01:00</published><updated>2014-03-28T23:38:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-28:/2014/03/querying-selinux-policy-for-boolean-information/</id><summary type="html">&lt;p&gt;Within an SELinux policy, certain access vectors (permissions) can be
conditionally granted based on the value of a &lt;em&gt;SELinux boolean&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To find the list of SELinux booleans that are available on your system,
you can use the &lt;strong&gt;getsebool -a&lt;/strong&gt; method, or &lt;strong&gt;semanage boolean -l&lt;/strong&gt;. The
latter also displays the description …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Within an SELinux policy, certain access vectors (permissions) can be
conditionally granted based on the value of a &lt;em&gt;SELinux boolean&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To find the list of SELinux booleans that are available on your system,
you can use the &lt;strong&gt;getsebool -a&lt;/strong&gt; method, or &lt;strong&gt;semanage boolean -l&lt;/strong&gt;. The
latter also displays the description of the boolean:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage boolean -l | grep user_ping
user_ping                      (on   ,   on)  Control users use of ping and traceroute
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can easily query the SELinux policy to see what this boolean
triggers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# sesearch -b user_ping -A -C
Found 22 semantic av rules:
ET allow ping_t staff_t : process sigchld ; [ user_ping ]
ET allow ping_t staff_t : fd use ; [ user_ping ]
ET allow ping_t staff_t : fifo_file { ioctl read write getattr lock append open } ; [ user_ping ]
ET allow ping_t user_t : process sigchld ; [ user_ping ]
ET allow ping_t user_t : fd use ; [ user_ping ]
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, often you want to know if a particular access is allowed and,
if it is conditionally allowed, which boolean enables it. In the case of
user ping, we want to know if (and when) a user domain (&lt;code&gt;user_t&lt;/code&gt;) is
allowed to transition to the ping domain (&lt;code&gt;ping_t&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# sesearch -s user_t -t ping_t -c process -p transition -ACTS
Found 1 semantic av rules:
ET allow user_t ping_t : process transition ; [ user_ping ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So there you go - it is allowed if the &lt;code&gt;user_ping&lt;/code&gt; SELinux boolean is
enabled.&lt;/p&gt;</content><category term="SELinux"></category><category term="boolean"></category><category term="query"></category><category term="selinux"></category><category term="sesearch"></category></entry><entry><title>Switching context depending on user code-wise</title><link href="https://blog.siphos.be/2014/01/switching-context-depending-on-user-code-wise/" rel="alternate"></link><published>2014-01-12T22:43:00+01:00</published><updated>2014-01-12T22:43:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-12:/2014/01/switching-context-depending-on-user-code-wise/</id><summary type="html">&lt;p&gt;I blogged about how SELinux decides what the context should be for a
particular Linux user; how it checks the default context(s) and tells
the SELinux-aware application on what the new context should be. Let's
look into the C code that does so, and how an application should behave …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I blogged about how SELinux decides what the context should be for a
particular Linux user; how it checks the default context(s) and tells
the SELinux-aware application on what the new context should be. Let's
look into the C code that does so, and how an application should behave
depending on the enforcing/permissive mode...&lt;/p&gt;
&lt;p&gt;I use the following, extremely simple C that fork()'s and executes
&lt;code&gt;id -Z&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;

#define DEBUG  7
#define INFO   6
#define NOTICE 5
#define WARN   4
#define ERR    3
#define CRIT   2
#define ALERT  1
#define EMERG  0

#ifndef LOGLEVEL
#define LOGLEVEL 4
#endif

/* out - Simple output */
void out(int level, char * msg, ...) {
  if (level &amp;lt;= LOGLEVEL) {
    va_list ap;
    printf(&amp;quot;%d - &amp;quot;, level);

    va_start(ap, msg);
    vprintf(msg, ap);
    va_end(ap);
  };
};
int main(int argc, char * argv[]) {
  int rc = 0;
  pid_t child;

  child = fork();
  if (child &amp;lt; 0) {
    out(WARN, &amp;quot;fork() failed\n&amp;quot;, NULL);
  };

  if (child == 0) {
    int pidrc;
    pidrc = execl(&amp;quot;/usr/bin/id&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;-Z&amp;quot;, NULL);
    if (pidrc != 0) {
      out(WARN, &amp;quot;Command failed with return code %d\n&amp;quot;, pidrc);
    };
    return(0);
  } else {
    int status;
    out(DEBUG, &amp;quot;Child is %d\n&amp;quot;, child);
    wait(&amp;amp;status);
    out(DEBUG, &amp;quot;Child exited with %d\n&amp;quot;, status);
  };
  return 0;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code is ran as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ test myusername
staff_u:staff_r:staff_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, it shows the output of the &lt;code&gt;id -Z&lt;/code&gt; command. Let's
enhance this code with some SELinux specific functions. The purpose of
the application now is to ask SELinux what the context should be that
the command should run in, and switch to that context for the &lt;code&gt;id -Z&lt;/code&gt;
invocation.&lt;/p&gt;
&lt;p&gt;We will include the necessary SELinux code with &lt;code&gt;#ifdef SELINUX&lt;/code&gt;,
allowing the application to be build without SELinux code if wanted.&lt;/p&gt;
&lt;p&gt;First, add in the proper &lt;code&gt;#include&lt;/code&gt; directives.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#ifdef SELINUX
#include &amp;lt;selinux/selinux.h&amp;gt;
#include &amp;lt;selinux/flask.h&amp;gt;
#include &amp;lt;selinux/av_permissions.h&amp;gt;
#include &amp;lt;selinux/get_context_list.h&amp;gt;
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, we create a function called &lt;em&gt;selinux_prepare_fork()&lt;/em&gt; which takes
one input variable: the Linux user name for which we are going to
transition (and thus run &lt;code&gt;id -Z&lt;/code&gt; for). This function can always be
called, even if SELinux is not built in. If that happens, we return 0
immediately.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/* selinux_prepare_fork - Initialize context switching
 *
 * Returns
 *  - 0 if everything is OK, 
 *  - +1 if the code should continue, even if SELinux wouldn&amp;#39;t allow
 *       (for instance due to permissive mode)
 *  - -1 if the code should not continue
 */
int selinux_prepare_fork(char * name) {
#ifndef SELINUX
  return 0;
#else
  // ... this is where the remainder goes
#endif
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We include this call in the application above, and take into account the
return codes passed on. As can be seen from the comment, if the
returncode is 0 (zero) then everything can go on as expected. A positive
return code means that there are some issues, but the application should
continue with its logic as SELinux is either in permissive, or the
domain in which the application runs is permissive - in either case, the
code will succeed. A returncode of -1 means that the code will most
likely fail and thus the application should log an error and exit or
break.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  pid_t child;

  rc = selinux_prepare_fork(argv[1]);
  if (rc &amp;lt; 0) {
    out(WARN, &amp;quot;The necessary context change will fail.\n&amp;quot;);
    // Continuing here would mean that the newly started process
    // runs in the wrong context (current context) which might
    // be either too privileged, or not privileged enough.
    return -1;
  } else if (rc &amp;gt; 0) {
    out(WARN, &amp;quot;The necessary context change will fail, but permissive mode is active.\n&amp;quot;);
  };

  child = fork();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now all we need to do is fill in the logic in &lt;em&gt;selinux_prepare_fork&lt;/em&gt;.
Let's start with the variable declarations (boring stuff):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#ifndef SELINUX
  return 0;
#else
  security_context_t newcon = 0;
  security_context_t curcon = 0;
  struct av_decision avd;
  int rc;
  int permissive = 0;
  int dom_permissive = 0;

  char * sename = 0;
  char * selevel = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that out of the way, let's take our first step: we want to see if
SELinux is enabled or not. Applications that are SELinux-aware should
always check if SELinux itself is enabled and, if not, just continue
with the (application) logic.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * See if SELinux is enabled.
   * If not, then we can immediately tell the code
   * that everything is OK.
   */
  rc = is_selinux_enabled();
  if (rc == 0) {
    out(DEBUG, &amp;quot;SELinux is not enabled.\n&amp;quot;);
    return 0;
  } else if (rc == -1) {
    out(WARN, &amp;quot;Could not check SELinux state (is_selinux_enabled() failed)\n&amp;quot;);
    return 1;
  };
  out(DEBUG, &amp;quot;SELinux is enabled.\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, we use &lt;em&gt;is_selinux_enabled&lt;/em&gt; here to do just that. If
it returns 0, then it is not enabled. A returncode of 1 means it is
enabled, and -1 means something wicked happened. I recommend that
applications who are SELinux-aware enable info on these matters in
debugging output. Nothing is more annoying than having to debug
permission issues that might be SELinux-related, but are not enforced
through SELinux (and as such do not show up in any logs).&lt;/p&gt;
&lt;p&gt;Next, see if SELinux is in permissive mode and register this (as we need
this later for deciding to continue or not).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * See if SELinux is in enforcing mode
   * or permissive mode
   */
  rc = security_getenforce();
  if (rc == 0) {
    permissive = 1;
  } else if (rc == 1) {
    permissive = 0;
  } else {
    out(WARN, &amp;quot;Could not check SELinux mode (security_getenforce() failed)\n&amp;quot;);
  }
  out(DEBUG, &amp;quot;SELinux mode is %s\n&amp;quot;, permissive ? &amp;quot;permissive&amp;quot; : &amp;quot;enforcing&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;security_getenforce&lt;/em&gt; method will check the current SELinux mode
(enforcing or permissive). If SELinux is in permissive mode, then the
application logic should always go through - even if that means contexts
will go wrong and such. The end user marked the system in permissive
mode, meaning he does not want to have SELinux (or SELinux-aware
applications) to block things purely due to SELinux decisions, but log
when things are going wrong (for instance for policy development).&lt;/p&gt;
&lt;p&gt;Now, let's look up what the current context is (the context that the
process is running in). This will be used later for logging by the
SELinux-aware application in debugging mode. Often, applications that
fail run too short to find out if their context is correct or not, and
having it logged definitely helps. This step is not mandatory per se (as
you will see from the code later).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Get the current SELinux context of the process.
   * Always interesting to log this for end users
   * trying to debug a possible issue.
   */
  rc = getcon(&amp;amp;curcon);
  if (rc) {
    out(WARN, &amp;quot;Could not get current SELinux context (getcon() failed)\n&amp;quot;);
    if (permissive)
      return +1;
    else
      return -1;
  };
  out(DEBUG, &amp;quot;Currently in SELinux context \&amp;quot;%s\&amp;quot;\n&amp;quot;, (char *) curcon);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;getcon()&lt;/em&gt; method places the current context in the &lt;em&gt;curcon&lt;/em&gt;
variable. Note that from this point onwards, we should always
&lt;em&gt;freecon()&lt;/em&gt; the context before exiting the &lt;em&gt;selinux_prepare_fork()&lt;/em&gt;
method.&lt;/p&gt;
&lt;p&gt;A second important note is that, if we have a failure, we now check the
permissive state and return a positive error (SELinux is in permissive
mode, so log but continue) or negative error (SELinux is in enforcing
mode). The negative error is needed so that the code itself does not go
run the &lt;em&gt;fork()&lt;/em&gt; as it will fail anyway (or, it might succeed, but run
in the parent context which is not what the application should do).&lt;/p&gt;
&lt;p&gt;Next, we try to find out what the SELinux user is for the given Linux
account name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Get the SELinux user given the Linux user
   * name passed on to this function.
   */
  rc = getseuserbyname(name, &amp;amp;sename, &amp;amp;selevel);
  if (rc) {
    out(WARN, &amp;quot;Could not find SELinux user for Linux user \&amp;quot;%s\&amp;quot; (getseuserbyname() failed)\n&amp;quot;, name);
    freecon(curcon);
    if (permissive)
      return +1;
    else
      return -1;
  };
  out(DEBUG, &amp;quot;SELinux user for Linux user \&amp;quot;%s\&amp;quot; is \&amp;quot;%s\&amp;quot;\n&amp;quot;, name, sename);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;getseuserbyname()&lt;/em&gt; method returns the SELinux name for the given
Linux user. It also returns the MLS level (but we're not going to use
that in the remainder of the code). Again, if it fails, we check the
permissive state to see how to bail out.&lt;/p&gt;
&lt;p&gt;Now get the context to which we should transition when calling &lt;code&gt;id -Z&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Find out what the context is that this process should transition
   * to.
   */
  rc = get_default_context(sename, NULL, &amp;amp;newcon);
  if (rc) {
    out(WARN, &amp;quot;Could not deduce default context for SELinux user \&amp;quot;%s\&amp;quot; given our current context (\&amp;quot;%s\&amp;quot;)\n&amp;quot;, sename, (char *) curcon);
    freecon(curcon);
    if (permissive)
      return +1;
    else
      return -1;
  };
  out(DEBUG, &amp;quot;SELinux context to transition to is \&amp;quot;%s\&amp;quot;\n&amp;quot;, (char *) newcon);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;get_default_context()&lt;/em&gt; will do what I blogged about earlier.
It'll check what the contexts are in the user-specific context files or
the &lt;code&gt;default_contexts&lt;/code&gt; file, given the current context. You might notice
I don't pass on this context - the &lt;code&gt;NULL&lt;/code&gt; second argument means "use the
current context". This is why the &lt;em&gt;getcon()&lt;/em&gt; method earlier is not
strictly needed. But again, for logging (and thus debugging) this is
very much recommended.&lt;/p&gt;
&lt;p&gt;From this point onward, we also need to &lt;em&gt;freecon()&lt;/em&gt; the &lt;code&gt;newcon&lt;/code&gt;
variable before exiting the function.&lt;/p&gt;
&lt;p&gt;Now let's see if we are allowed to transition. We will query the SELinux
policy and see if a transition from the current context to the new
context is allowed (class &lt;code&gt;process&lt;/code&gt;, privilege &lt;code&gt;transition&lt;/code&gt;). I know, to
truly see if a transition is allowed, more steps should be checked, but
let's stick with this one permission.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Now let&amp;#39;s look if we are allowed to transition to the new context.
   * We currently only check the transition access for the process class. However,
   * transitioning is a bit more complex (execute rights on target context, 
   * entrypoint of that context for the new domain, no constraints like target
   * domain not being a valid one, MLS constraints, etc.).
   */
  rc = security_compute_av_flags(curcon, newcon, SECCLASS_PROCESS, PROCESS__TRANSITION, &amp;amp;avd);
  if (rc) {
    out(WARN, &amp;quot;Could not deduce rights for transitioning \&amp;quot;%s\&amp;quot; -&amp;gt; \&amp;quot;%s\&amp;quot; (security_compute_av_flags() failed)\n&amp;quot;, (char *) curcon, (char *) newcon);
    freecon(curcon);
    freecon(newcon);
    if (permissive)
      return +1;
    else
      return -1;
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above code, I didn't yet check the result. This is done in two
steps.&lt;/p&gt;
&lt;p&gt;In the first step, I want to know if the current context is a permissive
domain. Since a few years, SELinux supports permissive domains, so that
a single domain is permissive even though the rest of the system is in
enforcing mode. Currently, we only know if the system is in permissive
mode or not.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /* Validate the response 
   *
   * We are interested in two things:
   * - Is the transition allowed, but also
   * - Is the permissive flag set
   *
   * If the permissive flag is set, then we
   * know the current domain is permissive
   * (even if the rest of the system is in
   * enforcing mode).
   */
  if (avd.flags &amp;amp; SELINUX_AVD_FLAGS_PERMISSIVE) {
    out(DEBUG, &amp;quot;The SELINUX_AVD_FLAGS_PERMISSIVE flag is set, so domain is permissive.\n&amp;quot;);
    dom_permissive = 1;
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We check the flags provided to us by the SELinux subsystem and check if
&lt;code&gt;SELINUX_AVD_FLAGS_PERMISSIVE&lt;/code&gt; is set. If it is, then the current domain
is permissive, and we register this (in the &lt;code&gt;dom_permissive&lt;/code&gt; variable).
From this point onwards, &lt;code&gt;permissive=1&lt;/code&gt; or &lt;code&gt;dom_permissive=1&lt;/code&gt; is enough
to tell the real application logic to continue (even if things would
fail SELinux-wise) - the actions are executed by a permissive domain (or
system) and thus should continue.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  if (!(avd.allowed &amp;amp; PROCESS__TRANSITION)) {
    // The transition is denied
    if (permissive) {
      out(DEBUG, &amp;quot;Transition is not allowed by SELinux, but permissive mode is enabled. Continuing.\n&amp;quot;);
    };
    if (dom_permissive) {
      out(DEBUG, &amp;quot;Transition is not allowed by SELinux, but domain is in permissive mode. Continuing.\n&amp;quot;);
    };
    if ((permissive == 0) &amp;amp;&amp;amp; (dom_permissive == 0)) {
      out(WARN, &amp;quot;The domain transition is not allowed and we are not in permissive mode.\n&amp;quot;);
      freecon(curcon);
      freecon(newcon);
      return -1;
    };
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the second step, we checked if the requested operation (transition)
is allowed or not. If denied, we log it, but do not break out of the
function if either &lt;code&gt;permissive&lt;/code&gt; (SELinux permissive mode) or
&lt;code&gt;dom_permissive&lt;/code&gt; (domain is permissive) is set.&lt;/p&gt;
&lt;p&gt;Finally, we set the (new) context, telling the SELinux subsystem that
the next &lt;em&gt;exec()&lt;/em&gt; done by the application should also switch the domain
of the process to the new context (i.e. a domain transition):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Set the context for the fork (process execution).
   */
  rc = setexeccon(newcon);
  if (rc) {
    out(WARN, &amp;quot;Could not set execution context (setexeccon() failed)\n&amp;quot;);
    freecon(curcon);
    freecon(newcon);
    if ((permissive) || (dom_permissive))
      return +1;
    else
      return -1;
  };

  freecon(newcon);
  freecon(curcon);

  return 0;
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it - we free'd all our variables and can now have the application
continue (taking into account the return code of this function). As
mentioned before, a positive return code (0 or higher) means the logic
should continue; a strictly negative return code means that the
application should gracefully fail.&lt;/p&gt;</content><category term="SELinux"></category><category term="default_context"></category><category term="domain"></category><category term="libselinux"></category><category term="selinux"></category><category term="selinux-aware"></category><category term="transition"></category></entry><entry><title>It has finally arrived: SELinux System Administration</title><link href="https://blog.siphos.be/2013/09/it-has-finally-arrived-selinux-system-administration/" rel="alternate"></link><published>2013-09-27T15:10:00+02:00</published><updated>2013-09-27T15:10:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-09-27:/2013/09/it-has-finally-arrived-selinux-system-administration/</id><summary type="html">&lt;p&gt;Almost everyone has it - either physical or in their heads: a list of
things you want to do or achieve before you... well, stop existing. Mine
still has numerous things on it (I should get on it, I know) but one of
the items on that list has recently been …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Almost everyone has it - either physical or in their heads: a list of
things you want to do or achieve before you... well, stop existing. Mine
still has numerous things on it (I should get on it, I know) but one of
the items on that list has recently been removed: write and have a book
published. And the result is a book called &lt;a href="http://www.packtpub.com/selinux-system-administration/book"&gt;SELinux System
Administration&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Somewhere in the second quarter of this year, &lt;a href="http://www.packtpub.com/"&gt;Packt
Publishing&lt;/a&gt; contacted me to see if I am
interested in authoring a book about SELinux, focusing on the usage of
SELinux (you know - handling booleans, dealing with file contexts, etc.)
in a short technical book (the aim was 100 pages). Considering that I'm
almost always busy with documentation and editing (for instance, I
&lt;a href="http://www.gentoo.org/news/en/gwn/20031110-newsletter.xml#doc_chap2"&gt;joined
Gentoo&lt;/a&gt;
as documentation translator and editor beginning of 2003 if I remember
correctly) and am busy keeping SELinux support within Gentoo on a good
level, I of course said yes to the request.&lt;/p&gt;
&lt;p&gt;Now, 100 pages is not a lot for a topic as complex and diverse as
SELinux so was really challenging, but I do think I managed to get
everything in it while keeping it practical. The book first starts with
the fundamentals of SELinux - concepts you really need to grasp before
diving into SELinux. Then, it goes on about switching SELinux state
(disabling, permissive, granular permissive, etc.), logging, managing
SELinux users and roles, handling process domains, etc. Just take a look
at the table of contents and you'll see what I mean ;-)&lt;/p&gt;
&lt;p&gt;Inside the book, examples are given based on Fedora (and thus also
RedHat Enterprise Linux) and Gentoo Hardened while ensuring that there
are few distribution specific sections in it, making it usable for Linux
administrators of systems with a different Linux distribution installed
to it. Take a look at the &lt;a href="http://www.packtpub.com/sites/default/files/9781783283170_Chapter-03.pdf?utm_source=packtpub&amp;amp;utm_medium=free&amp;amp;utm_campaign=pdf"&gt;sample
chapter&lt;/a&gt;
and, if you like it, put it on your wish list and let everyone know ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="administration"></category><category term="book"></category><category term="fedora"></category><category term="Gentoo"></category><category term="packt"></category><category term="packtpub"></category><category term="selinux"></category><category term="system"></category></entry><entry><title>Network routing based on SELinux?</title><link href="https://blog.siphos.be/2013/08/network-routing-based-on-selinux/" rel="alternate"></link><published>2013-08-21T19:43:00+02:00</published><updated>2013-08-21T19:43:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-21:/2013/08/network-routing-based-on-selinux/</id><summary type="html">&lt;p&gt;Today we had a question on #selinux if it was possible to route traffic
of a specific process using SELinux. The answer to this is "no",
although it has to be explained a bit in more detail.&lt;/p&gt;
&lt;p&gt;SELinux does not route traffic. SELinux is a local mandatory access
control system …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today we had a question on #selinux if it was possible to route traffic
of a specific process using SELinux. The answer to this is "no",
although it has to be explained a bit in more detail.&lt;/p&gt;
&lt;p&gt;SELinux does not route traffic. SELinux is a local mandatory access
control system; its purpose is to allow or deny certain actions, not
route traffic. However, Linux' NetFilter does support security markings
(SECMARK). I've &lt;a href="http://blog.siphos.be/2013/05/secmark-and-selinux/"&gt;blogged about
it&lt;/a&gt; in the past, and
there are good tutorials elsewhere on the Internet, such as Dan Walsh'
&lt;a href="http://www.linux.com/learn/tutorials/421152-using-selinux-and-iptables-together"&gt;Using SELinux and iptables
together&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Linux support for security marking does allow for routing decisions -
but it does not "use" SELinux in this regard. To mark traffic with a
certain label, the administrator has to put in the rules himself using
&lt;strong&gt;iptables&lt;/strong&gt; or &lt;strong&gt;ip6tables&lt;/strong&gt; commands. And if you have to do that, then
you are already working with the routing commands so why not just route
immediately? Of course, the advantage of labeling the traffic is that
you can then use SELinux to allow or deny processes to send or receive
those packets - but SELinux is not involved with routing.&lt;/p&gt;
&lt;p&gt;Another possibility is to use labeled networking, such as Labeled IPSec
or NetLabel/CIPSO support.&lt;/p&gt;
&lt;p&gt;With labeled networking, all hosts that participate in the network need
to support the labeled networking technology. If that is the case, then
SELinux policy can be used to deny traffic from one host or another -
but again, not to route traffic. You can use SELinux to deny one process
to send out data to one set of hosts and allow it to send data to
another, but that is not routing. The advantage of Labeled IPSec is that
contexts are retained across the network - decisions that SELinux has to
take on one system can be made based on the context of the process on
the other system.&lt;/p&gt;
&lt;p&gt;So no, SELinux cannot be used to route traffic, but it plays very nicely
with various networking controls to make proper decisions on its access
control enforcement.&lt;/p&gt;</content><category term="SELinux"></category><category term="ipsec"></category><category term="netlabel"></category><category term="networking"></category><category term="secmark"></category><category term="selinux"></category></entry><entry><title>Some things sound more scary than they are</title><link href="https://blog.siphos.be/2013/08/some-things-sound-more-scary-than-they-are/" rel="alternate"></link><published>2013-08-15T10:02:00+02:00</published><updated>2013-08-15T10:02:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-15:/2013/08/some-things-sound-more-scary-than-they-are/</id><summary type="html">&lt;p&gt;A few days ago I finally got to the next thing on my &lt;em&gt;Want to do this
year&lt;/em&gt; list: put a new android
(&lt;a href="http://www.cyanogenmod.org/"&gt;Cyanogenmod&lt;/a&gt;) on my tablet, which was
still running the stock Android - but hasn't seen any updates in more
than a year. Considering the (in)security of Android …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few days ago I finally got to the next thing on my &lt;em&gt;Want to do this
year&lt;/em&gt; list: put a new android
(&lt;a href="http://www.cyanogenmod.org/"&gt;Cyanogenmod&lt;/a&gt;) on my tablet, which was
still running the stock Android - but hasn't seen any updates in more
than a year. Considering the (in)security of Android this was long
overdue for me. But the fear of getting an unbootable tablet ("bricked"
as it is often called) was keeping me from doing so.&lt;/p&gt;
&lt;p&gt;So when I finally got the nerves, I first had to run around screaming
for hours because the first step in the instructions didn't work. The
next day I read that it might have to do with the cable - and indeed,
tried with a different cable and the instructions just went along just
fine. So today I'm happily running with a more up-to-date Android again
on my tablet.&lt;/p&gt;
&lt;p&gt;Because my systems run Gentoo Hardened with SELinux, I did had to do
some small magic tricks to get the
&lt;a href="http://www.clockworkmod.com/"&gt;Clockworkmod&lt;/a&gt; recovery on the tablet: the
&lt;strong&gt;wheelie&lt;/strong&gt; binary (yes, I couldn't find the sources - if they are even
available) that I had to run required me to disable size overflow
detection in the kernel (a PaX countermeasure), allowed executable
memory (both through &lt;strong&gt;paxctl-ng&lt;/strong&gt; as well as in SELinux using the
&lt;code&gt;allow_execmem&lt;/code&gt; boolean) and had to temporarily add in the
&lt;code&gt;dev_rw_generic_usb_dev&lt;/code&gt; right (refpolicy macro) to my user.&lt;/p&gt;
&lt;p&gt;Also &lt;strong&gt;adb&lt;/strong&gt; had to be pax-marked, although I now know I don't need
&lt;strong&gt;adb&lt;/strong&gt; at all - I can just download the latest Android ZIP file from
the phone itself and refer to it from the recovery manager.&lt;/p&gt;
&lt;p&gt;All in all nothing to worry about - everything worked like a charm.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit:&lt;/em&gt; (so I remember next time), if the system is stuck in CMR
(recovery), reboot with VolDown+Pwr, but don't select recovery. After 5
seconds, it will ask if you want a cold boot. Select it, and things work
again ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="android"></category><category term="grsecurity"></category><category term="pax"></category><category term="selinux"></category><category term="tablet"></category></entry><entry><title>Rebuilding SELinux contexts with sefcontext_compile</title><link href="https://blog.siphos.be/2013/07/rebuilding-selinux-contexts-with-sefcontext_compile/" rel="alternate"></link><published>2013-07-08T20:55:00+02:00</published><updated>2013-07-08T20:55:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-07-08:/2013/07/rebuilding-selinux-contexts-with-sefcontext_compile/</id><summary type="html">&lt;p&gt;A recent update of &lt;em&gt;libpcre&lt;/em&gt; caused the binary precompiled regular
expression files of SELinux to become outdated (and even blatantly
wrong). The details are in bug &lt;a href="https://bugs.gentoo.org/471718"&gt;471718&lt;/a&gt;
but that doesn't help the users that are already facing the problem, nor
have we found a good place to put the fix …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A recent update of &lt;em&gt;libpcre&lt;/em&gt; caused the binary precompiled regular
expression files of SELinux to become outdated (and even blatantly
wrong). The details are in bug &lt;a href="https://bugs.gentoo.org/471718"&gt;471718&lt;/a&gt;
but that doesn't help the users that are already facing the problem, nor
have we found a good place to put the fix in.&lt;/p&gt;
&lt;p&gt;Anyway, if you are facing issues with SELinux labeling (having files
being labeled as &lt;em&gt;portage_tmp_t&lt;/em&gt; instead of the proper label), check
with &lt;strong&gt;matchpathcon&lt;/strong&gt; if the label is correct. If &lt;strong&gt;matchpathcon&lt;/strong&gt; sais
that the label should be &lt;code&gt;&amp;lt;&amp;lt;none&amp;gt;&amp;gt;&lt;/code&gt; then you need to rebuild the SELinux
context files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# cd /etc/selinux/strict/contexts/files
# for n in *.bin; do sefcontext_compile ${n%%.bin}; done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;sefcontext_compile&lt;/strong&gt; command will rebuild the SELinux context
files. When that has been done, &lt;strong&gt;matchpathcon&lt;/strong&gt; should show the right
context again, and Portage will relabel files correctly. Until then, you
will need to relabel the packages that have been built since (and
including) the &lt;em&gt;libpcre&lt;/em&gt; build.&lt;/p&gt;
&lt;p&gt;If someone has a good suggestion where to put these rebuilds in, please
do drop a note in the bug. Although the proper one might be &lt;em&gt;libpcre&lt;/em&gt;
itself, I'd rather not put too much SELinux logic in the ebuild unless
it is pretty safeguarded...&lt;/p&gt;
&lt;p&gt;In any case, it has also been documented in the &lt;a href="https://wiki.gentoo.org/wiki/SELinux/FAQ#File_labels_do_not_seem_to_be_set_anymore.2C_and_matchpathcon_sais_.3C.3Cnone.3E.3E"&gt;Gentoo SELinux
FAQ&lt;/a&gt;
on the Gentoo wiki.&lt;/p&gt;</content><category term="SELinux"></category><category term="hardened"></category><category term="pcre"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: finishing up</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-finishing-up/" rel="alternate"></link><published>2013-05-31T03:50:00+02:00</published><updated>2013-05-31T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-31:/2013/05/a-selinux-policy-for-incron-finishing-up/</id><summary type="html">&lt;p&gt;After 9 posts, it's time to wrap things up. You can review the final
results online
(&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.te.txt"&gt;incron.te&lt;/a&gt;,
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.if.txt"&gt;incron.if&lt;/a&gt; and
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.fc.txt"&gt;incron.fc&lt;/a&gt;) and
adapt to your own needs if you want. But we should also review what we
have accomplished so far...&lt;/p&gt;
&lt;p&gt;We built the start of an entire …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After 9 posts, it's time to wrap things up. You can review the final
results online
(&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.te.txt"&gt;incron.te&lt;/a&gt;,
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.if.txt"&gt;incron.if&lt;/a&gt; and
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.fc.txt"&gt;incron.fc&lt;/a&gt;) and
adapt to your own needs if you want. But we should also review what we
have accomplished so far...&lt;/p&gt;
&lt;p&gt;We built the start of an entire policy for a daemon (the inotify cron
daemon) for two main types: the daemon itself, and its management
application &lt;strong&gt;incrontab&lt;/strong&gt;. We defined new types and contexts, we used
attributes, declared a boolean and worked with interfaces. That's a lot
to digest, and yet it is only a part of the various capabilities that
SELinux offers.&lt;/p&gt;
&lt;p&gt;The policy isn't complete though. We defined a type called
&lt;code&gt;incron_initrc_exec_t&lt;/code&gt; but don't really use it further. In practice, we
would need to define an additional interface (probably named
&lt;em&gt;incron_admin&lt;/em&gt;) that allows users and roles to manage &lt;em&gt;incron&lt;/em&gt; without
needing to grant this user/role &lt;code&gt;sysadm_r&lt;/code&gt; privileges. I leave that up
to you as an exercise for now, but I'll post more about admin interfaces
and how to work with them on a system in the near future.&lt;/p&gt;
&lt;p&gt;We also made a few assumptions and decisions while building the policy
that might not be how you yourself would want to build the policy.
SELinux is a MAC system, but the policy language is very flexible. You
can use an entirely different approach in policies if you want. For
instance, &lt;em&gt;incron&lt;/em&gt; supports launching the &lt;strong&gt;incrond&lt;/strong&gt; as a command-line,
foreground process. This could help users run &lt;strong&gt;incrond&lt;/strong&gt; under their
privileges for their own files - we did not consider this case in our
design. Although most policies try to capture all use cases of an
application, there will be cases when a policy developer did either not
consider the use case or found that it infringed with his own principles
on policy development (and allowed activities on a system).&lt;/p&gt;
&lt;p&gt;In Gentoo Hardened, I try to write down the principles and policies that
we follow in a &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-policy.xml"&gt;Gentoo Hardened SELinux Development
Policy&lt;/a&gt;
document. As decisions need to be taken, such a document might help find
common consensus on how to approach SELinux policy development further,
and I seriously recommend that you consider writing up a similar
document yourself, especially if you are going to develop policies for a
larger organization.&lt;/p&gt;
&lt;p&gt;One of the deficiencies of the current policy is that it worked with the
unmodified &lt;em&gt;incron&lt;/em&gt; version. If we would patch &lt;em&gt;incron&lt;/em&gt; so that it could
change context on executing the incrontab files of a user, then we can
start making use of the default context approach (and perhaps even
enhance with PAM services). In that case, user incrontabs could be
launched entirely from the users' context (like &lt;code&gt;user_u:user_r:user_t&lt;/code&gt;)
instead of the &lt;code&gt;system_u:system_r:incrond_t&lt;/code&gt; or transitioned
&lt;code&gt;system_u:system_r:whatever_t&lt;/code&gt; contexts. Having user provided commands
executed in the system context is a security risk, so in our policy we
would &lt;em&gt;not&lt;/em&gt; grant the &lt;em&gt;incron_role&lt;/em&gt; to untrusted users - probably only
to &lt;code&gt;sysadm_t&lt;/code&gt; and even then he probably would be better with using the
&lt;code&gt;/etc/incron.d&lt;/code&gt; anyway.&lt;/p&gt;
&lt;p&gt;The downside of patching code however is that this is only viable if
upstream wants to support this - otherwise we would need to maintain the
patches ourselves for a long time, creating delays in releases (upstream
released a new version and we still need to reapply and refactor
patches) and removing precious (human) resources from other, Gentoo
Hardened/SELinux specific tasks (like bugfixing and documentation
writing ;-)&lt;/p&gt;
&lt;p&gt;Still, the policy returned a fairly good view on how policies &lt;em&gt;can&lt;/em&gt; be
developed. And as I said, there are still other things that weren't
discussed, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build-time decisions, which can change policies based on build
    options of the policy. In the reference policy, this is most often
    used for distribution-specific choices: if Gentoo would use one
    approach and Redhat another, then the differences would be separated
    through &lt;code&gt;ifdef(`distro_gentoo',`...')&lt;/code&gt; and
    &lt;code&gt;ifdef(`distro_redhat',`...')&lt;/code&gt; calls.&lt;/li&gt;
&lt;li&gt;Some calls might only be needed if another policy is loaded. I think
    all calls made currently are part of base modules, so can be
    expected to be available at all times. But if we would need
    something like &lt;em&gt;icecast_signal(incrond_t)&lt;/em&gt;, then we would need to
    put that call inside a &lt;code&gt;optional_policy(`...')&lt;/code&gt; statement.
    Otherwise, our policy would fail to load because the &lt;em&gt;icecast&lt;/em&gt;
    SELinux policy isn't loaded.&lt;/li&gt;
&lt;li&gt;We could even introduce specific statements like &lt;em&gt;dontaudit&lt;/em&gt; or
    &lt;em&gt;neverallow&lt;/em&gt; to fine-tune the policy. Note though that &lt;em&gt;neverallow&lt;/em&gt;
    is a compile-time statement: it is not a way to negate &lt;em&gt;allow&lt;/em&gt;
    rules: if there is one &lt;em&gt;allow&lt;/em&gt; that would violate the &lt;em&gt;neverallow&lt;/em&gt;,
    then that module just refuses to build.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Furthermore, if you want to create policies to be pushed upstream to the
reference policy project, you will need to look into the
&lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide"&gt;StyleGuide&lt;/a&gt;
and
&lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming"&gt;InterfaceNaming&lt;/a&gt;
documents as those define the order that rules should be placed and the
name syntax for interfaces. I have been contributing a lot to the
reference policy and I still miss a few of these, so for me they are not
that obvious. But using a common style is important as it allows for
simple patching, code comparison and even allows us to easily read
through complex policies.&lt;/p&gt;
&lt;p&gt;If you don't want to contribute it, but still use it on your Gentoo
system, you can use a simple ebuild to install the files. Create an
ebuild (for instance &lt;code&gt;selinux-incron&lt;/code&gt;), put the three files in the
&lt;code&gt;files/&lt;/code&gt; subdirectory, and use the following ebuild code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Copyright 1999-2013 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header$
EAPI=&amp;quot;4&amp;quot;

IUSE=&amp;quot;&amp;quot;
MODS=&amp;quot;incron&amp;quot;
BASEPOL=&amp;quot;2.20130424-r1&amp;quot;
POLICY_FILES=&amp;quot;incron.te incron.fc incron.if&amp;quot;

inherit selinux-policy-2

DESCRIPTION=&amp;quot;SELinux policy for incron, the inotify cron daemon&amp;quot;

KEYWORDS=&amp;quot;~amd64 ~x86&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When installed, the interface files will be published as well and can
then be used by other modules (something we couldn't do in the past few
posts) or by the &lt;strong&gt;selocal&lt;/strong&gt; tool.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: using booleans</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-using-booleans/" rel="alternate"></link><published>2013-05-30T03:50:00+02:00</published><updated>2013-05-30T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-30:/2013/05/a-selinux-policy-for-incron-using-booleans/</id><summary type="html">&lt;p&gt;After using a default set of directories to watch, and &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/"&gt;allowing admins
to mark other
types&lt;/a&gt;
as such as well, let's consider another approach for making the policy
more flexible: booleans. The idea now is that a boolean called
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; enables &lt;strong&gt;incrond&lt;/strong&gt; to be
notified on changes on all possible …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After using a default set of directories to watch, and &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/"&gt;allowing admins
to mark other
types&lt;/a&gt;
as such as well, let's consider another approach for making the policy
more flexible: booleans. The idea now is that a boolean called
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; enables &lt;strong&gt;incrond&lt;/strong&gt; to be
notified on changes on all possible non-security related files (the
latter is merely an approach, you can define other sets as well if you
want, including all possible files).&lt;/p&gt;
&lt;p&gt;Booleans in SELinux policy can be generated in the &lt;code&gt;incron.te&lt;/code&gt; file as
follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## &amp;lt;desc&amp;gt;
## &amp;lt;p&amp;gt;
##      Determine whether incron can watch all non-security
##      file types
## &amp;lt;/p&amp;gt;
## &amp;lt;/desc&amp;gt;
gen_tunable(incron_notify_non_security_files, false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this boolean in place, the policy can be enhanced with code like
the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tunable_policy(`incron_notify_non_security_files&amp;#39;,`
        files_read_non_security_files(incrond_t)
        files_read_all_dirs_except(incrond_t)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This code tells SELinux that, &lt;em&gt;if&lt;/em&gt; the
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; boolean is set (which by default
is not the case), then &lt;code&gt;incrond_t&lt;/code&gt; is able to read non security files.&lt;/p&gt;
&lt;p&gt;Let's try to watch for changes in the AIDE log directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail audit.log
type=AVC msg=audit(1368777675.597:28611): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;log&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=13 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_log_t tclass=dir
type=AVC msg=audit(1368777675.597:28612): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;log&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=13 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_log_t tclass=dir

# tail cron.log
May 17 10:01:15 test incrond[11704]: access denied on /var/log/aide - events will be discarded silently

# getsebool incron_notify_non_security_files
incron_notify_non_security_files --&amp;gt; off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's enable the boolean and try again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# setsebool incron_notify_non_security_files on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Reloading the incrontab tables now works, and the notifications work as
well.&lt;/p&gt;
&lt;p&gt;As you can see, once a policy is somewhat working, policy developers are
considering the various "use cases" of an application, trying to write
down policies that can be used by the majority of users, without
granting too many rights automatically.&lt;/p&gt;</content><category term="SELinux"></category><category term="boolean"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: marking types eligible for watching</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/" rel="alternate"></link><published>2013-05-29T03:50:00+02:00</published><updated>2013-05-29T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-29:/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/</id><summary type="html">&lt;p&gt;In the
&lt;a herf="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/"&gt;previous
post&lt;/a&gt; we made &lt;strong&gt;incrond&lt;/strong&gt; able to watch &lt;code&gt;public_content_t&lt;/code&gt; and
&lt;code&gt;public_content_rw_t&lt;/code&gt; types. However, this is not scalable, so we might
want to be able to update the policy more dynamically with additional
types. To accomplish this, we will make types eligible for watching
through an attribute.&lt;/p&gt;
&lt;p&gt;So how …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the
&lt;a herf="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/"&gt;previous
post&lt;/a&gt; we made &lt;strong&gt;incrond&lt;/strong&gt; able to watch &lt;code&gt;public_content_t&lt;/code&gt; and
&lt;code&gt;public_content_rw_t&lt;/code&gt; types. However, this is not scalable, so we might
want to be able to update the policy more dynamically with additional
types. To accomplish this, we will make types eligible for watching
through an attribute.&lt;/p&gt;
&lt;p&gt;So how does this work? First, we create an attribute called
&lt;code&gt;incron_notify_type&lt;/code&gt; (we can choose the name we want of course) and
grant &lt;code&gt;incrond_t&lt;/code&gt; the proper rights on all types that have been assigned
the &lt;code&gt;incron_notify_type&lt;/code&gt; attribute. Then, we create an interface that
other modules (or admins) can use to mark specific types eligible for
watching, called &lt;em&gt;incron_notify_file&lt;/em&gt;. This interface will assign the
&lt;code&gt;incron_notify_type&lt;/code&gt; attribute to the provided type.&lt;/p&gt;
&lt;p&gt;First, the attribute and its associated privileges:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;attribute incron_notify_type;
...
allow incrond_t incron_notify_type:dir list_dir_perms;
allow incrond_t incron_notify_type:file read_file_perms;
allow incrond_t incron_notify_type:lnk_file read_lnk_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it. For now, this won't do much as there are no types associated
with the &lt;code&gt;incron_notify_type&lt;/code&gt; attribute, so let's change that by
introducing the interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;########################################
## &amp;lt;summary&amp;gt;
##      Make the specified type a file or directory
##      that incrond can watch on.
## &amp;lt;/summary&amp;gt;
## &amp;lt;param name=&amp;quot;file_type&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      Type of the file to be allowed to watch
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
#
interface(`incron_notify_file&amp;#39;,`
        gen_require(`
                attribute incron_notify_type;
        &amp;#39;)

        typeattribute $1 incron_notify_type;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it! If you want &lt;strong&gt;incrond&lt;/strong&gt; to watch user content, one can now do
something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;incron_notify_file(home_root_t)
incron_notify_file(user_home_dir_t)
incron_notify_file(user_home_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Moreover, we can now also easily check what additional types have been
marked as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seinfo -aincron_notify_type -x
   incron_notify_type
      user_home_dir_t
      user_home_t
      home_root_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This attribute approach is commonly used for such setups and is becoming
more and more a "standard" approach.&lt;/p&gt;
&lt;p&gt;In the next post, we'll cover a boolean-triggered approach where
&lt;strong&gt;incrond&lt;/strong&gt; will be eligible for watching all (non-security) content.&lt;/p&gt;</content><category term="SELinux"></category><category term="attribute"></category><category term="incrond"></category><category term="selinux"></category><category term="watch"></category></entry><entry><title>A SELinux policy for incron: default set</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/" rel="alternate"></link><published>2013-05-28T03:50:00+02:00</published><updated>2013-05-28T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-28:/2013/05/a-selinux-policy-for-incron-default-set/</id><summary type="html">&lt;p&gt;I finished the last post a bit with a
&lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/"&gt;cliffhanger&lt;/a&gt;
as &lt;strong&gt;incrond&lt;/strong&gt; is still not working properly, and we got a few denials
that needed to be resolved; here they are again for your convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I finished the last post a bit with a
&lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/"&gt;cliffhanger&lt;/a&gt;
as &lt;strong&gt;incrond&lt;/strong&gt; is still not working properly, and we got a few denials
that needed to be resolved; here they are again for your convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/home/user/test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
type=AVC msg=audit(1368734110.913:28354): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The permission we are looking for here is
&lt;em&gt;userdom_list_user_home_content&lt;/em&gt;, but this is only for when we want
to watch a user home directory. What if we want to watch a server upload
directory? Or a cache directory? We might need to have &lt;strong&gt;incrond&lt;/strong&gt; have
the proper accesses on all directories. But then again, &lt;em&gt;all&lt;/em&gt; does sound
a bit... much, doesn't it? So let's split it up in three waves:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;incrond_t&lt;/code&gt; domain will support a minimal set of types that it
    can watch, based on common approaches&lt;/li&gt;
&lt;li&gt;I will introduce an interface that allows other modules to mark
    specific types as being "watch-worthy"&lt;/li&gt;
&lt;li&gt;A boolean will be set to allow &lt;code&gt;incrond_t&lt;/code&gt; to watch a very large set
    of types (just in case the admin trusts it sufficiently)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's first consider a decent minimal set. Within most SELinux policies,
two types are often used for public access (or for uploading of data).
These types are &lt;code&gt;public_content_t&lt;/code&gt; and &lt;code&gt;public_content_rw_t&lt;/code&gt;, and is
used for instance for FTP definitions (upload folders), HTTP servers and
such. So we introduce the proper rights to watch that data. There is an
interface available called &lt;em&gt;miscfiles_read_public_files&lt;/em&gt; but let's
first see if that interface isn't too broad (after all, watching might
not be the same as reading).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# This is only to temporarily check if the rights of the interface are too broad or not
# You can set this using &amp;quot;selocal&amp;quot; or in a module (in which case you&amp;#39;ll need to &amp;#39;require&amp;#39;
# the two types)
allow incrond_t public_content_t:dir { read getattr };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After editing the incrontab to watch a directory labeled with
&lt;code&gt;public_content_t&lt;/code&gt;, we now get the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 08:46:12 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 08:46:12 test incrond[11281]: cannot exec process: Operation not permitted
May 17 08:46:12 test incrond[9716]: cannot send SIGCHLD token to notification pipe

# tail audit.log
type=AVC msg=audit(1368773172.313:28386): avc:  denied  { setgid } for  pid=11281 comm=&amp;quot;incrond&amp;quot; capability=6  scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=capability
type=AVC msg=audit(1368773172.314:28387): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;pipe:[14027]&amp;quot; dev=&amp;quot;pipefs&amp;quot; ino=14027 scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=fifo_file
type=AVC msg=audit(1368773172.315:28388): avc:  denied  { write } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;pipe:[14027]&amp;quot; dev=&amp;quot;pipefs&amp;quot; ino=14027 scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=fifo_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As the incrontab is a user incrontab, we can expect &lt;code&gt;incrond_t&lt;/code&gt; to
require setuid and setgid privileges. Also, the &lt;em&gt;fifo_file&lt;/em&gt; access is
after forking (notice the difference in PID values) and most likely to
communicate to the master process. So let's allow those:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t self:capability { setuid setgid };
allow incrond_t self:fifo_file { read write };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that set, we get the following upon triggering a file write:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 08:52:46 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 08:52:46 test incrond[11338]: cannot exec process: Permission denied

# tail audit.log
type=AVC msg=audit(1368773566.606:28394): avc:  denied  { read } for  pid=11338 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;ngroups_max&amp;quot; dev=&amp;quot;proc&amp;quot; ino=5711 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:sysctl_kernel_t tclass=file
type=AVC msg=audit(1368773566.607:28395): avc:  denied  { search } for  pid=11338 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;bin&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=1048578 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:bin_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;ngroups_max&lt;/code&gt; pseudo-file (in &lt;code&gt;/proc/sys/kernel&lt;/code&gt;) returns the
maximum number of supplementary group IDs per process, and is consulted
through the &lt;em&gt;initgroups()&lt;/em&gt; method provided by a system library, so it
&lt;em&gt;might&lt;/em&gt; make sense to allow it. For now though, I will not enable it (as
reading &lt;code&gt;sysctl_kernel_t&lt;/code&gt; exposes a lot of other system information) but
I might be forced to do so later if things don't work out well. The
&lt;em&gt;search&lt;/em&gt; privilege on &lt;code&gt;bin_t&lt;/code&gt; is needed to find the script that I have
prepared (&lt;code&gt;/usr/local/bin/test&lt;/code&gt;) to be executed, so I add in a
&lt;em&gt;corecmd_search_bin&lt;/em&gt; and retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 09:02:55 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 09:02:55 test incrond[11427]: cannot exec process: Permission denied

# tail audit.log
type=AVC msg=audit(1368774175.646:28441): avc:  denied  { read } for  pid=11427 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;sh&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=131454 scontext=system_u:system_r:incrond_t tcontext=root:object_r:bin_t tclass=lnk_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Still not there yet apparently. The &lt;strong&gt;incrond&lt;/strong&gt; forked process wants to
execute the script, but to do so it has to follow a symbolic link
labeled &lt;code&gt;bin_t&lt;/code&gt;. This is because the script points to &lt;code&gt;#!/bin/sh&lt;/code&gt; which
is a symlink to the system shell. We need to follow this link before the
execution can occur; only after execution will the transition from
&lt;code&gt;incrond_t&lt;/code&gt; to &lt;code&gt;system_cronjob_t&lt;/code&gt; be done.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corecmd_read_bin_symlinks(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that set in the policy, the watch works, &lt;strong&gt;incrond&lt;/strong&gt; properly
launches the command and the command properly transitions into
&lt;code&gt;system_cronjob_t&lt;/code&gt; as we defined earlier (I check this by echo'ing the
output of &lt;strong&gt;id -Z&lt;/strong&gt; into a temporary file).&lt;/p&gt;
&lt;p&gt;So we are left with the (temporary) rights we granted on
&lt;code&gt;public_content_t&lt;/code&gt;. Consider the rules we had versus the rules applied
with &lt;em&gt;miscfiles_read_public_files&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t public_content_t:dir { read getattr };

# miscfiles_read_public_files
allow $1 { public_content_t public_content_rw_t }:dir list_dir_perms;
read_files_pattern($1, { public_content_t public_content_rw_t }, { public_content_t public_content_rw_t })
read_lnk_files_pattern($1, { public_content_t public_content_rw_t }, { public_content_t public_content_rw_t })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The rights here seem to bemore than what we need. Playing around a bit
with the directories reveals that &lt;strong&gt;incrond&lt;/strong&gt; requires a bit more. For
instance, when you create additional directories (subdirectories) and
want to match multiple ones:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 09:16:08 test incrond[11704]: access denied on /var/www/test/* - events will be discarded silently
May 17 09:16:08 test incrond[11704]: cannot create watch for user user: (13) Permission denied

# tail audit.log
type=AVC msg=audit(1368774968.416:28504): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1488 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=dir
type=AVC msg=audit(1368774968.416:28505): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1488 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Similarly if you want to watch on a particular file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368775274.655:28552): avc:  denied  { getattr } for  pid=11704 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/var/www/test/testfile&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1709 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=file
type=AVC msg=audit(1368775274.655:28553): avc:  denied  { read } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;testfile&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1709 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So it looks like &lt;em&gt;miscfiles_read_public_files&lt;/em&gt; isn't that bad after
all.&lt;/p&gt;
&lt;p&gt;All we are left with is the access to &lt;code&gt;ngroups_max&lt;/code&gt;. We can ignore the
calls and make sure they don't show up in standard auditing using
&lt;em&gt;kernel_dontaudit_read_kernel_sysctls&lt;/em&gt; or we can allow it with
&lt;em&gt;kernel_read_kernel_sysctls&lt;/em&gt;. I'm going to take the former approach
for my system, but your own idea might be different.&lt;/p&gt;
&lt;p&gt;I tested all this with user incrontabs (as those are the "most"
advanced) but one can easily test with system incrontabs as well
(placing one in &lt;code&gt;/etc/incron.d&lt;/code&gt;). Just be aware that &lt;em&gt;incrond&lt;/em&gt; will take
the first match and will not seek other matches. So if a system
incrontab watches &lt;code&gt;/var/www&lt;/code&gt; and another line (or user incrontab)
watches &lt;code&gt;/var/www/localhost/upload&lt;/code&gt; it is very well possible that only
the &lt;code&gt;/var/www&lt;/code&gt; watch is triggered.&lt;/p&gt;
&lt;p&gt;So right now, our &lt;code&gt;incrond_t&lt;/code&gt; policy looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrond policy
#

allow incrond_t self:capability { setgid setuid };

allow incrond_t incron_spool_t:dir list_dir_perms;
allow incrond_t incron_spool_t:file read_file_perms;

allow incrond_t self:fifo_file { read write };

allow incrond_t incrond_var_run_t:file manage_file_perms;
files_pid_filetrans(incrond_t, incrond_var_run_t, file)

kernel_dontaudit_read_kernel_sysctls(incrond_t)

corecmd_read_bin_symlinks(incrond_t)
corecmd_search_bin(incrond_t)

files_search_spool(incrond_t)

logging_send_syslog_msg(incrond_t)

auth_use_nsswitch(incrond_t)

miscfiles_read_localization(incrond_t)
miscfiles_read_public_files(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next on the agenda is another interface to make other types
"watch-worthy".&lt;/p&gt;</content><category term="SELinux"></category><category term="booleans"></category><category term="incrond"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: the incrond daemon</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/" rel="alternate"></link><published>2013-05-27T03:50:00+02:00</published><updated>2013-05-27T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-27:/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/</id><summary type="html">&lt;p&gt;With &lt;code&gt;incrontab_t&lt;/code&gt; (hopefully) complete, let's look at the &lt;code&gt;incrond_t&lt;/code&gt;
domain. As this domain will also be used to execute the user (and
system) commands provided through the incrontabs, we need to consider
how we are going to deal with this wide range of possible permissions
that it might take. One …&lt;/p&gt;</summary><content type="html">&lt;p&gt;With &lt;code&gt;incrontab_t&lt;/code&gt; (hopefully) complete, let's look at the &lt;code&gt;incrond_t&lt;/code&gt;
domain. As this domain will also be used to execute the user (and
system) commands provided through the incrontabs, we need to consider
how we are going to deal with this wide range of possible permissions
that it might take. One would be to make &lt;code&gt;incrond_t&lt;/code&gt; quite powerful, and
extend its privileges as we go further. But in my opinion, that's not a
good way to deal with it.&lt;/p&gt;
&lt;p&gt;Another would be to support a small set of permissions, and introduce an
interface that other modules can use to create a transition when
&lt;code&gt;incrond_t&lt;/code&gt; executes a script properly labeled for a transition. For
instance, a domain &lt;code&gt;foo_t&lt;/code&gt; might have an executable type &lt;code&gt;foo_exec_t&lt;/code&gt;.
Most modules support an interface similar to &lt;em&gt;foo_domtrans&lt;/em&gt; (and
&lt;em&gt;foo_role&lt;/em&gt; if roles are applicable as well), but that assumes that the
&lt;em&gt;incron&lt;/em&gt; policy is modified every time a new target module is made
available (since we then need to add the proper &lt;em&gt;*_domtrans&lt;/em&gt; rules to
the &lt;em&gt;incron&lt;/em&gt; policy. Instead, we might want to make this something that
the &lt;em&gt;foo&lt;/em&gt; SELinux module can decide.&lt;/p&gt;
&lt;p&gt;It is that approach that we are going to take here. To do so, we will
create a new interface called &lt;em&gt;incron_entry&lt;/em&gt;, taken a bit from the
&lt;em&gt;cron_system_entry&lt;/em&gt; interface already in place for the regular &lt;em&gt;cron&lt;/em&gt;
domain (the following comes in &lt;code&gt;incron.if&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## &amp;lt;summary&amp;gt;
##      Make the specified program domain
##      accessible from the incrond job.
## &amp;lt;/summary&amp;gt;
## &amp;lt;param name=&amp;quot;domain&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      The type of the process to transition to
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
## &amp;lt;param name=&amp;quot;entrypoint&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      The type of the file used as an entrypoint to this domain
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
#
interface(`incron_entry&amp;#39;,`
        gen_require(`
                type incrond_t;
        &amp;#39;)

        domtrans_pattern(incrond_t, $2, $1)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this in place, the &lt;em&gt;foo&lt;/em&gt; SELinux module can call
&lt;em&gt;incron_entry(foo_t, foo_exec_t)&lt;/em&gt; so that, the moment &lt;code&gt;incrond_t&lt;/code&gt;
executes a file with label &lt;code&gt;foo_exec_t&lt;/code&gt;, the resulting process will run
in &lt;code&gt;foo_t&lt;/code&gt;. I am going to &lt;em&gt;test&lt;/em&gt; (and I stress that it is only for
&lt;em&gt;testing&lt;/em&gt;) this by assigning &lt;em&gt;incron_entry(system_cronjob_t,
shell_exec_t)&lt;/em&gt;, making every shell script being called run in
&lt;code&gt;system_cronjob_t&lt;/code&gt; domain (for instance in the &lt;code&gt;localuser.te&lt;/code&gt; file that
already assigned &lt;em&gt;incron_role&lt;/em&gt; to the &lt;code&gt;user_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;With that in place, it's time to start our iterations again.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# run_init rc-service incrond start
* start-stop-daemon: failed to start &amp;#39;/usr/sbin/incrond&amp;#39; [ !! ]
* ERROR: incrond failed to start

# tail audit.log
type=AVC msg=audit(1368732494.275:28319): avc:  denied  { read } for  pid=9282 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;localtime&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393663 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:locale_t tclass=file
type=AVC msg=audit(1368732494.275:28320): avc:  denied  { create } for  pid=9282 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732494.276:28321): avc:  denied  { read } for  pid=9282 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;incron.d&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394140 scontext=system_u:system_r:incrond_t tcontext=root:object_r:incron_spool_t tclass=dir
type=AVC msg=audit(1368732494.276:28322): avc:  denied  { create } for  pid=9282 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732494.276:28323): avc:  denied  { create } for  pid=9282 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ignoring the &lt;em&gt;unix_dgram_socket&lt;/em&gt; for now, we need to allow &lt;code&gt;incrond_t&lt;/code&gt;
to read locale information, and to read the files in the
&lt;code&gt;/var/spool/incron&lt;/code&gt; location (this goes in &lt;code&gt;incron.te&lt;/code&gt; again):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrond policy
#

read_files_pattern(incrond_t, incron_spool_t, incron_spool_t)

files_search_spool(incrond_t)

miscfiles_read_localization(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The next run fails again, with the following denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368732806.757:28328): avc:  denied  { create } for  pid=9419 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732806.757:28329): avc:  denied  { read } for  pid=9419 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;incron.d&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394140 scontext=system_u:system_r:incrond_t tcontext=root:object_r:incron_spool_t tclass=dir
type=AVC msg=audit(1368732806.757:28330): avc:  denied  { create } for  pid=9419 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732806.757:28331): avc:  denied  { create } for  pid=9419 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So although &lt;code&gt;incrond_t&lt;/code&gt; has search rights on the &lt;code&gt;incron_spool_t&lt;/code&gt;
directories (through the &lt;code&gt;read_files_pattern&lt;/code&gt;), we need to grant it
&lt;em&gt;list_dir_perms&lt;/em&gt; as well (which contains the &lt;em&gt;read&lt;/em&gt; permission). As
&lt;em&gt;list_dir_perms&lt;/em&gt; contains search anyhow, we can just update the line
with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t incron_spool_t:dir list_dir_perms;
allow incrond_t incron_spool_t:file read_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the startup seems to work, but we still get denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# run_init rc-service incrond start
* Starting incrond... [ ok ]

# ps -eZ | grep incrond
# tail /var/log/cron.log
(nothing)

# tail audit.log
type=AVC msg=audit(1368733443.799:28340): avc:  denied  { create } for  pid=9551 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368733443.802:28341): avc:  denied  { write } for  pid=9552 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=1970 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_run_t tclass=dir
type=AVC msg=audit(1368733443.806:28342): avc:  denied  { create } for  pid=9552 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368733443.806:28343): avc:  denied  { create } for  pid=9552 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Those &lt;em&gt;unix_dgram_sockets&lt;/em&gt; are here again. But seeing that &lt;code&gt;cron.log&lt;/code&gt;
is empty, and &lt;em&gt;logging_send_syslog_msg&lt;/em&gt; is one of the interfaces that
would enable it, we might want to do just that so that we get more
information about why &lt;strong&gt;incrond&lt;/strong&gt; doesn't properly start. Also, it tries
to write into &lt;code&gt;var_run_t&lt;/code&gt; labeled directories, probably for its PID
file, so add in a proper file transition as well as manage rights:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type incrond_var_run_t;
files_pid_file(incrond_var_run_t)
...
allow incrond_t incrond_var_run_t:file manage_file_perms;
files_pid_filetrans(incrond_t, incrond_var_run_t, file)
...
logging_send_syslog_msg(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that in place:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# run_init rc-service incrond start
* Starting incrond... [ ok ]

# ps -eZ | grep incron
system_u:system_r:incrond_t      9648 ?        00:00:00 incrond

# tail /var/log/cron.log 
May 16 21:51:34 test incrond[9647]: starting service (version 0.5.10, built on May 16 2013 12:11:29)
May 16 21:51:34 test incrond[9648]: loading system tables
May 16 21:51:34 test incrond[9648]: loading user tables
May 16 21:51:34 test incrond[9648]: table for invalid user user found (ignored)
May 16 21:51:34 test incrond[9648]: ready to process filesystem events

# tail audit.log
type=AVC msg=audit(1368733894.641:28347): avc:  denied  { read } for  pid=9648 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;nsswitch.conf&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393768 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:etc_t tclass=file
type=AVC msg=audit(1368733894.645:28349): avc:  denied  { read } for  pid=9648 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;passwd&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394223 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:etc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It looks like we're getting there. Similar as with &lt;strong&gt;incrontab&lt;/strong&gt; we
allow &lt;em&gt;auth_use_nsswitch&lt;/em&gt; as well, and then get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 16 21:55:10 test incrond[9715]: starting service (version 0.5.10, built on May 16 2013 12:11:29)
May 16 21:55:10 test incrond[9716]: loading system tables
May 16 21:55:10 test incrond[9716]: loading user tables
May 16 21:55:10 test incrond[9716]: loading table for user user
May 16 21:55:10 test incrond[9716]: access denied on /home/user/test2 - events will be discarded silently
May 16 21:55:10 test incrond[9716]: cannot create watch for user user: (13) Permission denied
May 16 21:55:10 test incrond[9716]: ready to process filesystem events

# tail audit.log
type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/home/user/test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
type=AVC msg=audit(1368734110.913:28354): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What happens is that &lt;strong&gt;incrond&lt;/strong&gt; read the (user) crontab, found that it
had to "watch" &lt;code&gt;/home/user/test2&lt;/code&gt; but fails because SELinux doesn't
allow it to do so. We could just allow that, but we might do it a bit
better by looking into what we want it to do in a flexible manner...
next time ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="incrond"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: new types and transitions</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-new-types-and-transitions/" rel="alternate"></link><published>2013-05-26T03:50:00+02:00</published><updated>2013-05-26T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-26:/2013/05/a-selinux-policy-for-incron-new-types-and-transitions/</id><summary type="html">&lt;p&gt;So I've shown the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/"&gt;iterative approach
used&lt;/a&gt;
to develop policies. Again, please be aware that this is my way of
developing policies, other policy developers might have a different
approach. We were working on the &lt;strong&gt;incrontab&lt;/strong&gt; command, so let's
continue with trying to create a new user incrontab:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;So I've shown the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/"&gt;iterative approach
used&lt;/a&gt;
to develop policies. Again, please be aware that this is my way of
developing policies, other policy developers might have a different
approach. We were working on the &lt;strong&gt;incrontab&lt;/strong&gt; command, so let's
continue with trying to create a new user incrontab:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
cannot create temporary file: Permission denied

# tail audit.log
type=AVC msg=audit(1368709633.285:28211): avc:  denied  { setgid } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; capability=6  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368709633.285:28212): avc:  denied  { setuid } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; capability=7  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368709633.287:28213): avc:  denied  { search } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=3927 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:tmp_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The requests for the setuid and setgid capabilities are needed for the
application to safely handle the user incrontabs. Note that SELinux does
not "remove" the setuid bit on the binary itself, but does govern the
related capabilities. Since this is required, we will add these
capabilities to the policy. We also notice that &lt;strong&gt;incrontab&lt;/strong&gt; searched
in the &lt;code&gt;/tmp&lt;/code&gt; location.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t self:capability { setuid setgid };
...
files_search_tmp(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the next round of iteration, we notice the same error message with
the following denial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368728433.521:28215): avc:  denied  { write } for  pid=8913 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=3927 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:tmp_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It is safe to assume here that the process wants to create a temporary
file (if it is a directory, we will find out later and can adapt). But
when temporary files are created, we better make those files a specific
type, like &lt;code&gt;incrontab_tmp_t&lt;/code&gt;. So we define that on top of the policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type incrontab_tmp_t;
files_tmp_file(incrontab_tmp_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Also, we need to allow the &lt;code&gt;incrontab_t&lt;/code&gt; domain write privileges into
the &lt;code&gt;tmp_t&lt;/code&gt; labeled directory, but with an automatic file transition
towards &lt;code&gt;incrontab_tmp_t&lt;/code&gt; for every file written. This is done through
the &lt;em&gt;files_tmp_filetrans&lt;/em&gt; method:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;files_tmp_filetrans(incrontab_t, incrontab_tmp_t, file)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What this sais is that, if a domain &lt;code&gt;incrontab_t&lt;/code&gt; wants to create a
&lt;code&gt;file&lt;/code&gt; inside &lt;code&gt;tmp_t&lt;/code&gt;, then this file is automatically labeled
&lt;code&gt;incrontab_tmp_t&lt;/code&gt;. With SELinux, you can make this more precise: if you
know what the file name would be, then you can add that as a fourth
argument. However, this does not seem necessary now since we definitely
want all files created in &lt;code&gt;tmp_t&lt;/code&gt; to become &lt;code&gt;incrontab_tmp_t&lt;/code&gt;. All that
rests us is to allow &lt;strong&gt;incrontab&lt;/strong&gt; to actually manage those files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t incrontab_tmp_t:file manage_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With those in place, let's look at the outcome:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
editor finished with error: No such file or directory

# tail audit.log
type=AVC msg=audit(1368729268.465:28217): avc:  denied  { search } for  pid=8981 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;bin&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=524289 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:bin_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Considering that here, &lt;strong&gt;incrontab&lt;/strong&gt; is going to launch the users
&lt;code&gt;$EDITOR&lt;/code&gt; application to allow him (or her) to create an incrontab, we
need to allow &lt;code&gt;incrontab_t&lt;/code&gt; not only search privileges inside &lt;code&gt;bin_t&lt;/code&gt;
directories, but also execute rights:
&lt;em&gt;corecmd_exec_bin(incrontab_t)&lt;/em&gt;. We choose here to execute the editor
inside the existing domain (&lt;code&gt;incrontab_t&lt;/code&gt;) instead of creating a
different domain for the editor for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If we would create a separate domain for the editor, the editor
    would eventually need to have major permissions, depending on when
    it is used. Editors can be used to modify the sudoers files, passwd
    files, the &lt;code&gt;/etc/selinux/config&lt;/code&gt; file, etc. Instead, it makes much
    more sense to just be able to launch the editor in the current
    domain (which is much more confined to its specific purpose)&lt;/li&gt;
&lt;li&gt;The additional privileges needed to launch the editor are usually
    very slim, or even nonexistent. It generally only makes sense if, by
    executing it, the existing domain would need many more privileges,
    because then a new (confined) domain keeps the privileges for the
    current domain low.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's see if things work now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
(Editor opened, so I added in an incrontab line. Upon closing:)
cannot move temporary table: Permission denied

# tail audit.log
type=AVC msg=audit(1368729825.673:28237): avc:  denied  { dac_read_search } for  pid=9030 comm=&amp;quot;incrontab&amp;quot; capability=2  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368729825.673:28237): avc:  denied  { dac_override } for  pid=9030 comm=&amp;quot;incrontab&amp;quot; capability=1  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From a quick look through &lt;strong&gt;ps&lt;/strong&gt;, I notice that the application runs as
the user (luckily, otherwise I could use the editor to escape and get a
root shell) after which it tries to do something. Of course, it makes
sense that it wants to move this newly created incrontab file somewhere
in &lt;code&gt;/var/spool/incron&lt;/code&gt; so we grant it the permission to
&lt;code&gt;dac_read_search&lt;/code&gt; (which is lower than &lt;code&gt;dac_override&lt;/code&gt; as &lt;a href="http://blog.siphos.be/2013/05/the-weird-audit_access-permission/"&gt;explained
before&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t self:capability { dac_read_search setuid setgid };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On to the next failure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e 
cannot move temporary table: Permission denied

# tail audit.log
type=AVC msg=audit(1368730155.706:28296): avc:  denied  { write } for  pid=9088 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;incron&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=19725 scontext=user_u:user_r:incrontab_t tcontext=root:object_r:incron_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the application wants to write this file there. Now remember we
already have &lt;code&gt;search_dir_perms&lt;/code&gt; permissions into &lt;code&gt;incron_spool_t&lt;/code&gt;? We
need to expand those with read/write permissions into the directory, and
manage permissions on files (manage because users should be able to
create, modify and delete their files). These two permissions are
combined in the &lt;em&gt;manage_files_pattern&lt;/em&gt; interface, and makes the search
one obsolete:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;manage_files_pattern(incrontab_t, incron_spool_t, incron_spool_t)

$ incrontab -e
...
table updated
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally! And looking at the other options in &lt;strong&gt;incrontab&lt;/strong&gt;, it seems
that the policy for &lt;code&gt;incrontab_t&lt;/code&gt; is finally complete, and looks like
so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrontab policy
#

allow incrontab_t self:capability { setuid setgid dac_read_search };

manage_files_pattern(incrontab_t, incron_spool_t, incron_spool_t)

allow incrontab_t incrontab_tmp_t:file manage_file_perms;
files_tmp_filetrans(incrontab_t, incrontab_tmp_t, file)

corecmd_exec_bin(incrontab_t)

domain_use_interactive_fds(incrontab_t)

files_search_spool(incrontab_t)
files_search_tmp(incrontab_t)

auth_use_nsswitch(incrontab_t)

userdom_use_user_terminals(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next on the agenda: the &lt;code&gt;incrond_t&lt;/code&gt; domain.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: basic set for incrontab</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/" rel="alternate"></link><published>2013-05-25T03:50:00+02:00</published><updated>2013-05-25T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-25:/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/</id><summary type="html">&lt;p&gt;Now that our &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/"&gt;regular user is
allowed&lt;/a&gt;
to execute &lt;strong&gt;incrontab&lt;/strong&gt;, let's fire it up and look at the denials to
build up the policy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That doesn't show much does it? Well, if you look into the &lt;code&gt;audit.log&lt;/code&gt;
(or &lt;code&gt;avc.log&lt;/code&gt;) file, you'll notice a lot of denials …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Now that our &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/"&gt;regular user is
allowed&lt;/a&gt;
to execute &lt;strong&gt;incrontab&lt;/strong&gt;, let's fire it up and look at the denials to
build up the policy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That doesn't show much does it? Well, if you look into the &lt;code&gt;audit.log&lt;/code&gt;
(or &lt;code&gt;avc.log&lt;/code&gt;) file, you'll notice a lot of denials. If you are
developing a policy, it is wise to clear the entire log and reproduce
the "situation" so you get a proper idea of the scope.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# cd /var/log/audit
# &amp;gt; audit.log
# tail -f audit.log | grep AVC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now let's run &lt;strong&gt;incrontab --help&lt;/strong&gt; again and look at the denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368707274.429:28180): avc:  denied  { read write } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=user_u:object_r:user_tty_device_t tclass=chr_file
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can start piping this information into &lt;strong&gt;audit2allow&lt;/strong&gt; to generate
policy statements, but I personally prefer not to use &lt;strong&gt;audit2allow&lt;/strong&gt;
for building new policies. For one, it is not intelligent enough to
deduce if a denial should be fixed by allowing it, or by relabeling or
even by creating a new type. Instead, it always grants it. Second, it
does not know if a denial is cosmetic (and thus can be ignored) or not.&lt;/p&gt;
&lt;p&gt;This latter is also why I don't run domains in permissive mode to see
the majority of denials first and to build from those: you might see
denials that are actually never triggered when running in enforcing
mode. So let's look at the access to &lt;code&gt;/dev/tty2&lt;/code&gt;. Given that this is a
user application where we expect output to the screen, we want to grant
it the proper access. With &lt;strong&gt;sefindif&lt;/strong&gt; as
&lt;a href="http://blog.siphos.be/2013/05/commandline-selinux-policy-helper-functions/"&gt;documented&lt;/a&gt;
before, we can look for the proper interfaces we need. I look for
&lt;code&gt;user_tty_device_t&lt;/code&gt; with &lt;code&gt;rw&lt;/code&gt; (commonly used for read-write):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif user_tty_device_t.*rw
system/userdomain.if: template(`userdom_base_user_template&amp;#39;,`
system/userdomain.if:   allow $1_t user_tty_device_t:chr_file { setattr rw_chr_file_perms };
system/userdomain.if: interface(`userdom_use_user_ttys&amp;#39;,`
system/userdomain.if:   allow $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_use_user_terminals&amp;#39;,`
system/userdomain.if:   allow $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_dontaudit_use_user_terminals&amp;#39;,`
system/userdomain.if:   dontaudit $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_dontaudit_use_user_ttys&amp;#39;,`
system/userdomain.if:   dontaudit $1 user_tty_device_t:chr_file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Two of these look interesting: &lt;em&gt;userdom_use_user_ttys&lt;/em&gt; and
&lt;em&gt;userdom_use_user_terminals&lt;/em&gt;. Looking at the API documentation (or
the rules defined therein using &lt;strong&gt;seshowif&lt;/strong&gt;) reveals that
&lt;em&gt;userdom_use_user_terminals&lt;/em&gt; is needed if you also want the
application to work when invoked through a devpts terminal, which is
probably also something our user(s) want to do, so we'll add that. The
second one - using the file descriptor that has the &lt;code&gt;getty_t&lt;/code&gt; context -
is related to this, but not granted through the
&lt;em&gt;userdom_use_user_ttys&lt;/em&gt;. We could grant &lt;em&gt;getty_use_fds&lt;/em&gt; but my
experience tells me that &lt;em&gt;domain_use_interactive_fds&lt;/em&gt; is more likely
to be needed: the application inherits and uses a file descriptor
currently owned by &lt;code&gt;getty_t&lt;/code&gt; but it could be from any of the other
domains that has such file descriptors. For instance, if you grant the
&lt;em&gt;incron_role&lt;/em&gt; to &lt;code&gt;sysadm_r&lt;/code&gt;, then a user that switched roles through
&lt;strong&gt;newrole&lt;/strong&gt; will see denials for using a file descriptor owned by
&lt;code&gt;newrole_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Experience is an important aspect in developing policies. If you would
go through with &lt;em&gt;getty_use_fds&lt;/em&gt; it would work as well, and you'll
probably hit the above mentioned experience later when you try the
application through a few different paths (such as within a screen
session or so). When you &lt;em&gt;think&lt;/em&gt; that the target context (in this case
&lt;code&gt;getty_t&lt;/code&gt;) could be a placeholder (so other types are likely to be
needed as well), make sure you check which attributes are assigned to
the type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seinfo -tgetty_t -x
   getty_t
      privfd
      mcssetcats
      mlsfileread
      mlsfilewrite
      application_domain_type
      domain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of the above ones, &lt;code&gt;privfd&lt;/code&gt; is the important one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif privfd.*use
kernel/domain.if: interface(`domain_use_interactive_fds&amp;#39;,`
kernel/domain.if:       allow $1 privfd:fd use;
kernel/domain.if: interface(`domain_dontaudit_use_interactive_fds&amp;#39;,`
kernel/domain.if:       dontaudit $1 privfd:fd use;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So let's update &lt;code&gt;incron.te&lt;/code&gt; accordingly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
type incron_spool_t;
files_type(incron_spool_t)

###########################################
#
# incrontab policy
#

userdom_use_user_terminals(incrontab_t)
domain_use_interactive_fds(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Rebuild the policy and load it in memory.&lt;/p&gt;
&lt;p&gt;If we now run &lt;strong&gt;incrontab&lt;/strong&gt; we get the online help as we expected. Let's
now look at the currently installed incrontabs (there shouldn't be any
of course):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot determine current user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the denials, we notice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368708632.060:28192): avc:  denied  { create } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=unix_stream_socket
type=AVC msg=audit(1368708632.060:28194): avc:  denied  { read } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;nsswitch.conf&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393768 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:etc_t tclass=file
type=AVC msg=audit(1368708632.062:28196): avc:  denied  { read } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;passwd&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394223 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:etc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's first focus on &lt;code&gt;nsswitch.conf&lt;/code&gt; and &lt;code&gt;passwd&lt;/code&gt;. Although both require
read access to &lt;code&gt;etc_t&lt;/code&gt; files, it might be wrong to just add in
&lt;em&gt;files_read_etc&lt;/em&gt; (which is what &lt;strong&gt;audit2allow&lt;/strong&gt; is probably going to
suggest). For nsswitch, there is a special interface available:
&lt;em&gt;auth_use_nsswitch&lt;/em&gt;. It is very, very likely that you'll need this
one, especially if you want to share the policy with others who might
not have all of the system databases in local files (as &lt;code&gt;etc_t&lt;/code&gt; files).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
domain_use_interactive_fds(incrontab_t)
auth_use_nsswitch(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's retry:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot read table for &amp;#39;user&amp;#39;: Permission denied

# tail audit.log
type=AVC msg=audit(1368708893.260:28199): avc:  denied  { search } for  pid=7997 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;spool&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=20 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:var_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So we need to grant search privileges on &lt;code&gt;var_spool_t&lt;/code&gt;. This is offered
through &lt;em&gt;files_search_spool&lt;/em&gt;. Add it to the policy, rebuild and retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot read table for &amp;#39;user&amp;#39;: Permission denied

# tail audit.log
type=AVC msg=audit(1368709146.426:28201): avc:  denied  { search } for  pid=8046 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;incron&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=19725 scontext=user_u:user_r:incrontab_t tcontext=root:object_r:incron_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For this one, no interface exists yet. We might be able to create one
for ourselves, but as long as other domains don't need it, we can just
add it locally in our policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t incron_spool_t:dir search_dir_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Adding raw allow rules in a policy is, according to the &lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide"&gt;refpolicy
styleguide&lt;/a&gt;,
only allowed if the policy module defines both the source and the
destination type of the rule. If you look into other policies you might
also find that you can use the &lt;em&gt;search_dirs_patter&lt;/em&gt; call. However,
that one only makes sense if you need to do this on top of another
directory - just look at the definition of &lt;em&gt;search_dirs_pattern&lt;/em&gt;. So
with this permission set, let's retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
no table for user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Great, we have successfully updated the policy until the commands
worked. In the next post, we'll enhance it even further while creating
new incrontabs.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="incrontab"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: our first interface</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/" rel="alternate"></link><published>2013-05-24T03:50:00+02:00</published><updated>2013-05-24T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-24:/2013/05/a-selinux-policy-for-incron-our-first-interface/</id><summary type="html">&lt;p&gt;The next step after having &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/"&gt;a basic
skeleton&lt;/a&gt;
is to get &lt;strong&gt;incrontab&lt;/strong&gt; running. We know however that everything invoked
from the main daemon will be running with the rights of the daemon
context (unless we would patch the source code, but that is beyond the
scope of this set of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The next step after having &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/"&gt;a basic
skeleton&lt;/a&gt;
is to get &lt;strong&gt;incrontab&lt;/strong&gt; running. We know however that everything invoked
from the main daemon will be running with the rights of the daemon
context (unless we would patch the source code, but that is beyond the
scope of this set of posts). As a result, we probably do not want
everyone to be able to launch commands through this application.&lt;/p&gt;
&lt;p&gt;What we want to do is to limit who can invoke &lt;strong&gt;incrontab&lt;/strong&gt; and, as
such, limit who can decide what is invoked through &lt;strong&gt;incrond&lt;/strong&gt;. First of
all, we define a &lt;em&gt;role attribute&lt;/em&gt; called &lt;code&gt;incrontab_roles&lt;/code&gt;. Every role
that gets this attribute assigned will be able to transition to the
&lt;code&gt;incrontab_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;We can accomplish this by editing the &lt;code&gt;incron.te&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(incron, 0.2)

# Declare the incrontab_roles attribute
attribute_role incrontab_roles;

...
type incrontab_t;
type incrontab_exec_t;
application_domain(incrontab_t, incrontab_exec_t)
# Allow incrontab_t for all incrontab_roles 
role incrontab_roles types incrontab_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, we need something where we can allow user domains to call
incrontab. This will be done through an interface. Let's look at
&lt;code&gt;incron.if&lt;/code&gt; with one such interface in it: the &lt;em&gt;incron_role&lt;/em&gt; interface.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## inotify-based cron-like daemon

#########################################
## &amp;lt;summary&amp;gt;
##      Role access for incrontab
## &amp;lt;/summary&amp;gt;
## &amp;lt;param name=&amp;quot;role&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      Role allowed access.
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
## &amp;lt;param name=&amp;quot;domain&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      User domain for the role.
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
#
interface(`incron_role&amp;#39;,`
        gen_require(`
                attribute_role incrontab_roles;
                type incrontab_exec_t, incrontab_t;
        &amp;#39;)

        roleattribute $1 incrontab_roles;

        domtrans_pattern($2, incrontab_exec_t, incrontab_t)

        ps_process_pattern($2, incrontab_t)
        allow $2 incrontab_t:process signal;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The comments in the file are somewhat special: if the comments start
with two hashes (&lt;code&gt;##&lt;/code&gt;) then it is taken into account while building the
policy documentation in &lt;code&gt;/usr/share/doc/selinux-base-*&lt;/code&gt;. The interface
itself, &lt;em&gt;incron_role&lt;/em&gt;, grants a user role and domain the necessary
privileges to transition to the &lt;code&gt;incrontab_t&lt;/code&gt; domain as well as read
process information (as used through &lt;strong&gt;ps&lt;/strong&gt;, hence the name of the
pattern being &lt;code&gt;ps_process_pattern&lt;/code&gt;) and send a standard signal to it.
Most of the time, you can use &lt;code&gt;signal_perms&lt;/code&gt; here but from looking at
the application we see that the application is setuid root, so we don't
want to grant too many privileges by default if they are not needed.&lt;/p&gt;
&lt;p&gt;With this interface file created, we can rebuild the module and load it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile incron.pp
# semodule -i incron.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But how to assign this interface to users? Well, what we want to do is
something like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;incron_role(user_r, user_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When interfaces are part of the policy provided by the distribution, the
definitions of it are stored in the proper location and you can easily
add it. For instance, in Gentoo, if you want to allow the &lt;code&gt;user_r&lt;/code&gt; role
and &lt;code&gt;user_t&lt;/code&gt; domain the &lt;em&gt;cron_role&lt;/em&gt; access (and assuming it doesn't
have so already), then you can call &lt;strong&gt;selocal&lt;/strong&gt; as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal -a &amp;quot;cron_role(user_r, user_t)&amp;quot; -c &amp;quot;Granting user_t cron access&amp;quot; -Lb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, because the interface is currently not known yet, we need to
create a second small policy that does this. Create a file (called
&lt;code&gt;localuser.te&lt;/code&gt; or so) with the following content:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(localuser, 0.1)

gen_require(`
        type user_t;
        role user_r;
&amp;#39;)

incron_role(user_r, user_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now build the policies and load them. We'll now just build and load all
the policies in the current directory (which will be the incron and
localuser ones):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile
# semodule -i *.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can now verify that the user is allowed to transition to the
&lt;code&gt;incrontab_t&lt;/code&gt; domain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seinfo -ruser_r -x | grep incron
         incrontab_t
# sesearch -s user_t -t incrontab_exec_t -AdCTS
Found 1 semantic av rules:
   allow user_t incrontab_exec_t : file { read getattr execute open } ;

Found 1 semantic te rules:
   type_transition user_t incrontab_exec_t : process incrontab_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Great, let's get to our first failure to resolve... in the next post ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="interface"></category><category term="policy"></category></entry><entry><title>A SELinux policy for incron: the basic skeleton</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/" rel="alternate"></link><published>2013-05-23T03:50:00+02:00</published><updated>2013-05-23T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-23:/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/</id><summary type="html">&lt;p&gt;So, in the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/"&gt;previous
post&lt;/a&gt;
I talked about &lt;em&gt;incron&lt;/em&gt; and why I think moving it into the existing cron
policy would not be a good idea. It works, somewhat, but is probably not
that future-proof. So we're going to create our own policy for it.&lt;/p&gt;
&lt;p&gt;In SELinux, policies are generally …&lt;/p&gt;</summary><content type="html">&lt;p&gt;So, in the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/"&gt;previous
post&lt;/a&gt;
I talked about &lt;em&gt;incron&lt;/em&gt; and why I think moving it into the existing cron
policy would not be a good idea. It works, somewhat, but is probably not
that future-proof. So we're going to create our own policy for it.&lt;/p&gt;
&lt;p&gt;In SELinux, policies are generally written through 3 files:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a &lt;em&gt;type enforcement&lt;/em&gt; file that contains the SELinux rules applicable
    to the domain(s) related to the application (in our example,
    &lt;em&gt;incron&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;file context&lt;/em&gt; file that tells the SELinux utilities how the files
    and directories offered by the application should be labeled&lt;/li&gt;
&lt;li&gt;an &lt;em&gt;interface definition&lt;/em&gt; file that allows other SELinux policy
    modules to gain rights offered through the (to be written) &lt;em&gt;incron&lt;/em&gt;
    policy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We now need to create a skeleton for the policy. This skeleton will
define the types related to the application. Such types can be the
domains for the processes (the context of the &lt;strong&gt;incrond&lt;/strong&gt; and perhaps
also &lt;strong&gt;incrontab&lt;/strong&gt; applications), the contexts for the directories (if
any) and files, etc.&lt;/p&gt;
&lt;p&gt;So let's take a look at the content of the &lt;em&gt;incron&lt;/em&gt; package. On Gentoo,
we can use &lt;strong&gt;qlist incron&lt;/strong&gt; for this. In the output of &lt;strong&gt;qlist&lt;/strong&gt;, I
added comments to show you how contexts can be (easily) deduced.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Application binary for managing user crontabs. We want to give this a specific
# context because we want the application (which will manage the incrontabs in
# /var/spool/incron) in a specific domain
/usr/bin/incrontab  ## incrontab_exec_t

# General application information files, do not need specific attention
# (the default context is fine)
/usr/share/doc/incron-0.5.10/README.bz2
/usr/share/doc/incron-0.5.10/TODO.bz2
/usr/share/doc/incron-0.5.10/incron.conf.example.bz2
/usr/share/doc/incron-0.5.10/CHANGELOG.bz2
/usr/share/man/man8/incrond.8.bz2
/usr/share/man/man5/incron.conf.5.bz2
/usr/share/man/man5/incrontab.5.bz2
/usr/share/man/man1/incrontab.1.bz2

# Binary for the incrond daemon. This definitely needs its own context, since
# it will be launched from an init script and we do not want it to run in the
# initrc_t domain.
/usr/sbin/incrond ## incrond_exec_t

# This is the init script for the incrond daemon. If we want to allow 
# some users the rights to administer incrond without needing to grant
# those users the sysadm_r role, we need to give this file a different
# context as well.
/etc/init.d/incrond ## incrond_initrc_exec_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this information at hand, and the behavior of the application we
know from the previous post, can lead to the following &lt;code&gt;incron.fc&lt;/code&gt; file,
which defines the file contexts for the application.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/incron.d(/.*)?     gen_context(system_u:object_r:incron_spool_t,s0)

/etc/rc\.d/init\.d/incrond      --      gen_context(system_u:object_r:incrond_initrc_exec_t,s0)

/usr/bin/incrontab      --      gen_context(system_u:object_r:incrontab_exec_t,s0)

/usr/sbin/incrond       --      gen_context(system_u:object_r:incrond_exec_t,s0)

/var/spool/incron(/.*)?         gen_context(system_u:object_r:incron_spool_t,s0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The syntax of this file closely follows the syntax that &lt;strong&gt;semanage
fcontext&lt;/strong&gt; takes - at least for the regular expressions in the
beginning. The last column is specifically for policy development to
generate a context based on the policies' requirements: an MCS/MLS
enabled policy will get the trailing sensitivity with it, but when
MCS/MLS is disabled then it is dropped. The middle column is to specify
if the label should only be set on regular files (&lt;code&gt;--&lt;/code&gt;), directories
(&lt;code&gt;-d&lt;/code&gt;), sockets (&lt;code&gt;-s&lt;/code&gt;), symlinks (&lt;code&gt;-l&lt;/code&gt;), etc. If it is omitted, it
matches whatever class the path matches.&lt;/p&gt;
&lt;p&gt;The second file needed for the skeleton is the &lt;code&gt;incron.te&lt;/code&gt; file, which
would look like so. I added in inline comments here to explain why
certain lines are prepared, but generally this is omitted when the
policy is &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;upstreamed&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(incron, 0.1)
# The above line declares that this file is a SELinux policy file. Its name
# is incron, so the file should saved as incron.te

# First, we declare the incrond_t domain, used for the &amp;quot;incrond&amp;quot; process.
# Because it is launched from an init script, we tell the policy that
# incrond_exec_t (the context of incrond), when launched from init, should
# transition to incrond_t.
#
# Basically, the syntax here is:
# type 
# type 
# 
type incrond_t;
type incrond_exec_t;
init_daemon_domain(incrond_t, incrond_exec_t)

# Next we declare that the incrond_initrc_exec_t is an init script context
# so that init can execute it (remember, SELinux is a mandatory access control
# system, so if we do not tell that init can execute it, it won&amp;#39;t).
type incrond_initrc_exec_t;
init_script_file(incrond_initrc_exec_t)

# We also create the incrontab_t domain (for the &amp;quot;incrontab&amp;quot; application), which
# is triggered through the incrontab_exec_t labeled file. This again follows a bit
# the syntax as we used above, but now the interface call is &amp;quot;application_domain&amp;quot;.
type incrontab_t;
type incrontab_exec_t;
application_domain(incrontab_t, incrontab_exec_t)

# Finally we declare the spool type as well (incron_spool_t) and tell SELinux that
# it will be used for regular files.
type incron_spool_t;
files_type(incron_spool_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Knowing which interface calls, like &lt;em&gt;init_daemon_domain&lt;/em&gt; and
&lt;em&gt;application_domain&lt;/em&gt;, we should use is not obvious at first. Most of
this can be gathered from existing policies. Other frequently occurring
interfaces to be used immediately at the skeleton side are (examples for
a &lt;code&gt;foo_t&lt;/code&gt; domain):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;logging_log_file(foo_log_t)&lt;/em&gt; to inform SELinux that the context
    is used for logging purposes. This allows generic log-related
    daemons to do "their thing" with the file.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_tmp_file(foo_tmp_t)&lt;/em&gt; to identify the context as being
    used for temporary files&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_tmpfs_file(foo_tmpfs_t)&lt;/em&gt; for tmpfs files (which could be
    shared memory)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_pid_file(foo_var_run_t)&lt;/em&gt; for PID files (and other run
    metadata files)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_config_file(foo_conf_t)&lt;/em&gt; for configuration files (often
    within &lt;code&gt;/etc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_lock_file(foo_lock_t)&lt;/em&gt; for lock files (often within
    &lt;code&gt;/run/lock&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We might be using these later as we progress with the policy (for
instance, the PID file is a very high candidate for needing to be
included). However, with the information currently at hand, we have our
first policy module ready for building. Save the type enforcement rules
in &lt;code&gt;incron.te&lt;/code&gt; and the file contexts in &lt;code&gt;incron.fc&lt;/code&gt; and you can then
build the SELinux policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile incron.pp
# semodule -i incron.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On Gentoo, you can then relabel the files and directories offered
through the package using &lt;strong&gt;rlpkg&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# rlpkg incron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next is to start looking at the &lt;strong&gt;incrontab&lt;/strong&gt; application.&lt;/p&gt;</content><category term="SELinux"></category><category term="fc"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category><category term="skeleton"></category><category term="te"></category></entry><entry><title>A SELinux policy for incron: what does it do?</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/" rel="alternate"></link><published>2013-05-22T03:50:00+02:00</published><updated>2013-05-22T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-22:/2013/05/a-selinux-policy-for-incron-what-does-it-do/</id><summary type="html">&lt;p&gt;In this series of posts, we'll go through the creation of a SELinux
policy for
&lt;a href="http://inotify.aiken.cz/?section=incron&amp;amp;page=doc⟨=en"&gt;incron&lt;/a&gt;, a simple
inotify based cron-like application. I will talk about the various steps
that I would take in the creation of this policy, and give feedback when
certain decisions are taken and why. At …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this series of posts, we'll go through the creation of a SELinux
policy for
&lt;a href="http://inotify.aiken.cz/?section=incron&amp;amp;page=doc⟨=en"&gt;incron&lt;/a&gt;, a simple
inotify based cron-like application. I will talk about the various steps
that I would take in the creation of this policy, and give feedback when
certain decisions are taken and why. At the end of the series, we'll
have a hopefully well working policy.&lt;/p&gt;
&lt;p&gt;The first step in developing a policy is to know what the application
does and how/where it works. This allows us to check if its behavior
matches an existing policy (and as such might be best just added to this
policy) or if a new policy needs to be written. So, what does incron do?&lt;/p&gt;
&lt;p&gt;From the documentation, we know that &lt;em&gt;incron&lt;/em&gt; is a cron-like application
that, unlike cron, works with file system notification events instead of
time-related events. Other than that, it uses a similar way of working:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A daemon called &lt;strong&gt;incrond&lt;/strong&gt; is the run-time application that reads
    in the &lt;em&gt;incrontab&lt;/em&gt; files and creates the proper inotify watches.
    When a watch is triggered, it will execute the matching rule.&lt;/li&gt;
&lt;li&gt;The daemon looks at two definitions (incrontabs): one system-wide
    (in &lt;code&gt;/etc/incron.d&lt;/code&gt;) and one for users (in &lt;code&gt;/var/spool/incron&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The user tabfiles are managed through &lt;strong&gt;incrontab&lt;/strong&gt; (the command)&lt;/li&gt;
&lt;li&gt;Logging is done through syslog&lt;/li&gt;
&lt;li&gt;User commands are executed with the users' privileges (so the
    application calls &lt;em&gt;setuid()&lt;/em&gt; and &lt;em&gt;setgid()&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this, one can create a script to be executed when a file is
uploaded (or deleted) to/from a file server, or when a process coredump
occurred, or whatever automation you want to trigger when some file
system event occurred. Events are plenty and can be found in
&lt;code&gt;/usr/include/sys/inotify.h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, with this information, it is safe to assume that we might be able to
push incron in the existing &lt;em&gt;cron&lt;/em&gt; policy. After all, it defines the
contexts for all these and probably doesn't need any additional
tweaking. And this seems to work at first, but a few tests reveal that
the behavior is not that optimal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# chcon -t crond_exec_t /usr/sbin/incrond
# chcon -t crontab_exec_t /usr/bin/incrontab
# chcon -R -t system_cron_spool_t /etc/incron.d
# chcon -t cron_log_t /var/log/cron.log
# chcon -R -t cron_spool_t /var/spool/incron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;System tables work somewhat, but all commands are executed in the
&lt;code&gt;crond_t&lt;/code&gt; domain, not in a &lt;code&gt;system_cronjob_t&lt;/code&gt; or related domain.&lt;br&gt;
User tables fail when dealing with files in the users directories,
since these too run in &lt;code&gt;crond_t&lt;/code&gt; and thus have no read access to the
user home directories.&lt;/p&gt;
&lt;p&gt;The problems we notice come from the fact that the application is very
simple in its code: it is not SELinux-aware (so it doesn't change the
runtime context) as most cron daemons are, and when it changes the user
id it does not call PAM, so we cannot trigger &lt;code&gt;pam_selinux.so&lt;/code&gt; to handle
context changes either. As a result, the entire daemon keeps running in
&lt;code&gt;crond_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is one reason why a separate domain could be interesting: we might
want to extend the rights of the daemon domain a bit, but don't want to
extend these rights to the other cron daemons (who also run in
&lt;code&gt;crond_t&lt;/code&gt;). Another reason is that the cron policy has a few booleans
that would not affect the behavior at all, making it less obvious for
users to troubleshoot. As a result, we'll go for the separate policy
instead - which will be for the next post.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Why oh why does a process run in unlabeled_t?</title><link href="https://blog.siphos.be/2013/05/why-oh-why-does-a-process-run-in-unlabeled_t/" rel="alternate"></link><published>2013-05-21T03:50:00+02:00</published><updated>2013-05-21T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-21:/2013/05/why-oh-why-does-a-process-run-in-unlabeled_t/</id><summary type="html">&lt;p&gt;If you notice that a process is running in the &lt;code&gt;unlabeled_t&lt;/code&gt; domain, the
first question to ask is how it got there.&lt;/p&gt;
&lt;p&gt;Well, one way is to have a process running in a known domain, like
&lt;code&gt;screen_t&lt;/code&gt;, after which the SELinux policy module that provides this
domain is removed from …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you notice that a process is running in the &lt;code&gt;unlabeled_t&lt;/code&gt; domain, the
first question to ask is how it got there.&lt;/p&gt;
&lt;p&gt;Well, one way is to have a process running in a known domain, like
&lt;code&gt;screen_t&lt;/code&gt;, after which the SELinux policy module that provides this
domain is removed from the system (or updated and the update does not
contain the &lt;code&gt;screen_t&lt;/code&gt; definition anymore):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test ~ # ps -eZ | grep screen
root:sysadm_r:sysadm_screen_t    5047 ?        00:00:00 screen
test ~ # semodule -r screen
test ~ # ps -eZ | grep screen
system_u:object_r:unlabeled_t    5047 ?        00:00:00 screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In permissive mode, this will be visible easily; in enforcing mode, the
domains you are running in might not be allowed to do anything with
&lt;code&gt;unlabeled_t&lt;/code&gt; files, directories and processes, so &lt;strong&gt;ps&lt;/strong&gt; might not show
it even though it still exists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test audit # ps -eZ | grep 5047
test audit # ls -dZ /proc/5047
ls: cannot access /proc/5047: Permission denied
test audit # tail audit.log | grep unlabeled
type=AVC msg=audit(1368698097.494:27806): avc:  denied  { getattr } for  pid=4137 comm=&amp;quot;bash&amp;quot; path=&amp;quot;/proc/5047&amp;quot; dev=&amp;quot;proc&amp;quot; ino=6677 scontext=root:sysadm_r:sysadm_t tcontext=system_u:object_r:unlabeled_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that, if you reload the module, the process becomes visible
again. That is because the process context itself (&lt;code&gt;screen_t&lt;/code&gt;) is
retained, but because the policy doesn't know it anymore, it shows it as
&lt;code&gt;unlabeled_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Basically, the moment the policy doesn't know how a label would be
(should be), it uses &lt;code&gt;unlabeled_t&lt;/code&gt;. The SELinux policy then defines how
this &lt;code&gt;unlabeled_t&lt;/code&gt; domain is handled. Processes getting into
&lt;code&gt;unlabeled_t&lt;/code&gt; is not that common though as there is no supported
transition to it. The above one is one way that this still can occur.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="selinux"></category><category term="unlabeled"></category></entry><entry><title>The weird "audit_access" permission</title><link href="https://blog.siphos.be/2013/05/the-weird-audit_access-permission/" rel="alternate"></link><published>2013-05-19T03:50:00+02:00</published><updated>2013-05-19T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-19:/2013/05/the-weird-audit_access-permission/</id><summary type="html">&lt;p&gt;While writing up the posts on capabilities, one thing I had in my mind
was to give some additional information on frequently occurring denials,
such as the &lt;em&gt;dac_override&lt;/em&gt; and &lt;em&gt;dac_read_search&lt;/em&gt; capabilities, and
when they are triggered. For the DAC-related capabilities, policy
developers often notice that these capabilities are triggered without …&lt;/p&gt;</summary><content type="html">&lt;p&gt;While writing up the posts on capabilities, one thing I had in my mind
was to give some additional information on frequently occurring denials,
such as the &lt;em&gt;dac_override&lt;/em&gt; and &lt;em&gt;dac_read_search&lt;/em&gt; capabilities, and
when they are triggered. For the DAC-related capabilities, policy
developers often notice that these capabilities are triggered without a
real need for them. So in the majority of cases, the policy developer
wants to disable auditing of this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dontaudit &amp;lt;somedomain&amp;gt; self:capability { dac_read_search dac_override };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When applications wants to search through directories not owned by the
user as which the application runs, &lt;em&gt;both&lt;/em&gt; capabilities will be checked
- first the &lt;em&gt;dac_read_search&lt;/em&gt; one and, if that is denied (it will be
audited though) then &lt;em&gt;dac_override&lt;/em&gt; is checked. If that one is denied
as well, it too will be audited. That is why many developers
automatically &lt;em&gt;dontaudit&lt;/em&gt; both capability calls if the application
itself doesn't really need the permission.&lt;/p&gt;
&lt;p&gt;Let's say you allow this because the application needs it. But then
another issue comes up when the application checks file attributes or
access permissions (which is a second occurring denial that developers
come across with). Such applications use &lt;em&gt;access()&lt;/em&gt; or &lt;em&gt;faccessat()&lt;/em&gt; to
get information about files, but other than that don't do anything with
the files. When this occurs and the domain does not have read, write or
execute permissions on the target, then the denial is shown even when
the application doesn't really read, write or execute the file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char ** argv) {
  printf(&amp;quot;%s: Exists (%d), Readable (%d), Writeable (%d), Executable (%d)\n&amp;quot;, argv[1],
    access(argv[1], F_OK), access(argv[1], R_OK),
    access(argv[1], W_OK), access(argv[1], X_OK));
}

$ check /var/lib/logrotate.status
/var/lib/logrotate.status: Exists (0), Readable (-1), Writeable (-1), Executable (-1)

$ tail -1 /var/log/audit.log
...
type=AVC msg=audit(1367400559.273:5224): avc:  denied  { read } for  pid=12270 comm=&amp;quot;test&amp;quot; name=&amp;quot;logrotate.status&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=2849 scontext=staff_u:staff_r:staff_t tcontext=system_u:object_r:logrotate_var_lib_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This gives the impression that the application is doing nasty stuff,
even when it is merely checking permissions. One way would be to
dontaudit read as well, but if the application does the check against
several files of various types, that might mean you need to include
dontaudit statements for various domains. That by itself isn't wrong,
but perhaps you do not want to audit such checks but do want to audit
real read attempts. This is what the &lt;em&gt;audit_access&lt;/em&gt; permission is for.&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://marc.info/?l=selinux&amp;amp;m=125349740623497&amp;amp;w=2"&gt;audit_access&lt;/a&gt;
&lt;a href="http://marc.info/?l=selinux&amp;amp;m=127239846604513"&gt;permission&lt;/a&gt; is meant to
be used only for &lt;em&gt;dontaudit&lt;/em&gt; statements: it has no effect on the
security of the system itself, so using it in &lt;em&gt;allow&lt;/em&gt; statements has no
effect. The purpose of the permission is to allow policy developers to
not audit access checks without really dontauditing other, possibly
malicious, attempts. In other words, checking the access can be
dontaudited while actually attempting to use the access (reading,
writing or executing the file) will still result in the proper denial.&lt;/p&gt;</content><category term="SELinux"></category><category term="access"></category><category term="audit"></category><category term="audit_access"></category><category term="selinux"></category></entry><entry><title>Commandline SELinux policy helper functions</title><link href="https://blog.siphos.be/2013/05/commandline-selinux-policy-helper-functions/" rel="alternate"></link><published>2013-05-18T03:50:00+02:00</published><updated>2013-05-18T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-18:/2013/05/commandline-selinux-policy-helper-functions/</id><summary type="html">&lt;p&gt;To work on SELinux policies, I use a couple of functions that I can call
on the shell (command line): &lt;strong&gt;seshowif&lt;/strong&gt;, &lt;strong&gt;sefindif&lt;/strong&gt;, &lt;strong&gt;seshowdef&lt;/strong&gt;
and &lt;strong&gt;sefinddef&lt;/strong&gt;. The idea behind the methods is that I want to search
(&lt;em&gt;find&lt;/em&gt;) for an interface (&lt;em&gt;if&lt;/em&gt;) or definition (&lt;em&gt;def&lt;/em&gt;) that contains a
particular method or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;To work on SELinux policies, I use a couple of functions that I can call
on the shell (command line): &lt;strong&gt;seshowif&lt;/strong&gt;, &lt;strong&gt;sefindif&lt;/strong&gt;, &lt;strong&gt;seshowdef&lt;/strong&gt;
and &lt;strong&gt;sefinddef&lt;/strong&gt;. The idea behind the methods is that I want to search
(&lt;em&gt;find&lt;/em&gt;) for an interface (&lt;em&gt;if&lt;/em&gt;) or definition (&lt;em&gt;def&lt;/em&gt;) that contains a
particular method or call. Or, if I know what the interface or
definition is, I want to see it (&lt;em&gt;show&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;For instance, to find the name of the interface that allows us to define
file transitions from the &lt;code&gt;postfix_etc_t&lt;/code&gt; label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif filetrans.*postfix_etc
contrib/postfix.if: interface(`postfix_config_filetrans&amp;#39;,`
contrib/postfix.if:     filetrans_pattern($1, postfix_etc_t, $2, $3, $4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Or to show the content of the &lt;em&gt;corenet_tcp_bind_http_port&lt;/em&gt;
interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seshowif corenet_tcp_bind_http_port
interface(`corenet_tcp_bind_http_port&amp;#39;,`
        gen_require(`
                type http_port_t;
        &amp;#39;)

        allow $1 http_port_t:tcp_socket name_bind;
        allow $1 self:capability net_bind_service;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For the definitions, this is quite similar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefinddef socket.*create
obj_perm_sets.spt:define(`create_socket_perms&amp;#39;, `{ create rw_socket_perms }&amp;#39;)
obj_perm_sets.spt:define(`create_stream_socket_perms&amp;#39;, `{ create_socket_perms listen accept }&amp;#39;)
obj_perm_sets.spt:define(`connected_socket_perms&amp;#39;, `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }&amp;#39;)
obj_perm_sets.spt:define(`create_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read nlmsg_write }&amp;#39;)
obj_perm_sets.spt:define(`rw_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read nlmsg_write }&amp;#39;)
obj_perm_sets.spt:define(`r_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read }&amp;#39;)
obj_perm_sets.spt:define(`client_stream_socket_perms&amp;#39;, `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }&amp;#39;)

$ seshowdef manage_files_pattern
define(`manage_files_pattern&amp;#39;,`
        allow $1 $2:dir rw_dir_perms;
        allow $1 $3:file manage_file_perms;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I have these defined in my &lt;code&gt;~/.bashrc&lt;/code&gt; (they are simple
&lt;a href="http://dev.gentoo.org/~swift/blog/01/selinux-funcs.txt"&gt;functions&lt;/a&gt;) and
are used on a daily basis here ;-) If you want to learn a bit more on
developing SELinux policies for Gentoo, make sure you read the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-development.xml"&gt;Gentoo
Hardened SELinux
Development&lt;/a&gt;
guide.&lt;/p&gt;</content><category term="SELinux"></category><category term="bash"></category><category term="definition"></category><category term="functions"></category><category term="interface"></category><category term="policy"></category><category term="selinux"></category><category term="support"></category></entry><entry><title>SECMARK and SELinux</title><link href="https://blog.siphos.be/2013/05/secmark-and-selinux/" rel="alternate"></link><published>2013-05-13T03:50:00+02:00</published><updated>2013-05-13T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-13:/2013/05/secmark-and-selinux/</id><summary type="html">&lt;p&gt;When using SECMARK, the administrator configures the &lt;strong&gt;iptables&lt;/strong&gt; or
&lt;strong&gt;netfilter&lt;/strong&gt; rules to add a label to the packet data structure (on the
host itself) that can be governed through SELinux policies. Unlike peer
labeling, here the labels assigned to the network traffic is completely
locally defined. Consider the following command …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When using SECMARK, the administrator configures the &lt;strong&gt;iptables&lt;/strong&gt; or
&lt;strong&gt;netfilter&lt;/strong&gt; rules to add a label to the packet data structure (on the
host itself) that can be governed through SELinux policies. Unlike peer
labeling, here the labels assigned to the network traffic is completely
locally defined. Consider the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# iptables -t mangle -A INPUT -p tcp --src 192.168.1.2 --dport 443
  -j SECMARK --selctx system_u:object_r:myauth_packet_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this command, packets that originate from the &lt;em&gt;192.168.1.2&lt;/em&gt; host
and arrive on port 443 (typically used for HTTPS traffic) are marked as
&lt;code&gt;myauth_packet_t&lt;/code&gt;. SELinux policy writers can then allow domains to
receive this type of packets (or send) through the &lt;em&gt;packet&lt;/em&gt; class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Allow sockets with mydomain_t context to receive packets labeled myauth_packet_t
allow mydomain_t myauth_packet_t:packet recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The SELinux policy modules enable this through the
&lt;em&gt;corenet_sendrecv_&amp;lt;type&amp;gt;_{client,server}_packets&lt;/em&gt; interfaces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_sendrecv_http_client_packets(mybrowser_t)
# allow mybrowser_t http_client_packet_t:packet { send recv };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As a common rule, packets are marked as client packets or server
packets, depending on the role of the &lt;em&gt;domain&lt;/em&gt;. In the above example,
the domain is a browser, so acts as a web client. So, it needs to send
and receive &lt;code&gt;http_client_packet_t&lt;/code&gt;. A web server on the other hand would
need to send and receive &lt;code&gt;http_server_packet_t&lt;/code&gt;. Note that the packets
that are sent over the wire do not have any labels assigned to them -
this is all local to the system. So even when the source and destination
use SELinux with SECMARK, on the source server the packets might be
labeled as &lt;code&gt;http_client_packet_t&lt;/code&gt; whereas on the target they are seen as
&lt;code&gt;http_server_packet_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As far as I know, when you want to use SECMARK, you will need to set the
contexts with &lt;strong&gt;iptables&lt;/strong&gt; yourself (there is no default labeling), so
knowing about the above convention is important.&lt;/p&gt;
&lt;p&gt;Again, Paul Moore has &lt;a href="http://paulmoore.livejournal.com/4281.html"&gt;more
information&lt;/a&gt; about this.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="secmark"></category><category term="selinux"></category></entry><entry><title>Peer labeling in SELinux policy</title><link href="https://blog.siphos.be/2013/05/peer-labeling-in-selinux-policy/" rel="alternate"></link><published>2013-05-12T03:50:00+02:00</published><updated>2013-05-12T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-12:/2013/05/peer-labeling-in-selinux-policy/</id><summary type="html">&lt;p&gt;Allow me to start with an important warning: I don't have much hands-on
experience with the remainder of this post. Its based on the few
resources I found on the Internet and a few tests done locally which
I've investigated in my attempt to understand SELinux policy writing for
networking …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Allow me to start with an important warning: I don't have much hands-on
experience with the remainder of this post. Its based on the few
resources I found on the Internet and a few tests done locally which
I've investigated in my attempt to understand SELinux policy writing for
networking stuff.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, let's look into &lt;em&gt;peer labeling&lt;/em&gt;. As
mentioned in my &lt;a href="http://blog.siphos.be/2013/05/selinux-policy-and-network-controls/"&gt;previous
post&lt;/a&gt;,
SELinux supports some more advanced networking security features than
the default socket restrictions. I mentioned SECMARK and NetLabel
before, but NetLabel is actually part of the family of &lt;em&gt;peer&lt;/em&gt; labeling
technologies.&lt;/p&gt;
&lt;p&gt;With this technology approach, all participating systems in the network
must support the same labeling method. NetLabel supports CIPSO
(&lt;a href="https://tools.ietf.org/html/draft-ietf-cipso-ipsecurity-01"&gt;Commerial IP Security
Option&lt;/a&gt;)
where hosts label their network traffic to be part of a particular
"Domain of Interpretation". The labels are used by the hosts to identify
where a packet should be for. NetLabel, within Linux, is then used to
translate those CIPSO labels. SELinux itself labels the incoming sockets
based on the NetLabel information and the context of the listening
socket, resulting in a context that is governed policy-wise through the
&lt;em&gt;peer&lt;/em&gt; class. Since this is based on the information in the packet
instead of defined on the system itself, this allows remote systems to
have a say in how the packets are labeled.&lt;/p&gt;
&lt;p&gt;Another peer technology is the &lt;em&gt;Labeled IPSec&lt;/em&gt; one. In this case the
labels are fully provided by the remote system. I think they are based
on the security association within the IPSec setup.&lt;/p&gt;
&lt;p&gt;In both cases, in the SELinux policies, three definitions are important
to keep an eye out on: &lt;em&gt;interface&lt;/em&gt; definitions, &lt;em&gt;node&lt;/em&gt; definitions and
&lt;em&gt;peer&lt;/em&gt; definitions.&lt;/p&gt;
&lt;p&gt;Interface definitions allow users to (mainly) set the sensitivity that
is allowed to pass the interface. Using &lt;strong&gt;semanage interface&lt;/strong&gt; this can
be controlled by the user. One can also assign a different context to
the interface - by default, this is &lt;code&gt;netif_t&lt;/code&gt;. The permissions that are
checked on the traffic is &lt;em&gt;ingress&lt;/em&gt; (incoming) and &lt;em&gt;egress&lt;/em&gt; (outgoing)
traffic, and most policies set this through the following call (comment
shows the underlying SELinux rules, where &lt;em&gt;tcp_send&lt;/em&gt; and &lt;em&gt;tcp_recv&lt;/em&gt;
are - I think - obsolete):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_sendrecv_generic_if(something_t)
# allow something_t netif_t:netif { tcp_send tcp_recv egress ingress };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Node definitions define which targets (nodes, which can be IP addresses
or subnets) traffic meant for a particular socket is allow to originate
from (&lt;em&gt;recvfrom&lt;/em&gt;) or sent to (&lt;em&gt;sendto&lt;/em&gt;). Again, users can define their
own node types and manage them using &lt;strong&gt;semanage node&lt;/strong&gt;. The default node
I already covered in the previous post (&lt;code&gt;node_t&lt;/code&gt;) and is allowed by most
policies by default through the following call (where the &lt;em&gt;tcp_send&lt;/em&gt;
and &lt;em&gt;tcp_recv&lt;/em&gt; are probably deprecated as well):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_sendrecv_generic_node(something_t)
# allow something_t node_t:node { tcp_send tcp_recv sendto recvfrom };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, peer definitions are based on the labels from the traffic. If
the system uses NetLabel, then the target label will always be
&lt;code&gt;netlabel_peer_t&lt;/code&gt; since the workings of CIPSO are mainly (only?) mapped
towards sensitivity labels (in MLS policy). As a result, SELinux always
displays the peer as being &lt;code&gt;netlabel_peer_t&lt;/code&gt;. In case of Labeled IPSec,
this isn't the case as the peer label is transmitted by the peer itself.&lt;/p&gt;
&lt;p&gt;For NetLabel support, policies generally include two methods - one is to
support unlabeled traffic (only needed the moment you have support for
labeled traffic) and one is to allow the NetLabel'ed traffic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_all_recvfrom_unlabeled(something_t)
# allow something_t unlabeled_t:peer recv;
corenet_all_recvfrom_netlabel(something_t)
# allow something_t netlabel_peer_t:peer recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In case of IPSec for instance, the peer will have a provided label, as
is shown by the call for accepting hadoop traffic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;hadoop_recvfrom(something_t)
# allow something_t hadoop_t:peer recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, this alone is not sufficient for labeled IPSec. We also need to
allow the domain to be allowed to send anything towards an IPSec
security association. There is an interface called
&lt;em&gt;corenet_tcp_recvfrom_labeled&lt;/em&gt; that takes two arguments which,
amongst other things, enables &lt;em&gt;sendto&lt;/em&gt; towards its association.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_recvfrom_labeled(some_t, thing_t)
# allow { some_t thing_t} self:association sendto;
# allow some_t thing_t:peer recv;
# allow thing_t some_t:peer recv;
# corenet_tcp_recvfrom_netlabel(some_t)
# corenet_tcp_recvfrom_netlabel(thing_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This interface is usually called within a &lt;em&gt;*_tcp_connect()&lt;/em&gt; interface
for a particular domain, like with the &lt;em&gt;mysql_tcp_connect&lt;/em&gt; example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`mysql_tcp_connect&amp;#39;,`
        gen_require(`
                type mysqld_t;
        &amp;#39;)

        corenet_tcp_recvfrom_labeled($1, mysqld_t)
        corenet_tcp_sendrecv_mysqld_port($1) # deprecated
        corenet_tcp_connect_mysqld_port($1)
        corenet_sendrecv_mysqld_client_packets($1)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When using peer labeling, the domain that is allowed something is based
on the socket context of the application. Also, the rules when using
peer labeling are &lt;em&gt;in addition to&lt;/em&gt; the rules mentioned before
("standard" networking control): &lt;em&gt;name_bind&lt;/em&gt; and &lt;em&gt;name_connect&lt;/em&gt; are
always checked.&lt;/p&gt;
&lt;p&gt;For more information, make sure you check &lt;a href="http://paulmoore.livejournal.com"&gt;Paul Moore's
blog&lt;/a&gt;, such as the
&lt;a href="http://paulmoore.livejournal.com/2128.html?nojs=1"&gt;egress/ingress&lt;/a&gt;
information. And if you know of resources that show this in a more
practical setting (above is mainly to work with the SELinux policy) I'm
all ears.&lt;/p&gt;</content><category term="SELinux"></category><category term="cipso"></category><category term="ipsec"></category><category term="peer"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>SELinux policy and network controls</title><link href="https://blog.siphos.be/2013/05/selinux-policy-and-network-controls/" rel="alternate"></link><published>2013-05-11T03:50:00+02:00</published><updated>2013-05-11T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-11:/2013/05/selinux-policy-and-network-controls/</id><summary type="html">&lt;p&gt;Let's talk about how SELinux governs network streams (and how it
reflects this into the policy).&lt;/p&gt;
&lt;p&gt;When you don't do fancy stuff like SECMARK or netlabeling, then the
classes that you should keep an eye on are &lt;em&gt;tcp_socket&lt;/em&gt; and
&lt;em&gt;udp_socket&lt;/em&gt; (depending on the protocol). There used to be &lt;em&gt;node&lt;/em&gt; and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Let's talk about how SELinux governs network streams (and how it
reflects this into the policy).&lt;/p&gt;
&lt;p&gt;When you don't do fancy stuff like SECMARK or netlabeling, then the
classes that you should keep an eye on are &lt;em&gt;tcp_socket&lt;/em&gt; and
&lt;em&gt;udp_socket&lt;/em&gt; (depending on the protocol). There used to be &lt;em&gt;node&lt;/em&gt; and
&lt;em&gt;netif&lt;/em&gt; as well, but the support (enforcement) for these have been
&lt;a href="http://lists.openwall.net/netdev/2009/03/27/144"&gt;removed a while ago&lt;/a&gt;
for the "old style" network control enforcement. The concepts are still
available though, and I believe they take effect when netlabeling is
used. But let's first look at the regular networking aspects.&lt;/p&gt;
&lt;p&gt;The idea behind the regular network related permissions are that you
define either daemon-like behavior (which "binds" to a port) or
client-like behavior (which "connects" to a port). Consider an FTP
daemon (domain &lt;code&gt;ftpd_t&lt;/code&gt;) versus FTP client (example domain &lt;code&gt;ncftp_t&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In case of a daemon, the policy would contain the following (necessary)
rules:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_bind_generic_node(ftpd_t) # Somewhat legacy but still needed
corenet_tcp_bind_ftp_port(ftpd_t)
corenet_tcp_bind_ftp_data_port(ftpd_t)
corenet_tcp_bind_all_unreserved_ports(ftpd_t) # In case of passive mode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This gets translated to the following "real" SELinux statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow ftpd_t node_t:tcp_socket node_bind;
allow ftpd_t ftp_port_t:tcp_socket name_bind;
allow ftpd_t ftp_data_port_t:tcp_socket name_bind;
allow ftpd_t unreserved_port_type:tcp_socket name_bind;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I mention that &lt;em&gt;corenet_tcp_bind_generic_node&lt;/em&gt; as being somewhat
legacy. When you use netlabeling, you can define different nodes (a
"node" in that case is a label assigned to an IP address or IP subnet)
and as such define policy-wise where daemons can bind on (or clients can
connect to). However, without netlabel, the only node that you get to
work with is &lt;code&gt;node_t&lt;/code&gt; which represents any possible node. Also, the use
of passive mode within the ftp policy is governed through the
&lt;em&gt;ftpd_use_passive_mode&lt;/em&gt; boolean.&lt;/p&gt;
&lt;p&gt;For a client, the following policy line would suffice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_connect_ftp_port(ncftp_t)
# allow ncftp_t ftp_port_t:tcp_socket name_connect;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Well, I lied. Because of how FTP works, if you use active connections,
you need to allow the client to bind on an unreserved port, and allow
the server to connect to unreserved ports (cfr code snippet below), but
you get the idea.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_connect_all_unreserved_ports(ftpd_t)

corenet_tcp_bind_generic_node(ncftp_t)
corenet_tcp_bind_all_unreserved_ports(ncftp_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the past, policy developers also had to include other lines, but
these have by time become obsolete (&lt;em&gt;corenet_tcp_sendrecv_ftp_port&lt;/em&gt;
for instance). These methods defined the ability to send and receive
messages on the port, but this is no longer controlled this way. If you
need such controls, you will need to look at SELinux and SECMARK (which
uses packets with the &lt;em&gt;packet&lt;/em&gt; class) or netlabel (which uses the &lt;em&gt;peer&lt;/em&gt;
class and peer types to send or receive messages from).&lt;/p&gt;
&lt;p&gt;And that'll be for a different post.&lt;/p&gt;</content><category term="SELinux"></category><category term="networking"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>SELinux mount options</title><link href="https://blog.siphos.be/2013/05/selinux-mount-options/" rel="alternate"></link><published>2013-05-01T03:50:00+02:00</published><updated>2013-05-01T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-01:/2013/05/selinux-mount-options/</id><summary type="html">&lt;p&gt;When you read through the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml"&gt;Gentoo Hardened SELinux
handbook&lt;/a&gt;,
you'll notice that we sometimes update &lt;code&gt;/etc/fstab&lt;/code&gt; with some
SELinux-specific settings. So, what are these settings about and are
there more of them?&lt;/p&gt;
&lt;p&gt;First of all, let's look at a particular example from the installation
instructions so you see what …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When you read through the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml"&gt;Gentoo Hardened SELinux
handbook&lt;/a&gt;,
you'll notice that we sometimes update &lt;code&gt;/etc/fstab&lt;/code&gt; with some
SELinux-specific settings. So, what are these settings about and are
there more of them?&lt;/p&gt;
&lt;p&gt;First of all, let's look at a particular example from the installation
instructions so you see what I am talking about:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tmpfs  /tmp  tmpfs  defaults,noexec,nosuid,rootcontext=system_u:object_r:tmp_t  0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What the &lt;em&gt;rootcontext=&lt;/em&gt; option does here is to set the context of the
"root" of that file system (meaning, the context of &lt;code&gt;/tmp&lt;/code&gt; in the
example) to the specified context &lt;em&gt;before&lt;/em&gt; the file system is made
visible to the userspace. Because we do it soon, the file system is
known as &lt;code&gt;tmp_t&lt;/code&gt; throughout its life cycle (not just after the mount or
so).&lt;/p&gt;
&lt;p&gt;Another option that you'll frequently see on the Internet is the
&lt;em&gt;context=&lt;/em&gt; option. This option is most frequently used for file systems
that do not support extended attributes, and as such cannot store the
context of files on the file system. With the &lt;em&gt;context=&lt;/em&gt; mount option
set, all files on that file system get the specified context. For
instance, &lt;em&gt;context=system_u:object_r:removable_t&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If the file system does support extended attributes, you might find some
benefit in using the &lt;em&gt;defcontext=&lt;/em&gt; option. When set, the context of
files and directories (and other resources on that file system) that do
not have a SELinux context set yet will use this default context.
However, once a context is set, it will use that context instead.&lt;/p&gt;
&lt;p&gt;The last context-related mount option is &lt;em&gt;fscontext=&lt;/em&gt;. With this option,
you set the context of the "filesystem" class object of the file system
rather than the mount itself (or the files). Within SELinux,
"filesystem" is one of the resource classes that can get a context.
Remember the &lt;code&gt;/tmp&lt;/code&gt; mount example from before? Well, even though the
files are labeled &lt;code&gt;tmp_t&lt;/code&gt;, the file system context itself is still
&lt;code&gt;tmpfs_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is important to know that, if you use one of these mount options,
&lt;em&gt;context=&lt;/em&gt; is mutually exclusive to the other options as it "forces" the
context on all resources (including the filesystem class).&lt;/p&gt;</content><category term="SELinux"></category><category term="mount"></category><category term="selinux"></category></entry><entry><title>How logins get their SELinux user context</title><link href="https://blog.siphos.be/2013/04/how-logins-get-their-selinux-user-context/" rel="alternate"></link><published>2013-04-27T03:50:00+02:00</published><updated>2013-04-27T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-27:/2013/04/how-logins-get-their-selinux-user-context/</id><summary type="html">&lt;p&gt;Sometimes, especially when users are converting their systems to be
SELinux-enabled, their user context is wrong. An example would be when,
after logon (in permissive mode), the user is in the
&lt;code&gt;system_u:system_r:local_login_t&lt;/code&gt; domain instead of a user domain like
&lt;code&gt;staff_u:staff_r:staff_t&lt;/code&gt;.&lt;br&gt;
So, how does a login get …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Sometimes, especially when users are converting their systems to be
SELinux-enabled, their user context is wrong. An example would be when,
after logon (in permissive mode), the user is in the
&lt;code&gt;system_u:system_r:local_login_t&lt;/code&gt; domain instead of a user domain like
&lt;code&gt;staff_u:staff_r:staff_t&lt;/code&gt;.&lt;br&gt;
So, how does a login get its SELinux user context?&lt;/p&gt;
&lt;p&gt;Let's look at the entire chain of SELinux context changes across a boot.
At first, when the system boots, the kernel (and all processes invoked
from it) run in the &lt;code&gt;kernel_t&lt;/code&gt; domain (I'm going to ignore the other
context fields for now until they become relevant). When the kernel
initialization has been completed, the kernel executes the &lt;strong&gt;init&lt;/strong&gt;
binary. When you use an initramfs, then a script might be called. This
actually doesn't matter that much yet, since SELinux stays within the
&lt;code&gt;kernel_t&lt;/code&gt; domain &lt;em&gt;until&lt;/em&gt; a SELinux-aware &lt;strong&gt;init&lt;/strong&gt; is launched.&lt;/p&gt;
&lt;p&gt;When the &lt;strong&gt;init&lt;/strong&gt; binary is executed, init of course starts. But as
mentioned, init is SELinux-aware, meaning it will invoke SELinux-related
commands. One of these is that it will load the SELinux policy (as
stored in &lt;code&gt;/etc/selinux&lt;/code&gt;) and then reexecute itself. Because of that,
its process context changes from &lt;code&gt;kernel_t&lt;/code&gt; towards &lt;code&gt;init_t&lt;/code&gt;. This is
because the &lt;strong&gt;init&lt;/strong&gt; binary itself is labeled as &lt;code&gt;init_exec_t&lt;/code&gt; and a
type transition is defined from &lt;code&gt;kernel_t&lt;/code&gt; towards &lt;code&gt;init_t&lt;/code&gt; when
&lt;code&gt;init_exec_t&lt;/code&gt; is executed.&lt;/p&gt;
&lt;p&gt;Ok, so &lt;strong&gt;init&lt;/strong&gt; now runs in &lt;code&gt;init_t&lt;/code&gt; and it goes on with whatever it
needs to do. This includes invoking init scripts (which, btw, run in
&lt;code&gt;initrc_t&lt;/code&gt; because the scripts are labeled &lt;code&gt;initrc_exec_t&lt;/code&gt; or with a
type that has the &lt;code&gt;init_script_file_type&lt;/code&gt; attribute set, and a
transition from &lt;code&gt;init_t&lt;/code&gt; to &lt;code&gt;initrc_t&lt;/code&gt; is defined when such files are
executed). When the bootup is finally completed, &lt;strong&gt;init&lt;/strong&gt; launches the
&lt;em&gt;getty&lt;/em&gt; processes. The commands are mentioned in &lt;code&gt;/etc/inittab&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ grep getty /etc/inittab
c1:12345:respawn:/sbin/agetty --noclear 38400 tty1 linux
c2:2345:respawn:/sbin/agetty 38400 tty2 linux
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;These binaries are also explicitly labeled &lt;code&gt;getty_exec_t&lt;/code&gt;. As a result,
the &lt;strong&gt;getty&lt;/strong&gt; (or &lt;strong&gt;agetty&lt;/strong&gt;) processes run in the &lt;code&gt;getty_t&lt;/code&gt; domain
(because a transition is defined from &lt;code&gt;init_t&lt;/code&gt; to &lt;code&gt;getty_t&lt;/code&gt; when
&lt;code&gt;getty_exec_t&lt;/code&gt; is executed). Ok, so gettys run in &lt;code&gt;getty_t&lt;/code&gt;. But what
happens when a user now logs on to the system?&lt;/p&gt;
&lt;p&gt;Well, the getty's invoke the &lt;strong&gt;login&lt;/strong&gt; binary which, you guessed it
right, is labeled as something: &lt;code&gt;login_exec_t&lt;/code&gt;. As a result (because,
again, a transition is defined in the policy), the login process runs as
&lt;code&gt;local_login_t&lt;/code&gt;. Now the login process invokes the various PAM
subroutines which follow the definitions in &lt;code&gt;/etc/pam.d/login&lt;/code&gt;. On
Gentoo systems, this by default points to the &lt;code&gt;system-local-login&lt;/code&gt;
definitions which points to the &lt;code&gt;system-login&lt;/code&gt; definitions. And in this
definition, especially under the sessions section, we find a reference
to &lt;code&gt;pam_selinux.so&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;session         required        pam_selinux.so close
...
session         required        pam_selinux.so multiple open
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now here is where some of the magic starts (see my post on &lt;a href="http://blog.siphos.be/2012/12/using-pam_selinux-to-switch-contexts/"&gt;Using
pam_selinux to switch
contexts&lt;/a&gt;
for the gritty details). The methods inside the &lt;code&gt;pam_selinux.so&lt;/code&gt; binary
will look up what the context should be for a user login. For instance,
when the &lt;em&gt;root&lt;/em&gt; user logs on, it has SELinux checking what SELinux user
&lt;em&gt;root&lt;/em&gt; is mapped to, equivalent to running &lt;strong&gt;semanage login -l&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ semanage login -l | grep ^root
root                      root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this case, the SELinux user for root is &lt;em&gt;root&lt;/em&gt;, but this is not
always the case (that login and user are the same). For instance, my
regular administrative account maps to the &lt;em&gt;staff_u&lt;/em&gt; SELinux user.&lt;/p&gt;
&lt;p&gt;Next, it checks what the default context should be for this user. This
is done by checking the &lt;code&gt;default_contexts&lt;/code&gt; file (such as the one in
&lt;code&gt;/etc/selinux/strict/contexts&lt;/code&gt; although user-specific overrides can be
(and are) placed in the &lt;code&gt;users&lt;/code&gt; subdirectory) based on the context of
the process that is asking SELinux what the default context should be.
In our case, it is the &lt;strong&gt;login&lt;/strong&gt; process running as &lt;code&gt;local_login_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ grep -HR local_login_t /etc/selinux/strict/contexts/*
default_contexts:system_r:local_login_t user_r:user_t staff_r:staff_t sysadm_r:sysadm_t unconfined_r:unconfined_t
users/unconfined_u:system_r:local_login_t               unconfined_r:unconfined_t
users/guest_u:system_r:local_login_t            guest_r:guest_t
users/user_u:system_r:local_login_t             user_r:user_t
users/staff_u:system_r:local_login_t            staff_r:staff_t sysadm_r:sysadm_t
users/root:system_r:local_login_t  unconfined_r:unconfined_t sysadm_r:sysadm_t staff_r:staff_t user_r:user_t
users/xguest_u:system_r:local_login_t   xguest_r:xguest_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since we are verifying this for the &lt;em&gt;root&lt;/em&gt; SELinux user, the following
line of the &lt;code&gt;users/root&lt;/code&gt; file is what matters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system_r:local_login_t  unconfined_r:unconfined_t sysadm_r:sysadm_t staff_r:staff_t user_r:user_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, SELinux looks for the first match in that line that the user has
access to. This is defined by the roles that the user is allowed to
access:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ semanage user -l | grep root
root            staff_r sysadm_r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As &lt;em&gt;root&lt;/em&gt; is allowed both the &lt;em&gt;staff_r&lt;/em&gt; and &lt;em&gt;sysadm_r&lt;/em&gt; roles, the
first one found &lt;em&gt;in the default context file&lt;/em&gt; that matches will be used.
So it is &lt;em&gt;not&lt;/em&gt; the order in which the roles are displayed in the
&lt;strong&gt;semanage user -l&lt;/strong&gt; output that matters, but the order of the contexts
in the &lt;em&gt;default context&lt;/em&gt; file. In the example, this is
&lt;code&gt;sysadm_r:sysadm_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system_r:local_login_t  unconfined_r:unconfined_t sysadm_r:sysadm_t staff_r:staff_t user_r:user_t
                        &amp;lt;-----------+-----------&amp;gt; &amp;lt;-------+-------&amp;gt; &amp;lt;------+------&amp;gt; &amp;lt;-----+-----&amp;gt;
                                    `- no matching role   `- first (!)     `- second      `- no match
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now that we know what the context &lt;em&gt;should&lt;/em&gt; be, this is used for the
first execution that the process (still &lt;strong&gt;login&lt;/strong&gt;) will do. So &lt;strong&gt;login&lt;/strong&gt;
changes the Linux user (if applicable) and invokes the shell of that
user. Because this is the first execution that is done by &lt;strong&gt;login&lt;/strong&gt;, the
new context is set (being &lt;code&gt;root:sysadm_r:sysadm_t&lt;/code&gt;) for the shell.&lt;/p&gt;
&lt;p&gt;And that is why, if you run &lt;strong&gt;id -Z&lt;/strong&gt;, it returns the user context
(&lt;code&gt;root:sysadm_r:sysadm_t&lt;/code&gt;) if everything works out fine ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="context"></category><category term="selinux"></category><category term="user"></category></entry><entry><title>Using strace to troubleshoot SELinux problems</title><link href="https://blog.siphos.be/2013/04/using-strace-to-troubleshoot-selinux-problems/" rel="alternate"></link><published>2013-04-24T03:50:00+02:00</published><updated>2013-04-24T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-24:/2013/04/using-strace-to-troubleshoot-selinux-problems/</id><summary type="html">&lt;p&gt;When SELinux is playing tricks on you, you can just "allow" whatever it
wants to do, but that is not always an option: sometimes, there is no
denial in sight because the problem lays within SELinux-aware
applications (applications that might change their behavior based on
what the policy sais or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When SELinux is playing tricks on you, you can just "allow" whatever it
wants to do, but that is not always an option: sometimes, there is no
denial in sight because the problem lays within SELinux-aware
applications (applications that might change their behavior based on
what the policy sais or even based on if SELinux is enabled or not). At
other times, you get a strange behavior that isn't directly visible what
the cause is. But mainly, if you want to make sure that allowing
something is correct (and not just a corrective action), you need to be
absolutely certain that what you want to allow is security-wise
acceptable.&lt;/p&gt;
&lt;p&gt;To debug such issues, I often take the &lt;strong&gt;strace&lt;/strong&gt; command to debug the
application at hand. To use &lt;strong&gt;strace&lt;/strong&gt;, I toggle the &lt;em&gt;allow_ptrace&lt;/em&gt;
boolean (&lt;strong&gt;strace&lt;/strong&gt; uses &lt;code&gt;ptrace()&lt;/code&gt; which, by default, isn't allowed
policy-wise) and then run the offending application through &lt;strong&gt;strace&lt;/strong&gt;
(or attach to the running process if it is a daemon). For instance, to
debug a &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=463222"&gt;tmux issue&lt;/a&gt; we
had with the policy not that long ago:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# setsebool allow_ptrace on
# strace -o strace.log -f -s 256 tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The resulting log file (strace.log) might seem daunting at first to look
at. What you see are the system calls that the process is performing,
together with their options but also the return code of each call. This
is especially important as SELinux, if it denies something, often
returns something like EACCESS (Permission Denied).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;7313  futex(0x349e016f080, FUTEX_WAKE_PRIVATE, 2147483647) = 0
7313  futex(0x5aad58fd84, FUTEX_WAKE_PRIVATE, 2147483647) = 0
7313  stat(&amp;quot;/&amp;quot;, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7313  stat(&amp;quot;/home&amp;quot;, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7313  stat(&amp;quot;/home/swift&amp;quot;, {st_mode=S_IFDIR|0755, st_size=12288, ...}) = 0
7313  stat(&amp;quot;/home/swift/.pki&amp;quot;, {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7313  stat(&amp;quot;/home/swift/.pki/nssdb&amp;quot;, {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7313  statfs(&amp;quot;/home/swift/.pki/nssdb&amp;quot;, 0x3c3cab6fa50) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Most (if not all) of the methods shown in a strace log are documented
through manpages, so you can quickly find out that &lt;code&gt;futex()&lt;/code&gt; is about
fast user-space locking, &lt;code&gt;stat()&lt;/code&gt; (&lt;strong&gt;man 2 stat&lt;/strong&gt; to see the information
about the method instead of the application) is about getting file
status and &lt;code&gt;statfs()&lt;/code&gt; is for getting file system statistics.&lt;/p&gt;
&lt;p&gt;The most common permission issues you'll find are file related:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;7313  open(&amp;quot;/proc/filesystems&amp;quot;, O_RDONLY) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above case, you notice that the application is trying to open the
&lt;code&gt;/proc/filesystems&lt;/code&gt; file read-only. In the SELinux logs, this might be
displayed as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;audit.log:type=AVC msg=audit(1365794728.180:3192): avc:  denied  { read } for  
pid=860 comm=&amp;quot;nacl_helper_boo&amp;quot; name=&amp;quot;filesystems&amp;quot; dev=&amp;quot;proc&amp;quot; ino=4026532034 
scontext=staff_u:staff_r:chromium_naclhelper_t tcontext=system_u:object_r:proc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the case of &lt;strong&gt;tmux&lt;/strong&gt; before was not an obvious one. In the end, I
compared the strace output's of two runs (one in enforcing and one in
permissive) to find what the difference would be. This is the result:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Enforcing:

10905 fcntl(9, F_GETFL) = 0x8000 (flags O_RDONLY|O_LARGEFILE) 
10905 fcntl(9, F_SETFL, O_RDONLY|O_NONBLOCK|O_LARGEFILE) = 0

Permissive:

10905 fcntl(9, F_GETFL) = 0x8002 (flags O_RDWR|O_LARGEFILE) 
10905 fcntl(9, F_SETFL, O_RDWR|O_NONBLOCK|O_LARGEFILE) = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You notice the difference? In enforcing-mode, one of the flags on the
file descriptor has &lt;code&gt;O_RDONLY&lt;/code&gt; whereas the one in permissive mode as
&lt;code&gt;O_RDWR&lt;/code&gt;. This means that the file descriptor in enforcing mode is
read-only whereas in permissive-mode is read-write. What we then do in
the strace logs is to see where this file descriptor (with id=9) comes
from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;10905 dup(0)     = 9
10905 dup(1)     = 10
10905 dup(2)     = 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As the man-pages sais, &lt;code&gt;dup()&lt;/code&gt; duplicates a file descriptor. And
because, by convention, the first three file descriptors of an
application correspond with standard input (0), standard output (1) and
error output (2), we now know that the file descriptor with id=9 comes
from the standard input file descriptor. Although this one should be
read-only (it is the input that the application gets = reads), it seems
that tmux might want to use this for writes as well. And that is what
happens - tmux sends the file descriptor to the tmux server to check if
it is a tty and then uses it to write to the screen.&lt;/p&gt;
&lt;p&gt;Now what does that have to do with SELinux? It has to mean something,
otherwise running in permissive mode would give the same result. After
some investigation, we found out that using &lt;strong&gt;newrole&lt;/strong&gt; to switch roles
changes the flags of the standard input (as then provided by
&lt;strong&gt;newrole&lt;/strong&gt;) from &lt;code&gt;O_RDWR&lt;/code&gt; to &lt;code&gt;O_RDONLY&lt;/code&gt; (code snippet from &lt;code&gt;newrole.c&lt;/code&gt;
- look at the first call to &lt;code&gt;open()&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/* Close the tty and reopen descriptors 0 through 2 */
if (ttyn) {
        if (close(fd) || close(0) || close(1) || close(2)) {
                fprintf(stderr, _(&amp;quot;Could not close descriptors.\n&amp;quot;));
                goto err_close_pam;
        }
        fd = open(ttyn, O_RDONLY | O_NONBLOCK);
        if (fd != 0)
                goto err_close_pam;
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) &amp;amp; ~O_NONBLOCK);
        fd = open(ttyn, O_RDWR | O_NONBLOCK);
        if (fd != 1)
                goto err_close_pam;
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) &amp;amp; ~O_NONBLOCK);
        fd = open(ttyn, O_RDWR | O_NONBLOCK);
        if (fd != 2)
                goto err_close_pam;
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) &amp;amp; ~O_NONBLOCK);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Such obscure problems are much easier to detect and troubleshoot thanks
to tools like &lt;strong&gt;strace&lt;/strong&gt;.&lt;/p&gt;</content><category term="SELinux"></category><category term="debug"></category><category term="selinux"></category><category term="strace"></category></entry><entry><title>SELinux tutorial series, update</title><link href="https://blog.siphos.be/2013/03/selinux-tutorial-series-update/" rel="alternate"></link><published>2013-03-18T23:22:00+01:00</published><updated>2013-03-18T23:22:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-03-18:/2013/03/selinux-tutorial-series-update/</id><summary type="html">&lt;p&gt;Just a small update - the &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials"&gt;set of SELinux
tutorials&lt;/a&gt; has been
enhanced since my last blog post about it with information on SELinux
booleans, customizable types, run-time modi (enforcing versus
permissive), some bits about unconfined domains, information on policy
loading, purpose of SELinux roles, SELinux users and an example on …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Just a small update - the &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials"&gt;set of SELinux
tutorials&lt;/a&gt; has been
enhanced since my last blog post about it with information on SELinux
booleans, customizable types, run-time modi (enforcing versus
permissive), some bits about unconfined domains, information on policy
loading, purpose of SELinux roles, SELinux users and an example on how a
policy works regarding init scripts.&lt;/p&gt;
&lt;p&gt;The near future will give more information about the multi-level
security aspect, about multi-category support, a review on the SELinux
context (as we then have handled each field in the context string) and
i'll also start with the second series that focuses more on policy
enhancements and policy building.&lt;/p&gt;
&lt;p&gt;And probably a few dozen more. Happy reading!&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux tutorial series</title><link href="https://blog.siphos.be/2013/03/selinux-tutorial-series/" rel="alternate"></link><published>2013-03-15T00:34:00+01:00</published><updated>2013-03-15T00:34:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-03-15:/2013/03/selinux-tutorial-series/</id><summary type="html">&lt;p&gt;As we get a growing number of SELinux users within Gentoo Hardened and
because the SELinux usage at the firm I work at is most likely going to
grow as well, I decided to join the bunch of documents on SELinux that
are "out there" and start a series of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As we get a growing number of SELinux users within Gentoo Hardened and
because the SELinux usage at the firm I work at is most likely going to
grow as well, I decided to join the bunch of documents on SELinux that
are "out there" and start a series of my own. After all, too much
documentation probably doesn't hurt, and SELinux definitely deserves a
lot of documentation.&lt;/p&gt;
&lt;p&gt;I decided to use the &lt;a href="https://wiki.gentoo.org"&gt;Gentoo Wiki&lt;/a&gt; for this
endeavour instead of a GuideXML approach (which is the format used for
Gentoo documentation on the main site). The set of tutorials that I
already wrote can be found under the
&lt;a href="https://wiki.gentoo.org/wiki/SELinux"&gt;SELinux&lt;/a&gt; : &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials"&gt;Gentoo Hardened
SELinux Tutorials&lt;/a&gt;
location. Although of course meant to support the Gentoo Hardened
SELinux users, I'm hoping to keep the initial set of tutorial articles
deliberately distribution-independent so I can refer to them at work as
well.&lt;/p&gt;
&lt;p&gt;For now (this is a week's work, so don't expect this amount of tutorials
to double in the next few days) I wrote about the security context of a
process, how SELinux controls file and directory accesses, where to find
SELinux permission denial details, controlling file contexts yourself
and how a process gets into a certain context.&lt;/p&gt;
&lt;p&gt;I hope I can keep the articles in good shape and with a gradual step-up
in complexity. That does mean that most articles are not complete (for
instance, when talking about domain transitions, I don't talk about
constraints that might prohibit them, or about the role and type
mismatches (invalid context) that you might get, etc.) and that those
details will follow in later articles. Hopefully that allows users to
learn step by step.&lt;/p&gt;
&lt;p&gt;At the end of each tutorial, you will find a "What you need to remember"
section. This is a very short overview of what was said in the tutorial
and that you will need to know in future articles. If you ever read a
tutorial article, then this section might be sufficient for you to
remember again what it was about - no need to reread the entire article.&lt;/p&gt;
&lt;p&gt;Consider it an attempt at a &lt;code&gt;tl;dr&lt;/code&gt; for articles ;-) Enjoy your reading,
and if you have any remarks, don't hesitate to contribute on the wiki or
talk through the "Talk" pages.&lt;/p&gt;</content><category term="SELinux"></category><category term="articles"></category><category term="documentation"></category><category term="Gentoo"></category><category term="hardened"></category><category term="selinux"></category><category term="tutorials"></category><category term="wiki"></category></entry><entry><title>Using pam_selinux to switch contexts</title><link href="https://blog.siphos.be/2012/12/using-pam_selinux-to-switch-contexts/" rel="alternate"></link><published>2012-12-10T22:11:00+01:00</published><updated>2012-12-10T22:11:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2012-12-10:/2012/12/using-pam_selinux-to-switch-contexts/</id><summary type="html">&lt;p&gt;With SELinux managing the access controls of applications towards the
resources on the system, a not-to-be forgotten important component on
any Unix/Linux system is the authentication part. Most systems use or
support PAM, the &lt;em&gt;Pluggable Authentication Modules&lt;/em&gt;, and for SELinux
this plays an important role.&lt;/p&gt;
&lt;p&gt;Applications that are PAM-enabled …&lt;/p&gt;</summary><content type="html">&lt;p&gt;With SELinux managing the access controls of applications towards the
resources on the system, a not-to-be forgotten important component on
any Unix/Linux system is the authentication part. Most systems use or
support PAM, the &lt;em&gt;Pluggable Authentication Modules&lt;/em&gt;, and for SELinux
this plays an important role.&lt;/p&gt;
&lt;p&gt;Applications that are PAM-enabled use PAM for the authentication of user
activities. If this includes setting up an authenticated session, then
the "session" part of the PAM configuration is also handled. And for
SELinux, this is a nice-to-have, since this means applications that are
not SELinux-aware can still enjoy transitions towards specified domains
depending on the user that is authenticated.&lt;/p&gt;
&lt;p&gt;The "not SELinux-aware" here is important. By default, applications keep
running in one security context for their lifetime. If they invoke a
&lt;code&gt;execve&lt;/code&gt; or similar call (which is used to start another application or
command when used in combination with a &lt;code&gt;fork&lt;/code&gt;), then the SELinux policy
&lt;em&gt;might&lt;/em&gt; trigger an automatic transition if the holy grail of fourfold
rules is set:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a transition from the current context to the new one is allowed&lt;/li&gt;
&lt;li&gt;the label of the executed command/label is marked as an entrypoint
    for the new context&lt;/li&gt;
&lt;li&gt;the current context is allowed to execute that application&lt;/li&gt;
&lt;li&gt;an automatic transition rule is made from the current context to the
    new one over the command label&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Or, in SELinux policy terms, assuming the domains are &lt;code&gt;source_t&lt;/code&gt; and
&lt;code&gt;destination_t&lt;/code&gt; with the label of the executed file being &lt;code&gt;file_exec_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow source_t destination_t:process transition;
allow destination_t file_exec_t:file entrypoint;
allow source_t file_exec_t:file execute;
type_transition source_t file_exec_t : process destination_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If those four settings are valid, then (and only then) can the automatic
transition be active.&lt;/p&gt;
&lt;p&gt;Sadly, for applications that run user actions (like cron systems, remote
logon services and more) this is not sufficient, since there are two
major downsides to this "flexibility":&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The rules to transition are static and do not depend on the identity
    of the user for which activities are launched. The policy can not
    deduce this identity from a file context either.&lt;/li&gt;
&lt;li&gt;The policy is statically defined: different transitions based on
    different user identities are not possibel.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To overcome this problem, applications can be made SELinux-aware,
linking with the libselinux library and invoking the necessary switches
themselves (or running the commands with &lt;code&gt;runcon&lt;/code&gt;). Luckily, this is
where the PAM system comes to play to aide us in setting up this policy
behavior.&lt;/p&gt;
&lt;p&gt;When an application is PAM-enabled, it will invoke PAM calls to
authenticate and possibly set up the user session. The actions that PAM
invokes are defined by the PAM configuration files. For instance, for
the at daemon:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## /etc/pam.d/atd
#
# The PAM configuration file for the at daemon
#

auth    required        pam_env.so
auth    include         system-services
account include         system-services
session include         system-services
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I am not going to dive into the details of PAM in this blog post, so
let's just jump to the session management part. In the above example
file, if PAM sets up (or shuts down) a user session for the service (at
in our case), it will go through the PAM services that are listed in the
&lt;em&gt;system-services&lt;/em&gt; definition, which looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## /etc/pam.d/system-services
auth            sufficient      pam_permit.so
account         include         system-auth
session         optional        pam_loginuid.so
session         required        pam_limits.so 
session         required        pam_env.so 
session         required        pam_unix.so 
session         optional        pam_permit.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Until now, nothing SELinux-specific is enabled. But if we change the
session section of the at service to the following, then the SELinux pam
module will be called as well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;session optional        pam_selinux.so close
session include         system-services
session optional        pam_selinux.so multiple open
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now that the SELinux module is called, pam_selinux will try to switch
the context of the process based on the definitions in the
/etc/selinux/strict/contexts location (substitute strict with the policy
type you use). The outcome of this switching can be checked with the
&lt;strong&gt;getseuser&lt;/strong&gt; application:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# getseuser root system_u:system_r:crond_t
seuser:  root, level (null)
Context 0       root:sysadm_r:cronjob_t
Context 1       root:staff_r:cronjob_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By providing the contexts in configurable files in
/etc/selinux/strict/contexts, a non-SELinux aware application suddenly
becomes SELinux-aware (through the PAM support it already has) without
needing to patch or even rebuild the application. All that is need is to
allow the security context of the application to switch ids and roles
(as that is by default not allowed), which I believe is offered through
the following statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;domain_subj_id_change_exemption(atd_t)
domain_role_change_exemption(atd_t)

selinux_validate_context(atd_t)
selinux_compute_access_vector(atd_t)
selinux_compute_create_context(atd_t)
selinux_compute_relabel_context(atd_t)
selinux_compute_user_contexts(atd_t)

seutil_read_config(atd_t)
seutil_read_default_contexts(atd_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category></entry><entry><title>Local policy management script</title><link href="https://blog.siphos.be/2012/11/local-policy-management-script/" rel="alternate"></link><published>2012-11-11T13:37:00+01:00</published><updated>2012-11-11T13:37:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2012-11-11:/2012/11/local-policy-management-script/</id><summary type="html">&lt;p&gt;I've written a small script that I call &lt;strong&gt;selocal&lt;/strong&gt; which manages
locally needed SELinux rules. It allows me to add or remove SELinux
rules from the command line and have them loaded up without needing to
edit a .te file and building the .pp file manually. If you are
interested …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've written a small script that I call &lt;strong&gt;selocal&lt;/strong&gt; which manages
locally needed SELinux rules. It allows me to add or remove SELinux
rules from the command line and have them loaded up without needing to
edit a .te file and building the .pp file manually. If you are
interested, you can download it from my &lt;a href="https://raw.github.com/sjvermeu/small.coding/master/se_scripts/selocal"&gt;github
location&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Its usage is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can &lt;em&gt;add&lt;/em&gt; a rule to the policy with &lt;strong&gt;selocal -a "rule"&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;You can &lt;em&gt;list&lt;/em&gt; the current rules with &lt;strong&gt;selocal -l&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;You can &lt;em&gt;remove&lt;/em&gt; entries by referring to their number (in the
    listing output), like &lt;strong&gt;semodule -d 19&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;You can ask it to build (&lt;strong&gt;-b&lt;/strong&gt;) and load (&lt;strong&gt;-L&lt;/strong&gt;) the policy when
    you think it is appropriate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It even supports multiple modules in case you don't want to have all
local rules in a single module set.&lt;/p&gt;
&lt;p&gt;So when I wanted to give a presentation on Tor, I had to allow the
torbrowser to connect to an unreserved port. The torbrowser runs in the
mozilla domain, so all I did was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# selocal -a &amp;quot;corenet_tcp_connect_all_unreserved_ports(mozilla_t)&amp;quot; -b -L
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At the end of the presentation, I removed the line from the policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# selocal -l | grep mozilla_t
19. corenet_tcp_connect_all_unreserved_ports(mozilla_t)
~# selocal -d 19 -b -L
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I can also add in comments in case I would forget why I added it in the
first place:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# selocal -a &amp;quot;allow mplayer_t self:udp_socket create_socket_perms;&amp;quot;   
 -c &amp;quot;MPlayer plays HTTP resources&amp;quot; -b -L
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This then also comes up when listing the current local policy rules:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# selocal -l
...
40: allow mplayer_t self:udp_socket create_socket_perms; # MPlayer plays HTTP resources
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category></entry><entry><title>Lots of work on supporting swig-2</title><link href="https://blog.siphos.be/2012/08/lots-of-work-on-supporting-swig-2/" rel="alternate"></link><published>2012-08-20T20:50:00+02:00</published><updated>2012-08-20T20:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2012-08-20:/2012/08/lots-of-work-on-supporting-swig-2/</id><summary type="html">&lt;p&gt;The SELinux &lt;a href="http://oss.tresys.com/projects/setools/"&gt;setools&lt;/a&gt;
&lt;a href="http://packages.gentoo.org/package/app-admin/setools"&gt;package&lt;/a&gt; provides
a few of the commands I used the most when working with SELinux:
&lt;strong&gt;sesearch&lt;/strong&gt; for looking through the policy and &lt;strong&gt;seinfo&lt;/strong&gt; to get
information on type/attribute/role/... from the currently loaded policy.&lt;/p&gt;
&lt;p&gt;This package uses &lt;a href="http://www.swig.org/"&gt;swig&lt;/a&gt;, the Simplified (sic)
Wrapper and Interface Generator to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The SELinux &lt;a href="http://oss.tresys.com/projects/setools/"&gt;setools&lt;/a&gt;
&lt;a href="http://packages.gentoo.org/package/app-admin/setools"&gt;package&lt;/a&gt; provides
a few of the commands I used the most when working with SELinux:
&lt;strong&gt;sesearch&lt;/strong&gt; for looking through the policy and &lt;strong&gt;seinfo&lt;/strong&gt; to get
information on type/attribute/role/... from the currently loaded policy.&lt;/p&gt;
&lt;p&gt;This package uses &lt;a href="http://www.swig.org/"&gt;swig&lt;/a&gt;, the Simplified (sic)
Wrapper and Interface Generator to provide libraries that can be loaded
by Python and used as regular Python modules, based on the C code that
setools uses. Or, in other words: you write C code, and swig transforms
it into libraries that can be loaded by a dozen higher generation
languages such as Python.&lt;/p&gt;
&lt;p&gt;The change from swig-1 to swig-2 however broke the setools build. It
seems that the swig interface code that setools uses doesn't work
properly anymore with more recent swig versions. The last few days (yes,
days) I have been trying to get setools to build again. The fixes that I
put in were not extremely difficult, but very labour-intensive (beyond
the point that I think I'm doing things wrong, but hey - this is my
first time I'm working on swig stuff, and I'm glad I already got it to
build again).&lt;/p&gt;
&lt;p&gt;The first thing I had to do was fix constructor/destructor logic. It
looks like swig-1 supported the C shorthand notation for structures
whereas swig-2 sees the name of the structure as its class (note that I
just got it to build, I still need to see if things still work):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  typedef struct apol_ip {...} apol_ip_t;
  %extend apol_ip_t {
-   apol_ip_t(const char * str) {
+   apol_ip(const char * str) {
  ...
-   ~apol_ip_t() {
+   ~apol_ip() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Without this, I got "Illegal destructor" errors (not related to the
illegal destructor fix made to swig itself) and "Method apol_ip_t
requires a return type" (because it doesn't see them as constructors).&lt;/p&gt;
&lt;p&gt;The second fix I had to introduce was to rename all functions that swig
would generate which would then have the same name as the C-function.
For instance, suppose a C function in the code has
&lt;code&gt;apol_vector_get_size&lt;/code&gt; then swig would, for the &lt;code&gt;apol_vector&lt;/code&gt; class with
method &lt;code&gt;get_size&lt;/code&gt; in the swig interface, generate a function called
&lt;code&gt;apol_vector_get_size&lt;/code&gt; which of course collides with the already defined
function, giving an error like "Conflicting types for
apol_vector_get_size" followed by a "previous declaration was here:".&lt;/p&gt;
&lt;p&gt;Swig supports the &lt;code&gt;%rename&lt;/code&gt; method for this, so I had to do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  typedef struct apol_vector {} apol_vector_t;
+ %rename(apol_vector_get_size) apol_vector_wrap_get_size;
+ %rename(apol_vector_get_capacity) apol_vector_wrap_get_capacity;
...
- size_t get_size() {
+ size_t wrap_get_size() {
...
- size_t get_capacity() {
+ size_t wrap_get_capacity() {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The patch that I had to add to finally get it to build again is 7019
lines (229 Kbyte). Too much manual labour. Now let's hope this really
fixes things, and doesn't just masquerade the build failures but
introduces runtime failures. Of course, if I think it works, I'll send
it upstream so that, if it is indeed the right fix, other developers
don't have to go through this...&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Dynamic transitions in SELinux</title><link href="https://blog.siphos.be/2012/07/dynamic-transitions-in-selinux/" rel="alternate"></link><published>2012-07-22T21:11:00+02:00</published><updated>2012-07-22T21:11:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2012-07-22:/2012/07/dynamic-transitions-in-selinux/</id><summary type="html">&lt;p&gt;In between talks on heap spraying techniques and visualization of data
for fast analysis, I'm working on integrating the chromium SELinux
policy that was offered in bug &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=412637"&gt;bug
#412637&lt;/a&gt; within Gentoo
Hardened. If you take a look at the bug, you notice I'm not really fond
of the policy because …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In between talks on heap spraying techniques and visualization of data
for fast analysis, I'm working on integrating the chromium SELinux
policy that was offered in bug &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=412637"&gt;bug
#412637&lt;/a&gt; within Gentoo
Hardened. If you take a look at the bug, you notice I'm not really fond
of the policy because it uses &lt;em&gt;dynamic transitions&lt;/em&gt;. That's not
something the policy writer can do anything about if he can't access the
source code of the application though, since it means that the
application is SELinux aware and will trigger transitions when needed.&lt;/p&gt;
&lt;p&gt;So what's this dynamic transitioning? Well, in short, it means that a
process can decide to switch domains whenever it pleases (hence the
dynamic part) instead of doing this on fork/exec's. Generally, that
sounds like a flexible feature - and it is. But it's also dangerous.&lt;/p&gt;
&lt;p&gt;Dynamic transitions might seem like a way to enhance security - the
application knows it will start a "dangerous" or more risky piece of
code, and thus transitions towards another domain with less privileges.
Once the dangerous code is passed, it transitions back to the main
domain. The problem with this is that the entire process is still live -
anything that happened within the transitioned domain remains, and
SELinux cannot prevent what happens within the domain itself (like
memory accesses within the same process space). If the more risky code
resulted in corruption or modification of memory, this remains
regardless of the SELinux context transitioning back or not. Assume that
some code is "injected" in the transitioned domain (which isn't allowed
to execute other applications) the moment it transitions back to the
main domain which is allowed to execute applications, this injected code
can become active and do its thing.&lt;/p&gt;
&lt;p&gt;This is why I didn't allow the original code (which ran chromium in the
main user domain and used dynamic transitions towards
&lt;code&gt;chromium_renderer_t&lt;/code&gt;) to be used, asking to confine the browser itself
within its own domain too (&lt;code&gt;chromium_t&lt;/code&gt;) so that we have a more clear
view on the allowed privileges (which is the set of the chromium domain
and the renderer domain together). It is that policy that I'm now
enhancing to work on a fully confined system (no unconfined domains).&lt;/p&gt;
&lt;p&gt;If you want to know more about dynamic transitions, it seems that the
blog post &lt;a href="http://beyondabstraction.net/2005/11/07/subject-object-tranquility-part-2/"&gt;Subject &amp;amp; Object Tranquility, part
2&lt;/a&gt;
(and don't forget to read the comments too) is a fine read.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Transitioning to MCS policies</title><link href="https://blog.siphos.be/2012/02/transitioning-to-mcs-policies/" rel="alternate"></link><published>2012-02-24T22:12:00+01:00</published><updated>2012-02-24T22:12:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2012-02-24:/2012/02/transitioning-to-mcs-policies/</id><summary type="html">&lt;p&gt;Since I started maintaining the &lt;a href="http://hardened.gentoo.org/selinux"&gt;SELinux
policies&lt;/a&gt; for &lt;a href="http://hardened.gentoo.org"&gt;Gentoo
Hardened&lt;/a&gt;, the policy types we supported
were primarily &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;targeted&lt;/code&gt;. About half a year ago, we also
started supported &lt;code&gt;mcs&lt;/code&gt; and offered the possibility for using &lt;code&gt;mls&lt;/code&gt; as
well (but didn't really support that one).&lt;/p&gt;
&lt;p&gt;With the recent release of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Since I started maintaining the &lt;a href="http://hardened.gentoo.org/selinux"&gt;SELinux
policies&lt;/a&gt; for &lt;a href="http://hardened.gentoo.org"&gt;Gentoo
Hardened&lt;/a&gt;, the policy types we supported
were primarily &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;targeted&lt;/code&gt;. About half a year ago, we also
started supported &lt;code&gt;mcs&lt;/code&gt; and offered the possibility for using &lt;code&gt;mls&lt;/code&gt; as
well (but didn't really support that one).&lt;/p&gt;
&lt;p&gt;With the recent release of the newer userspace utilities, we found out
that Gentoo Hardened is one of the few distributions that still really
supports policy types without levels (MCS and MLS have support for
levels, strict and targeted don't) as libsemanage had a failure when
running simple activities on a system without level support. The fix is
fairly trivial, but it does gave me the signal to start moving towards
MCS.&lt;/p&gt;
&lt;p&gt;So, now that the new userspace utilities are in the hardened-dev overlay
(please test them ;-) I will now focus on the 2.20120215 policy release,
getting that in good shape (forward-porting the patches that haven't
made it to the refpolicy repository yet) and then see how we can
transition users from strict or targeted to MCS (documentation, upgrade
guide and software or packages when needed) so that we are up to par
with the majority of other distributions.&lt;/p&gt;
&lt;p&gt;I personally like the strict policy type as it is fairly simple to
explain to users, but I'm sure I can deal with MCS and (in the future)
MLS equally well ;-)&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Trying out initramfs with selinux and grsec</title><link href="https://blog.siphos.be/2012/01/trying-out-initramfs-with-selinux-and-grsec/" rel="alternate"></link><published>2012-01-15T12:58:00+01:00</published><updated>2012-01-15T12:58:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2012-01-15:/2012/01/trying-out-initramfs-with-selinux-and-grsec/</id><summary type="html">&lt;p&gt;I'm no fan of initramfs. All my systems boot up just fine without it, so
I often see it as an additional layer of obfuscation. But there are
definitely cases where initramfs is needed, and from the &lt;a href="http://thread.gmane.org/gmane.linux.gentoo.devel/74464"&gt;looks of
it&lt;/a&gt;, we might be
needing to push out some documentation and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm no fan of initramfs. All my systems boot up just fine without it, so
I often see it as an additional layer of obfuscation. But there are
definitely cases where initramfs is needed, and from the &lt;a href="http://thread.gmane.org/gmane.linux.gentoo.devel/74464"&gt;looks of
it&lt;/a&gt;, we might be
needing to push out some documentation and support for initramfs. Since
my primary focus is to look at a hardened system, I started playing with
initramfs together with Gentoo Hardened, grSecurity and SELinux. And
what a challenge it was...&lt;/p&gt;
&lt;p&gt;But first, a quick introduction to initramfs. The Linux kernel supports
&lt;em&gt;initrd&lt;/em&gt; images for quite some time. These images are best seen as
loopback-mountable images containing a whole file system that the Linux
kernel boots as the root device. On this initrd image, a set of tools
and scripts then prepare the system and finally switch towards the real
root device. The initrd feature was often used when the root device is a
network-mounted location or on a file system that requires additional
activities (like an encrypted file system or even on LVM. But it also
had some difficulties with it.&lt;/p&gt;
&lt;p&gt;Using a loopback-mountable image means that this is seen as a full
device (with file system on it), so the Linux kernel also tries caching
the files on it, which leads to some unwanted memory consumption. It is
a static environment, so it is hard to grow or shrink it. Every time an
administrator creates an initrd, he needs to carefully design
(capacity-wise) the environment not to request too much or too little
memory.&lt;/p&gt;
&lt;p&gt;Enter &lt;em&gt;initramfs&lt;/em&gt;. The concept is similar: an environment that the Linux
kernel boots as a root device which is used to prepare for booting
further from the real root file systems. But it uses a different
approach. First of all, it is no longer a loopback-mountable image, but
a cpio archive that is used on a tmpfs file system. Unlike initrd, tmpfs
can grow or shrink as necessary, so the administrator doesn't need to
plan the capacity of the image. And because it is a tmpfs file system,
the Linux kernel doesn't try to cache the files in memory (as it knows
they already are in memory).&lt;/p&gt;
&lt;p&gt;There are undoubtedly more advantages to initramfs, but let's stick to
the primary objective of this post: talk about its implementation on a
hardened system.&lt;/p&gt;
&lt;p&gt;I started playing with &lt;strong&gt;dracut&lt;/strong&gt;, a tool to create initramfs archives
which is seen as a widely popular implementation (and suggested on the
gentoo development mailinglist). It uses a simple, modular approach to
building initramfs archives. It has a base, which includes a small
&lt;code&gt;init&lt;/code&gt; script and some device handling (based on &lt;code&gt;udev&lt;/code&gt;), and modules
that you can add depending on your situation (such as adding support for
RAID devices, LVM, NFS mounted file systems etc.)&lt;/p&gt;
&lt;p&gt;On a SELinux system (using a strict policy, enforcing mode) running
dracut in the &lt;code&gt;sysadm_t&lt;/code&gt; domain doesn't work, so I had to create a
&lt;code&gt;dracut_t&lt;/code&gt; domain (which has been pushed to the Portage tree yesterday).
But other than that, it is for me sufficient to call dracut to create an
initramfs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# dracut -f &amp;quot;&amp;quot; 3.1.6-hardened
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;My grub then has an additional set of lines like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title Gentoo Linux Hardened (initramfs)
root (hd0,0)
kernel /boot/vmlinuz-3.1.6-hardened root=/dev/vda1 console=ttyS0 console=tty0
initrd /boot/initramfs-3.1.6-hardened.img
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Sadly, the bugger didn't boot. The first problem I hit was that the
Linux kernel I boot has chroot restrictions in it (grSecurity). These
restrictions further tighten chroot environments so that it is much more
difficult to "escape" a chroot. But &lt;strong&gt;dracut&lt;/strong&gt;, and probably all others,
use &lt;strong&gt;chroot&lt;/strong&gt; to further prepare the bootup and eventually switch to
the chrooted environment to boot up further. Having the chroot
restrictions enabled effectively means that I cannot use initramfs
environments. To work around, I enabled &lt;em&gt;sysctl&lt;/em&gt; support for all the
chroot restrictions and made sure that their default behavior is to be
disabled. Then, when the system boots up, it enables the restrictions
later in the boot process (through the &lt;code&gt;sysctl.conf&lt;/code&gt; settings) and then
locks these settings (thanks to grSecurity's &lt;code&gt;grsec_lock&lt;/code&gt; feature) so
that they cannot be disabled anymore later.&lt;/p&gt;
&lt;p&gt;But no, I did get further, up to the point that either the openrc init
is called (which tries to load in the SELinux policy and then breaks) or
that the initramfs tries to load the SELinux policy - and then breaks.
The problem here is that there is too much happening before the SELinux
policy is loaded. Files are created (such as device files) or
manipulated, chroots are prepared, udev is (temporarily) ran, mounts are
created, ... all before a SELinux policy is loaded. As a result, the
files on the system have incorrect contexts and the moment the SELinux
policy is loaded, the processes get denied all access and other
privileges they want against these (wrongly) labeled files. And since
after loading the SELinux policy, the process runs in &lt;code&gt;kernel_t&lt;/code&gt; domain,
it doesn't have the privileges to relabel the entire system, let alone
call commands.&lt;/p&gt;
&lt;p&gt;This is currently where I'm stuck. I can get the thing boot up, if you
temporarily work in permissive mode. When the openrc init is eventually
called, things proceed as usual and the moment udev is started (again,
now from the openrc init) it is possible to switch to enforcing mode.
All processes are running by then in the correct domain and there do not
seem to be any files left with wrong contexts (since the initramfs is
not reachable anymore and the device files in &lt;code&gt;/dev&lt;/code&gt; are now set again
by udev which is SELinux aware.&lt;/p&gt;
&lt;p&gt;But if you want to boot up in enforcing straight away, there are still
things to investigate. I think I'll need to put the policy in the
initramfs as well (which has the huge downside that every update on the
policy requires a rebuild of the initramfs as well). In that case I can
load the policy early up the chain and have the initramfs work further
running in an enforced situation. Or I completely regard the initramfs
as an "always trusted" environment and wait for openrc's init to load
the SELinux policy. In that case, I need to find a way to relabel the
(temporarily created) &lt;code&gt;/dev&lt;/code&gt; entries (like console, kmsg, ...) before
the policy is loaded.&lt;/p&gt;
&lt;p&gt;Definitely to be continued...&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Unix domain sockets are files</title><link href="https://blog.siphos.be/2011/12/unix-domain-sockets-are-files/" rel="alternate"></link><published>2011-12-31T17:48:00+01:00</published><updated>2011-12-31T17:48:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-12-31:/2011/12/unix-domain-sockets-are-files/</id><summary type="html">&lt;p&gt;Probably not a first for many seasoned Linux administrators, and
probably not correct accordingly to more advanced users than myself, but
I just found out that Unix domain sockets are files. Even when they're
not.&lt;/p&gt;
&lt;p&gt;I have been looking at a weird SELinux denial I had occuring on my
system …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Probably not a first for many seasoned Linux administrators, and
probably not correct accordingly to more advanced users than myself, but
I just found out that Unix domain sockets are files. Even when they're
not.&lt;/p&gt;
&lt;p&gt;I have been looking at a weird SELinux denial I had occuring on my
system:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;avc:  denied  { read write } for  pid=10012 comm=&amp;quot;hostname&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;path="socket:[318867]" dev=sockfs ino=318867 &lt;br&gt;
   scontext=system_u:system_r:hostname_t &lt;br&gt;
   tcontext=system_u:system_r:dhcpc_t &lt;br&gt;
   tclass=unix_stream_socket&lt;/p&gt;
&lt;p&gt;I had a tough time trying to figure out why in earth the &lt;strong&gt;hostname&lt;/strong&gt;
application was trying to read/write to a &lt;em&gt;socket&lt;/em&gt; that was owned by
&lt;strong&gt;dhcpcd&lt;/strong&gt;. Even more, I didn't see a &lt;em&gt;connectto&lt;/em&gt; attempt, and there is
nothing in my policy that would allow the &lt;code&gt;hostname_t&lt;/code&gt; domain to connect
to a unix_stream_socket of &lt;code&gt;dhcpc_t&lt;/code&gt;. But moreover I was intrigued why
the given path was no real path, even though it has an inode.&lt;/p&gt;
&lt;p&gt;So I dug up &lt;strong&gt;lsof&lt;/strong&gt;, which returned the following on this socket:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# lsof -p 10017
COMMAND   PID USER   FD      TYPE             DEVICE SIZE/OFF   NODE NAME
...
dhcpcd  10017 root    3u     unix 0x0000000000000000      0t0 318867 socket
dhcpcd  10017 root    4w      REG              252,3        6 268749 /var/run/dhcpcd-eth1.pid
dhcpcd  10017 root    5u     unix 0x0000000000000000      0t0 318869 socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Still no luck in figuring out what that is. And even &lt;code&gt;/proc/net/unix&lt;/code&gt;
didn't give anything back:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# grep 318867 /proc/net/unix
Num               RefCount Protocol Flags    Type St Inode Path
0000000000000000: 00000002 00000000 00000000 0001 01 318867
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So I started looking at Unix domain sockets, what they are, how they are
used, etc. And I learned that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unix domain sockets are just files. Well, most of the time. To use a
    socket (from server-perspective), a programmer first calls
    &lt;code&gt;socket()&lt;/code&gt; to create a socket descriptor, which is a special type of
    file descriptor. It then &lt;code&gt;bind()&lt;/code&gt;'s the socket to a (socket)file on
    the file system, &lt;code&gt;listen()&lt;/code&gt;'s for incoming connections and
    eventually &lt;code&gt;accept()&lt;/code&gt;'s them. Clients also use &lt;code&gt;socket()&lt;/code&gt; but then
    call &lt;code&gt;connectto()&lt;/code&gt; to have its socket connected to a (socket)file
    and eventually &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; (or &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Linux supports an abstract namespace for sockets, so not all of
    these are actually bound/connected to a file. Instead, they connect
    to a "name" instead, which cannot be traced back to a file. For
    those interested, looking at &lt;code&gt;/proc/net/unix&lt;/code&gt; or &lt;code&gt;netstat -xa&lt;/code&gt; shows
    the abstract ones starting with an &lt;code&gt;@&lt;/code&gt; sign.&lt;/li&gt;
&lt;li&gt;Not all Unix sockets (actually almost the majority of sockets on
    my system) can be traced back to either a file or abstract name.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And this latter is eating me up. I assume that these sockets were
originally created on a file system, but immediately after they were
&lt;code&gt;bind()&lt;/code&gt;'ed, the file is unlinked, making it harder (impossible?) to
find what the socket file was called to begin with. I first thought it
were sockets that were not &lt;code&gt;bind()&lt;/code&gt;'ed to, but many of them have the
state &lt;code&gt;CONNECTED&lt;/code&gt; displayed (in the &lt;strong&gt;netstat -xa&lt;/strong&gt; output) so that's
not a likely scenario. In any case, if you know how these sockets can
have an inode without a known path, please let me know.&lt;/p&gt;
&lt;p&gt;But what has this to do with my previous investigation? Well, because
the sockets are descriptors, they are passed when a process uses
&lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;execve()&lt;/code&gt;. And looking at the source code of dhcpcd, I
noticed that it does not close its file descriptors when it calls its
hook scripts (through the &lt;code&gt;exec_script()&lt;/code&gt; function of its sources). As a
result, the open file descriptors (including the sockets) are passed on
to the hook scripts - one of them calling &lt;strong&gt;hostname&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;So what I saw in the AVC denials was a leaked socket (so there was no
&lt;code&gt;connectto&lt;/code&gt; originating from the &lt;code&gt;hostname_t&lt;/code&gt; domain since the
connection was made by &lt;strong&gt;dhcpc&lt;/strong&gt; in the &lt;code&gt;dhcpc_t&lt;/code&gt; domain) that is for
some reason being read/written to. A leaked unix stream socket.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Some people on #selinux are ... dolphins</title><link href="https://blog.siphos.be/2011/07/some-people-on-selinux-are-dolphins/" rel="alternate"></link><published>2011-07-14T20:00:00+02:00</published><updated>2011-07-14T20:00:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-07-14:/2011/07/some-people-on-selinux-are-dolphins/</id><summary type="html">&lt;p&gt;A very useful resource for anyone working on or with SELinux policies is
the #selinux chat channel on irc.freenode.net. People like Dominick
Grift and Dan Walsh you would first think are IRC bots (being online all
the time, answering questions), but I recently read that they must be …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A very useful resource for anyone working on or with SELinux policies is
the #selinux chat channel on irc.freenode.net. People like Dominick
Grift and Dan Walsh you would first think are IRC bots (being online all
the time, answering questions), but I recently read that they must be
... dolphins.&lt;/p&gt;
&lt;p&gt;Yes, dolphins. Dolphins are known to
&lt;a href="https://secure.wikimedia.org/wikipedia/en/wiki/Dolphins"&gt;not&lt;/a&gt;
&lt;a href="http://www.sciencentral.com/articles/view.php3?article_id=218392593"&gt;really&lt;/a&gt;
&lt;a href="http://www.nature.com/news/2004/040920/full/news040920-10.html"&gt;sleep&lt;/a&gt;
&lt;a href="http://newswatch.nationalgeographic.com/2009/05/06/dolphins_sleep_with_half_their_brains/"&gt;fully&lt;/a&gt;
- only one part of their brain goes to a low-wave sleep so they're
sufficiently conscious to keep track of what is happening around them.&lt;/p&gt;
&lt;p&gt;No seriously, thanks guys!&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Policy 25, 26</title><link href="https://blog.siphos.be/2011/06/policy-25-26/" rel="alternate"></link><published>2011-06-01T21:32:00+02:00</published><updated>2011-06-01T21:32:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-06-01:/2011/06/policy-25-26/</id><summary type="html">&lt;p&gt;Recently I've seen quite a few messages on IRC pop up about &lt;code&gt;policy.25&lt;/code&gt;
or even &lt;code&gt;policy.26&lt;/code&gt; so I harassed the guys in the chat channel to talk
about it. Apparently, these new binary policy formats add support for
filename transitions and non-process role transitions.&lt;/p&gt;
&lt;p&gt;Currently, when you initiate …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently I've seen quite a few messages on IRC pop up about &lt;code&gt;policy.25&lt;/code&gt;
or even &lt;code&gt;policy.26&lt;/code&gt; so I harassed the guys in the chat channel to talk
about it. Apparently, these new binary policy formats add support for
filename transitions and non-process role transitions.&lt;/p&gt;
&lt;p&gt;Currently, when you initiate a type transition, you would use something
like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type_transition mysqld_t mysql_db_t:sock_file mysqld_var_run_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This statement sais that, if a process running in the &lt;code&gt;mysqld_t&lt;/code&gt; domain
creates a socket in a directory labelled with &lt;code&gt;mysql_db_t&lt;/code&gt;, then this
socket gets the &lt;code&gt;mysqld_var_run_t&lt;/code&gt; label. In other words, the type
transitions from &lt;code&gt;mysql_db_t&lt;/code&gt; (parent label) to &lt;code&gt;mysqld_var_run_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What will be supported from version 25 onwards is that you can add
another argument, the file name (well, actually it is called "last name
component" and should be seen as what &lt;strong&gt;basename /path/to/something&lt;/strong&gt;
returns). That allows processes running in the same domain and writing
files in directories labelled with the same type to still have these
files labelled specifically. A non-existing example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type_transition puppet_t etc_t:file locale_t timezone;
type_transition puppet_t etc_t:file net_conf_t resolv.conf;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above example, if the &lt;code&gt;puppet_t&lt;/code&gt; domain creates files in
&lt;path&gt;/etc&lt;/path&gt; (which is labelled &lt;code&gt;etc_t&lt;/code&gt;) then based on the file it
is creating, this file gets a different label (&lt;code&gt;/etc/timezone&lt;/code&gt; gets
labelled &lt;code&gt;locale_t&lt;/code&gt; whereas &lt;code&gt;/etc/resolv.conf&lt;/code&gt; gets labelled
&lt;code&gt;net_conf_&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The second change (valid since policy version 26) is that role
transitions now also support non-process class transitions. &lt;a href="http://permalink.gmane.org/gmane.comp.security.selinux/15079"&gt;A lengthy
post&lt;/a&gt; that
Harry Ciao made helps to describe it. The &lt;code&gt;role_transition&lt;/code&gt; support in
SELinux was previously used in the following way:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;role_transition roleA_r some_exec_t roleB_r;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What this statement indicates is that a domain running within &lt;code&gt;roleA_r&lt;/code&gt;
and that is executing &lt;code&gt;some_exec_t&lt;/code&gt; will change its runtime role to
&lt;code&gt;roleB_r&lt;/code&gt;. If by calling &lt;code&gt;some_exec_t&lt;/code&gt; a domain transition occurs as
well (which is most common when a role transition is supported as well)
then this domain will run with the &lt;code&gt;roleB_r&lt;/code&gt; runtime role.&lt;/p&gt;
&lt;p&gt;The added functionality is now that this isn't limited to processes
anymore. You can now define non-process classes as well. If the source
domain creates something new of a particular class and a role transition
is declared for that, then the resulting new object will have the
specified role assigned to it (rather than the default &lt;code&gt;object_r&lt;/code&gt;). So
for instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;role_transition sysadm_r cron_spool_t:file sysadm_r;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If a domain running within the &lt;code&gt;sysadm_r&lt;/code&gt; role creates a file in a
directory labelled &lt;code&gt;cron_spool_t&lt;/code&gt;, then the resulting file will have the
role &lt;code&gt;sysadm_r&lt;/code&gt; rather than &lt;code&gt;object_r&lt;/code&gt;. This opens up more support for
role-based access controls (similar to the UBAC functionality that I
described earlier, but in some cases more flexible). I'm pretty sure
that the crontab management for vixie-cron will be one of the first ones
that can benefit greatly from this ;-)&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux file contexts</title><link href="https://blog.siphos.be/2011/05/selinux-file-contexts/" rel="alternate"></link><published>2011-05-15T13:39:00+02:00</published><updated>2011-05-15T13:39:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-05-15:/2011/05/selinux-file-contexts/</id><summary type="html">&lt;p&gt;If you have been working with SELinux for a while, you know that file
contexts are an important part of the policy and its enforcement. File
contexts are used to inform the SELinux tools which type a file,
directory, socket, ... should have. These types are then used to manage
the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you have been working with SELinux for a while, you know that file
contexts are an important part of the policy and its enforcement. File
contexts are used to inform the SELinux tools which type a file,
directory, socket, ... should have. These types are then used to manage
the policy itself, which is based on inter-type permissions.&lt;/p&gt;
&lt;p&gt;When dealing with file contexts, you either use&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;chcon&lt;/strong&gt; (mostly) if you are trying out stuff as a &lt;strong&gt;chcon&lt;/strong&gt;-set
    security context doesn't stick after a file system relabel operation
    (customizable types notwithstanding, and even then)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;restorecon&lt;/strong&gt; if you want to reset the file context of a file or
    set of files&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;semanage&lt;/strong&gt; through the &lt;strong&gt;semanage fcontext -a -t your_type
    "regular_expression"&lt;/strong&gt; method, which enhances the SELinux known
    file contexts with the appropriate information so that relabel
    operations are survived&lt;/li&gt;
&lt;li&gt;policy improvements by editing and enhancing the &lt;code&gt;*.fc&lt;/code&gt; files that
    take part in the policy definition&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When you look at the policy, or the output of &lt;strong&gt;semanage fcontext -l&lt;/strong&gt;,
you'll notice that the policy uses regular expressions very often. Of
course, without regular expression support, the file context rules
themselves would be impossible to manage. However, it immediately brings
up the question about what SELinux does when two or more lines are
appropriate for a particular file. Let's look at a few lines for
configuration related locations...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/.*                     all files          system_u:object_r:etc_t
/etc/HOSTNAME               regular file       system_u:object_r:etc_runtime_t
/etc/X11/[wx]dm/Xreset.*    regular file       system_u:object_r:xsession_exec_t 
/etc/X11/wdm(/.*)?          all files          system_u:object_r:xdm_rw_etc_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above examples, you'll notice that there is quite some overlap.
To start, the first line already matches all other lines as well. So how
does SELinux handle this?&lt;/p&gt;
&lt;p&gt;Well, SELinux uses the following logic to find the most specific match,
and uses the most specific match then (extract taken from a pending
update to the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-faq.xml"&gt;Gentoo Hardened SELinux
FAQ&lt;/a&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If line A has a regular expression, and line B doesn't, then line B
    is more specific.&lt;/li&gt;
&lt;li&gt;If the number of characters before the first regular expression in
    line A is less than the number of characters before the first
    regular expression in line B, then line B is more specific&lt;/li&gt;
&lt;li&gt;If the number of characters in line A is less than in line B, then
    line B is more specific&lt;/li&gt;
&lt;li&gt;If line A does not map to a specific SELinux type, and line B does,
    then line B is more specific&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So in case of &lt;code&gt;/etc/HOSTNAME&lt;/code&gt;, the second line is most specific because
it does not contain a regular expression.&lt;/p&gt;
&lt;p&gt;In case of &lt;code&gt;/etc/X11/wdm/Xreset.sh&lt;/code&gt;, SELinux will use the
xdm_rw_etc_t type and not the xsession_exec_t one. This is because
the first regular expression in the xsession_exec_t line (&lt;code&gt;[wx]&lt;/code&gt;)
comes sooner than the first regular expression in the xdm_rw_etc_t
line (&lt;code&gt;(/.*)?&lt;/code&gt;). You can validate this - even if you do not have such
file - with &lt;strong&gt;matchpathcon&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# matchpathcon /etc/X11/wdm/Xreset.sh
/etc/X11/wdm/Xreset.sh   system_u:object_r:xdm_rw_etc_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you want to know which line in the &lt;strong&gt;semanage fcontext -l&lt;/strong&gt; output is
used, you can use &lt;strong&gt;findcon&lt;/strong&gt; to show which lines match. That together
with the output of matchpathcon can help you deduce which line is
causing the label to be set:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# matchpathcon /etc/X11/wdm/Xreset.sh
/etc/X11/wdm/Xreset.sh   system_u:object_r:xdm_rw_etc_t
~# findcon /etc/selinux/strict/contexts/files/file_contexts -p /etc/X11/wdm/Xreset.sh
/.*             system_u:object_r:default_t
/etc/.*         system_u:object_r:etc_t
/etc/X11/[wx]dm/Xreset.*        --      system_u:object_r:xsession_exec_t
/etc/X11/wdm(/.*)?              system_u:object_r:xdm_rw_etc_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In many cases, the last output line of &lt;strong&gt;findcon&lt;/strong&gt; is the line you are
looking for, but I have not find a source that confirms this behavior so
do not trust this.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux User-Based Access Control</title><link href="https://blog.siphos.be/2011/05/selinux-user-based-access-control/" rel="alternate"></link><published>2011-05-02T22:14:00+02:00</published><updated>2011-05-02T22:14:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-05-02:/2011/05/selinux-user-based-access-control/</id><summary type="html">&lt;p&gt;Within the reference policy, support is given to a feature called &lt;em&gt;UBAC
constraints&lt;/em&gt;. Here, UBAC stands for &lt;em&gt;User Based Access Control&lt;/em&gt;. The
idea behind the constraint is that any activity between two types (say
&lt;code&gt;foo_t&lt;/code&gt; and &lt;code&gt;bar_t&lt;/code&gt;) can be prohibited if the user contexts of the
resources that are using …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Within the reference policy, support is given to a feature called &lt;em&gt;UBAC
constraints&lt;/em&gt;. Here, UBAC stands for &lt;em&gt;User Based Access Control&lt;/em&gt;. The
idea behind the constraint is that any activity between two types (say
&lt;code&gt;foo_t&lt;/code&gt; and &lt;code&gt;bar_t&lt;/code&gt;) can be prohibited if the user contexts of the
resources that are using those types are different. So even though
&lt;code&gt;foo_t&lt;/code&gt; can read files with label &lt;code&gt;bar_t&lt;/code&gt;, a process running as
&lt;code&gt;user1:user_r:foo_t&lt;/code&gt; will not be able to read a file labeled
&lt;code&gt;user2:user_r:bar_t&lt;/code&gt;. The policy defines the constraint like so (taken
from &lt;code&gt;policy/constraints&lt;/code&gt; and rewritten in a more readable code):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Action is okay if
  user1 == user2, or
  user1 == system_u, or
  user2 == system_u, or
  type1 is not a UBAC constrained type, or
  type2 is not a UBAC constrained type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So the constraint only denies an activity if the users involved are not
&lt;code&gt;system_u&lt;/code&gt; (that would render your system useless), not the same, and
&lt;em&gt;both types are ubac constrained types&lt;/em&gt;. The latter is, within the
policy, set using type attributes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ seinfo -aubac_constrained_type -x
ubac_constrained_type
   screen_var_run_t
   admin_crontab_t
   links_input_xevent_t
   ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Some domains are also UBAC exempt (currently I know of the &lt;code&gt;sysadm_t&lt;/code&gt;
domain - cfr the &lt;code&gt;ubacproc&lt;/code&gt; and &lt;code&gt;ubacfile&lt;/code&gt; attributes), meaning that
activities started from the &lt;code&gt;sysadm_t&lt;/code&gt; domain will not trigger the
constraint.&lt;/p&gt;
&lt;p&gt;UBAC gives some additional control on information flow between
resources. But it isn't perfect. One major downside is that the error
you get when the constraint is hit is a simple AVC denial where most
users would just check the inter-type privileges, without paying
attention to the difference in SELinux user identities. Another is that
it might be difficult for users or administrators that use different
SELinux user identities to still work properly with UBAC constrained
domains. Work is on the way in the SELinux development to improve the
role-based access control (RBAC) by allowing files and directories to
have a role as well (rather than the &lt;code&gt;object_r&lt;/code&gt; placeholder used
currently) and then work on those roles. You can then grant the users
that need access to a particular resource the necessary role rather than
requiring those users to use the same SELinux user id. This would take
at least one major downside of UBAC away and I'm hoping that the logging
will improve on this as well.&lt;/p&gt;
&lt;p&gt;Of course, I do not ramble about UBAC here because it is fun (well yes,
yes it is fun) but because in Gentoo, we've hit one UBAC-related issue.
When a user starts vixie-cron, the root crontab would fail to be loaded.
What gives? The root crontab has the SELinux identity of &lt;code&gt;staff_u&lt;/code&gt; (as
it is created by a regular staff user that su(do)'ed) whereas the
&lt;code&gt;cronjob_t&lt;/code&gt; process would have the SELinux identity of &lt;code&gt;root&lt;/code&gt;. Bang.
Dead. No error beyond what vixie-cron gives.&lt;/p&gt;
&lt;p&gt;Of course this can be easily worked around. &lt;strong&gt;chcon -u root
/var/spool/cron/crontabs/root&lt;/strong&gt; works, or you can recreate the crontab
as a console-logged-on root user. We could also change the default
context used by &lt;code&gt;cronjob_t&lt;/code&gt; to use &lt;code&gt;staff_u:sysadm_r:cronjob_t&lt;/code&gt; for
root. But we can also take a look at how other distributions do this.
What gives: most distributions &lt;em&gt;disable&lt;/em&gt; UBAC within the policy. Their
reasons might vary, but manageability of the policy comes to mind, as
well as reducing the number of (difficult to debug) problems. Most are
keen to include the RBAC at some point in the future though. Some
discussion on #gentoo-hardened and #selinux later, and I decided to
use a USE flag called "ubac" to optionally enable UBAC within the
policy. How very Gentoo, isn't it? At least users have the choice of
using UBAC or not (I know I'm going to enable it) and when RBAC is
available, we'll definitely make sure that support for RBAC is available
too.&lt;/p&gt;
&lt;p&gt;Currently in the hardened overlay,
&lt;code&gt;sec-policy/selinux-base-policy-2.20101213-r13&lt;/code&gt;. Take your pick on it,
give it a try and report any bugs you have on
&lt;a href="https://bugs.gentoo.org"&gt;Bugzilla&lt;/a&gt;. And if you enable USE="ubac", you
get user based access control for free.&lt;/p&gt;
&lt;p&gt;PS I'm also going to reapply for Gentoo developer-ship and, amongst
other things, help out the hardened team with SELinux policies and
documentation.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux and noatsecure, or why portage complains about LD_PRELOAD and libsandbox.so</title><link href="https://blog.siphos.be/2011/04/selinux-and-noatsecure-or-why-portage-complains-about-ld_preload-and-libsandbox-so/" rel="alternate"></link><published>2011-04-22T21:00:00+02:00</published><updated>2011-04-22T21:00:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-04-22:/2011/04/selinux-and-noatsecure-or-why-portage-complains-about-ld_preload-and-libsandbox-so/</id><summary type="html">&lt;p&gt;If you're fiddling with SELinux policies, you will eventually notice
that the reference policy by default hides certain privilege requests
(which are denied). One of them is noatsecure. But what is noatsecure?
To describe noatsecure, I first need to describe what atsecure is. And
to describe what that is, we …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you're fiddling with SELinux policies, you will eventually notice
that the reference policy by default hides certain privilege requests
(which are denied). One of them is noatsecure. But what is noatsecure?
To describe noatsecure, I first need to describe what atsecure is. And
to describe what that is, we first need to give a small talk about ELF
auxiliary vectors.&lt;/p&gt;
&lt;p&gt;As you probably know, when an application instantiates another
application, it calls the &lt;code&gt;execve&lt;/code&gt; function right after fork'ing to load
the new application in memory. The actual task to load the new
application in memory is done by the C library, more specifically the
binary loader. For Linux, this is the ELF loader. Now, &lt;em&gt;ELF auxiliary
vectors&lt;/em&gt; are parameters or flags that are set (or at least managed) by
the ELF loader to allow the application and program interpreter to get
some OS-specific information. Examples of such vectors are &lt;code&gt;AT_UID&lt;/code&gt; and
&lt;code&gt;AT_EUID&lt;/code&gt; (real uid and effective uid) and &lt;code&gt;AT_PAGESZ&lt;/code&gt; (system page
size).&lt;/p&gt;
&lt;p&gt;One of the vectors that glibc supports is &lt;code&gt;AT_SECURE&lt;/code&gt;. This particular
parameter (which is either "0" (default) or "1") tells the ELF dynamic
linker to unset various &lt;a href="http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/generic/unsecvars.h;hb=HEAD"&gt;environment
variables&lt;/a&gt;
that are considered potentially harmful for your system. One of these is
&lt;code&gt;LD_PRELOAD&lt;/code&gt; (I mention this one specifically because it was the source
of my small investigation). Normally, this environment sanitation is
done when a setuid/setgid application is called (to prevent the obvious
vulnerabilities). However, SELinux enhances the use of this
sanitation...&lt;/p&gt;
&lt;p&gt;Whenever an application is called which triggers a domain transition in
SELinux (say &lt;code&gt;sysadm_t&lt;/code&gt; to &lt;code&gt;mozilla_t&lt;/code&gt; through a binary labelled
&lt;code&gt;mozilla_exec_t&lt;/code&gt;), SELinux sets the &lt;code&gt;AT_SECURE&lt;/code&gt; flag for the loaded
application (in the example, mozilla/firefox). In other words, every
time a domain transition occurs, the environment for this application is
sanitized.&lt;/p&gt;
&lt;p&gt;As you can imagine now the &lt;code&gt;noatsecure&lt;/code&gt; permission disables the
environment sanitation activity for a particular transition. You can do
this through the following allow statement (applied to the above
example):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow sysadm_t mozilla_t:process { noatsecure };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;if every domain transition for which this permission isn't allowed would
log its denial, our audit logs would be filled with noise. That is why
the reference policy by default hides (&lt;code&gt;dontaudit&lt;/code&gt;) these calls. But
knowing what they are for is important, because you might sometimes come
into contact with it, like I did:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Installing (1 of 1) net-dns/host-991529
&amp;gt;&amp;gt;&amp;gt; Setting SELinux security labels
ERROR: ld.so: object &amp;#39;libsandbox.so&amp;#39; from LD_PRELOAD cannot be preloaded: ignored.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This error message is when Portage (running in &lt;code&gt;portage_t&lt;/code&gt;) wants to
relabel the files that it just placed on the system through setfiles
(which will run in &lt;code&gt;setfiles_t&lt;/code&gt;). As this involves a domain transition,
&lt;code&gt;AT_SECURE&lt;/code&gt; is set for setfiles, but &lt;code&gt;LD_PRELOAD&lt;/code&gt; was set as part of
Portage' sandboxing feature. This environment variable is disabled, and
the loader warns the user that it cannot preload &lt;code&gt;libsandbox.so&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Although we can just set &lt;em&gt;noatsecure&lt;/em&gt; here, it would open up a (small)
window for exploits (although they would need to be provided through
Portage, because when a user calls Portage, a domain transition is done
there as well so the user-provided environment variables are already
sanitized by then). By not allowing &lt;em&gt;noatsecure&lt;/em&gt;, we are disabling a few
functionalities provided by the libsandbox.so library &lt;em&gt;for the file
labeling activity&lt;/em&gt; (this is &lt;strong&gt;very important&lt;/strong&gt; to understand: it does
not disable the sandboxing for the builds and merges, only for the file
relabeling). As we already run setfiles in its own, confined domain, I
believe that we are best served by keeping the secure environment
sanitation here. That does mean that the warning will stay as we cannot
control that from within SELinux.&lt;/p&gt;
&lt;p&gt;If you want to allow &lt;em&gt;noatsecure&lt;/em&gt; here, create a simple module and load
it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# cat &amp;gt; portage_noatsecure.te &amp;lt;&amp;lt; EOF
module portage_noatsecure 1.0;
require {
  type portage_t;
  type setfiles_t;
  class process { noatsecure };
}
allow portage_t setfiles_t:process { noatsecure };
EOF
~# checkmodule -m -o portage_noatsecure.mod portage_noatsecure.te
~# semodule_package -o portage_noatsecure.pp -m portage_noatsecure.mod
~# semodule -i portage_noatsecure.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category></entry><entry><title>Updates on SELinux docs, added FAQ</title><link href="https://blog.siphos.be/2011/03/updates-on-selinux-docs-added-faq/" rel="alternate"></link><published>2011-03-09T22:17:00+01:00</published><updated>2011-03-09T22:17:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-03-09:/2011/03/updates-on-selinux-docs-added-faq/</id><summary type="html">&lt;p&gt;As you're probably noticing from my &lt;a href="https://twitter.com/#!/sjvermeu"&gt;twitter
feed&lt;/a&gt; and the various posts earlier in
my blog, I'm helping out with the Gentoo Hardened folks to get the
SELinux support state up to par. Today, the &lt;a href="http://goo.gl/DlHJD"&gt;Gentoo Hardened/SELinux
Handbook&lt;/a&gt; had a few updates, but the most important
change is that …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As you're probably noticing from my &lt;a href="https://twitter.com/#!/sjvermeu"&gt;twitter
feed&lt;/a&gt; and the various posts earlier in
my blog, I'm helping out with the Gentoo Hardened folks to get the
SELinux support state up to par. Today, the &lt;a href="http://goo.gl/DlHJD"&gt;Gentoo Hardened/SELinux
Handbook&lt;/a&gt; had a few updates, but the most important
change is that there is now a &lt;a href="http://goo.gl/uaaf4"&gt;Gentoo Hardened SELinux
FAQ&lt;/a&gt; (in draft). I'm hoping that, at the next IRC
meeting, we can vote on having it pushed to the main site. Also, the
latest changes I made to various SELinux policy ebuilds have been pushed
to the main tree.&lt;/p&gt;
&lt;p&gt;I'm now focusing on running various servers in KVM guests to test the
SELinux policies. Following the &lt;a href="http://www.gentoo.org/doc/en/virt-mail-howto.xml"&gt;Gentoo Virtual Mailhosting
HOWTO&lt;/a&gt; creates a
working system, although a few SELinux-specific steps had to be added
(if you follow the guide exactly to the letter, you won't finish it).
The issues are minor though: &lt;code&gt;selinux-sasl&lt;/code&gt; needs to be installed
manually (it isn't pulled in as a dependency), the PIDFILE and
SSLPIDFILE variables in /etc/courier-imap/* need to point to
/var/run/courier (and that location needs to be created) to match the
file context definitions as suggested by upstream, you need to run
&lt;strong&gt;postalias /etc/mail/aliases&lt;/strong&gt; instead of &lt;strong&gt;newaliases&lt;/strong&gt; and during the
installation of Apache, you might need to &lt;strong&gt;chcon -t bin_t
/usr/share/build-1/mkdir.sh&lt;/strong&gt; as you'll get a permission denied
otherwise.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Portage fails to build due to SELinux?</title><link href="https://blog.siphos.be/2011/03/portage-fails-to-build-due-to-selinux/" rel="alternate"></link><published>2011-03-03T00:26:00+01:00</published><updated>2011-03-03T00:26:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-03-03:/2011/03/portage-fails-to-build-due-to-selinux/</id><summary type="html">&lt;p&gt;If you're having troubles getting Portage to build packages due to
SELinux, then the reason usually is that it is unable to transition to
the proper portage domains. You'll get a nice OSError back with an ugly
backtrace, saying somewhere that "setexeccon" is misbehaving.&lt;/p&gt;
&lt;p&gt;Now, the real issue (not being …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you're having troubles getting Portage to build packages due to
SELinux, then the reason usually is that it is unable to transition to
the proper portage domains. You'll get a nice OSError back with an ugly
backtrace, saying somewhere that "setexeccon" is misbehaving.&lt;/p&gt;
&lt;p&gt;Now, the real issue (not being able to transition) means that the
current domain you are in (check &lt;strong&gt;id -Z&lt;/strong&gt;) has no right to transition
to the &lt;em&gt;portage_fetch_t&lt;/em&gt;, &lt;em&gt;portage_t&lt;/em&gt; or &lt;em&gt;portage_sandbox_t&lt;/em&gt;
domains. You can verify that with &lt;strong&gt;seinfo&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# id -Z
unconfined_u:unconfined_r:unconfined_t
~# seinfo -runconfined_r -x | grep portage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above example shows it for the &lt;em&gt;unconfined_t&lt;/em&gt; domain, but the same
is true if your current domain is a more illogical &lt;em&gt;local_login_t&lt;/em&gt;
(hint: check your PAM settings) or &lt;em&gt;initrc_t&lt;/em&gt;. Now, if you want to fix
these things, we will eventually ask you to reemerge some things - which
was the first reason why you came asking how to fix things.&lt;/p&gt;
&lt;p&gt;There are two ways to handle this situation: the proper way (disabling
SELinux and reenabling later) or the ugly way (hack Portage to ignore).&lt;/p&gt;
&lt;p&gt;In the first way, you need to edit &lt;em&gt;/etc/selinux/config&lt;/em&gt;, set
&lt;em&gt;SELINUX=disabled&lt;/em&gt;, reboot, emerge whatever you need, edit the file
again restoring SELINUX to what you had before, reboot, relabel your
entire filesystem (&lt;strong&gt;rlpkg -a -r&lt;/strong&gt;) and perhaps even reboot again.&lt;/p&gt;
&lt;p&gt;In the second method, edit /usr/lib(64)/portage/pym/portage/_selinux.py
and go to line 79. It reads:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;        if selinux.setexeccon(ctx) &amp;lt; 0:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Comment out that line (so it isn't lost) and substitute it with&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;        if selinux.setexeccon(&amp;quot;\n&amp;quot;) &amp;lt; 0:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now you should be able to install software without hitting the error.
But note that &lt;em&gt;this is only to help you fix the real problem&lt;/em&gt; as we're
circumventing SELinux integration in Portage a bit.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Temporary script for Gentoo Hardened SELinux users</title><link href="https://blog.siphos.be/2011/02/temporary-script-for-gentoo-hardened-selinux-users/" rel="alternate"></link><published>2011-02-27T17:37:00+01:00</published><updated>2011-02-27T17:37:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-02-27:/2011/02/temporary-script-for-gentoo-hardened-selinux-users/</id><summary type="html">&lt;p&gt;If you are currently using Gentoo Hardened with SELinux, you might have
noticed that we are currently lacking the proper dependencies within our
Portage tree upon the SELinux policies (or, in other words, installing a
package doesn't guarantee that the SELinux policy needed for that
package is pulled in as …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you are currently using Gentoo Hardened with SELinux, you might have
noticed that we are currently lacking the proper dependencies within our
Portage tree upon the SELinux policies (or, in other words, installing a
package doesn't guarantee that the SELinux policy needed for that
package is pulled in as well). As the current SELinux policy is still in
\~arch phase, it is also not really feasible to ask other package
maintainers to add the proper dependency information as that might stall
potential stability requests in general.&lt;/p&gt;
&lt;p&gt;So, for the time being, I'm using a simple script (which I call
&lt;a href="https://github.com/sjvermeu/small.coding/tree/master/genmodoverview"&gt;genmodoverview&lt;/a&gt;)
which tells me on my systems which SELinux policy modules i might still
be missing. Based on the output of that script, I can then continue to
install the &lt;code&gt;sec-policy/selinux-*&lt;/code&gt; package(s) for those modules.&lt;/p&gt;
&lt;p&gt;It's usage is simple. Download the genmodoverview.sh and LISTING files,
make the first one executable and run &lt;strong&gt;./genmodoverview.sh -c
LISTING&lt;/strong&gt;.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux for Gentoo Hardened</title><link href="https://blog.siphos.be/2011/02/selinux-for-gentoo-hardened/" rel="alternate"></link><published>2011-02-06T23:26:00+01:00</published><updated>2011-02-06T23:26:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-02-06:/2011/02/selinux-for-gentoo-hardened/</id><summary type="html">&lt;p&gt;Recently, most of the SELinux-related ebuilds from the hardened overlay
have been moved to the official Portage tree. Hopefully, this will
trigger more people / organizations to try Gentoo Hardened with SELinux
and help us improve the ebuilds. They're still marked as \~arch (as they
should be). The draft &lt;a href="http://goo.gl/DlHJD"&gt;SELinux handbook …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently, most of the SELinux-related ebuilds from the hardened overlay
have been moved to the official Portage tree. Hopefully, this will
trigger more people / organizations to try Gentoo Hardened with SELinux
and help us improve the ebuilds. They're still marked as \~arch (as they
should be). The draft &lt;a href="http://goo.gl/DlHJD"&gt;SELinux handbook&lt;/a&gt; has been
updated to reflect this and I'm currently performing a few greenfield
installations using the documentation again to verify if everything
still works as it is supposed to. In the meantime, I'm scripting these
things so that I can automate these tests and run those at night in the
future ;-)&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>Confining user applications</title><link href="https://blog.siphos.be/2011/01/confining-user-applications/" rel="alternate"></link><published>2011-01-16T16:23:00+01:00</published><updated>2011-01-16T16:23:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2011-01-16:/2011/01/confining-user-applications/</id><summary type="html">&lt;p&gt;Ever since I started using SELinux, I'm getting more and more fond of
what it can do for (security) administrators. Lately, I've started
confining user applications (like &lt;strong&gt;skype&lt;/strong&gt;) in the idea that I do not
want any application connecting to the Internet or working with content
received from untrusted sources …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Ever since I started using SELinux, I'm getting more and more fond of
what it can do for (security) administrators. Lately, I've started
confining user applications (like &lt;strong&gt;skype&lt;/strong&gt;) in the idea that I do not
want any application connecting to the Internet or working with content
received from untrusted sources to work inside the main user domain
(&lt;code&gt;user_t&lt;/code&gt; or &lt;code&gt;staff_t&lt;/code&gt; in my case). This particular exercise has been
quite interesting, not only to learn more on SELinux, not only to get
acquainted with the reference policy which Gentoo basis its policies
upon. No, it's been interesting because you learn how applications work
underneith...&lt;/p&gt;
&lt;p&gt;Take the skype application for example. Little did I know it read stuff
from my firefox configuration (like the &lt;code&gt;sec8.db&lt;/code&gt; and &lt;code&gt;prefs.js&lt;/code&gt; file),
most likely to see if the skype firefox plugin is installed. With
SELinux, I saw that it did all that - and also denied it. But it isn't
easy to find out why an application behaves as it does. After all, these
aren't questions that average joe asks. It also isn't easy to deduce if
you want to allow it or not. If it was purely for my own system, I
wouldn't hesitate for long, but the idea is that the modules should work
for the majority of people - and who knows, perhaps even be included in
the reference policy in the future.&lt;/p&gt;
&lt;p&gt;Perhaps Gentoo Hardened can write up some rules on the SELinux policies
and how they should be made for the distribution. Do we want to deny as
much as possible, only allowing those things developers can safely
verify need to be allowed? Or do we want to allow everything that the
application already does (but nothing more) so that no AVC denials are
shown anymore? And if Gentoo Hardened chooses "deny as much as
possible", do we configure the policy to not audit those things we don't
think we need (hiding it) or do we expect the security administrator to
manage his own &lt;em&gt;dontaudit&lt;/em&gt; rules? Well, guess I'll ask the hardened
folks and see what they think ;-)&lt;/p&gt;
&lt;p&gt;During the quest, I'll try to update the &lt;a href="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-docs.git;a=blob_plain;f=pdf/selinux-handbook.pdf;hb=HEAD"&gt;Gentoo Hardened SELinux
handbook
draft&lt;/a&gt;.
It's far from finished, but should be usable for most interested
parties. If you're interested in SELinux and want to give it a try with
Gentoo Hardened, this might be the document you are looking for.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux enforcing for console activity</title><link href="https://blog.siphos.be/2010/10/selinux-enforcing-for-console-activity/" rel="alternate"></link><published>2010-10-30T21:30:00+02:00</published><updated>2010-10-30T21:30:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2010-10-30:/2010/10/selinux-enforcing-for-console-activity/</id><summary type="html">&lt;p&gt;I'm now able to boot into my system with SELinux in enforcing mode
(without unconfined domains), do standard system administration tasks as
root / sysadm_r (including the relevant Portage activities) and work as
a regular user as long as I don't want to run in Xorg. I'm not going to
focus …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm now able to boot into my system with SELinux in enforcing mode
(without unconfined domains), do standard system administration tasks as
root / sysadm_r (including the relevant Portage activities) and work as
a regular user as long as I don't want to run in Xorg. I'm not going to
focus on Xorg pretty soon now as there is a bunch of other things to do
(like other applications, writing policies, patching etc.), but here is
a very quick summary on the activities I had to do (apart from those in
the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml"&gt;Gentoo Hardened SELinux
Handbook&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use a more recent reference policy to start from. I fiddled with a
    live ebuild first, but am now falling back to the latest reference
    policy release of &lt;a href="http://oss.tresys.com"&gt;Tresys&lt;/a&gt;, versioned
    &lt;code&gt;2.20100524&lt;/code&gt;. The implementing package
    (&lt;code&gt;sec-policy/selinux-base-policy&lt;/code&gt;) can be found in my
    &lt;a href="http://github.com/sjvermeu/gentoo.overlay"&gt;overlay (sjvermeu)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I use a meta package &lt;code&gt;sec-policy/selinux-policy&lt;/code&gt; which pulls in the
    base policy as well as policies that you definitely need, but seem
    to work well when loaded as a module. Currently, that only includes
    &lt;code&gt;sec-policy/selinux-portage&lt;/code&gt; but others may follow later. The main
    reason is that I like the modular approach and this way, I can
    update/patch these modules without requiring a base rebuild/reload&lt;/li&gt;
&lt;li&gt;Speaking of patching, the &lt;code&gt;sec-policy/selinux-portage&lt;/code&gt; ebuild
    contains a patch for those who have &lt;code&gt;/tmp&lt;/code&gt; and/or &lt;code&gt;/var/tmp&lt;/code&gt; as a
    tmpfs filesystem&lt;/li&gt;
&lt;li&gt;I had to update &lt;code&gt;/lib64/rcscripts/addons/lvm-start.sh&lt;/code&gt; so that the
    lvm locks are placed in &lt;code&gt;/etc/lvm/lock&lt;/code&gt; rather than &lt;code&gt;/dev/.lvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I also had to update &lt;code&gt;/lib/dhcpcd/dhcpcd-hooks/50-dhcpcd-compat&lt;/code&gt; to
    put the &lt;code&gt;*.info&lt;/code&gt; files in &lt;code&gt;/var/lib/dhcpcd&lt;/code&gt; rather than &lt;code&gt;/var/lib&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Many binaries in /bin (part of &lt;code&gt;sys-apps/net-tools&lt;/code&gt;) are hard links
    (same inode) but different name. This gives issues with SELinux'
    file contexts. Quick fix is to copy rather than hardlink (for
    instance, &lt;strong&gt;cp hostname hostname.old&lt;/strong&gt;). After this, I ran &lt;strong&gt;rlpkg
    net-tools&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Many packages need to be unmasked (from &lt;code&gt;~amd64&lt;/code&gt;) as the current
    stable packages either don't work or are too old. The "unstable"
    ones seem to work pretty well though.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I know much development is being put in the SELinux state of Gentoo
Hardened (just visit #gentoo-hardened if you have questions) so I'm
sure things will be improving soon.&lt;/p&gt;</content><category term="SELinux"></category></entry><entry><title>SELinux quicky</title><link href="https://blog.siphos.be/2010/09/selinux-quicky/" rel="alternate"></link><published>2010-09-14T23:44:00+02:00</published><updated>2010-09-14T23:44:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2010-09-14:/2010/09/selinux-quicky/</id><summary type="html">&lt;p&gt;I've been using SELinux for a few days now (in permissive mode, just to
get to know things) and have learned a few interesting commands (or
other nice-to-know's) for using SELinux. Since I'm going to forget those
the moment all is running well, I'll "document" them here ;-) I'm not
going …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've been using SELinux for a few days now (in permissive mode, just to
get to know things) and have learned a few interesting commands (or
other nice-to-know's) for using SELinux. Since I'm going to forget those
the moment all is running well, I'll "document" them here ;-) I'm not
going to talk about the &lt;strong&gt;-Z&lt;/strong&gt; switches in &lt;strong&gt;ps&lt;/strong&gt; or &lt;strong&gt;ls&lt;/strong&gt;, that has
been documented sufficiently on the Internet already.&lt;/p&gt;
&lt;p&gt;With &lt;strong&gt;sesearch&lt;/strong&gt; you can query through the loaded policy. For instance,
you want to know why you can execute &lt;strong&gt;sudo&lt;/strong&gt; as a user (and not just
due to the DAC permissions):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ sesearch -s user_t -t sudo_exec_t -p execute -c file -A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of course, this is only one of the three requirements for a transition
from &lt;code&gt;user_t&lt;/code&gt; to &lt;code&gt;user_sudo_t&lt;/code&gt;, for that you still need process
transition and entrypoint:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ sesearch -s user_t -t user_sudo_t -p transition -A 
~$ sesearch -s user_sudo_t -t sudo_exec_t -p entrypoint -A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, sometimes you find a rule that you didn't expect:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ sesearch -s user_t -t dmesg_exec_t -p execute -A
Found 1 semantic av rules:
  allow user_t application_exec_type : file { ioctl read getattr lock execute execute_no_trans open } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is because &lt;code&gt;dmesg_exec_t&lt;/code&gt; has the &lt;code&gt;application_exec_type&lt;/code&gt; attribute
set. You can see the list of types that have an attribute set (or vice
versa) with &lt;strong&gt;seinfo&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(Show list of types that have the application_exec_type attribute)
~$ seinfo -aapplication_exec_type -x
(Show list of attributes given to the dmesg_exec_t type)
~$ seinfo -tdmesg_exec_t -x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, during my browsing through the SELinux activities on my system, I
noticed that I could run &lt;code&gt;/usr/sbin/dnsmasq&lt;/code&gt; as root, without generating
an error in the avc log. Yet &lt;strong&gt;sesearch&lt;/strong&gt; didn't give any results. I've
almost killed a few kittens by searching for possibilities (perhaps
types with &lt;code&gt;exec_type&lt;/code&gt; automatically have &lt;code&gt;application_exec_type&lt;/code&gt; - not,
or perhaps the domain transitions to another domain first without me
knowing - not, I would see that the process runs as a different domain
then, which wasn't the case). Luckily, dgrift on &lt;code&gt;#selinux&lt;/code&gt; gave me the
hint of checking the &lt;em&gt;dontaudit&lt;/em&gt; rules as well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ sesearch --dontaudit -s sysadm_t -t dnsmasq_exec_t
...
   dontaudit sysadm_t exec_type : file { execute execute_no_trans } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So there we had it - it was being denied, just not logged. And because I
ran in permissive mode, it gets executed anyhow. I disabled the
dontaudit rules and got the avc denial I was expecting:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(Disable dontaudit rules)
~$ semodule -DB
(Reenable dontaudit rules)
~$ semodule -B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category></entry></feed>