<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Simplicity is a form of art... - oval</title><link href="https://blog.siphos.be/" rel="alternate"></link><link href="https://blog.siphos.be/tag/oval/feed/atom.xml" rel="self"></link><id>https://blog.siphos.be/</id><updated>2018-03-03T13:20:00+01:00</updated><entry><title>Automating compliance checks</title><link href="https://blog.siphos.be/2018/03/automating-compliance-checks/" rel="alternate"></link><published>2018-03-03T13:20:00+01:00</published><updated>2018-03-03T13:20:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2018-03-03:/2018/03/automating-compliance-checks/</id><summary type="html">&lt;p&gt;With the configuration baseline for a technical service being described fully (see the &lt;a href="https://blog.siphos.be/2018/01/documenting-configuration-changes/"&gt;first&lt;/a&gt;, &lt;a href="https://blog.siphos.be/2018/01/structuring-a-configuration-baseline/"&gt;second&lt;/a&gt; and &lt;a href="https://blog.siphos.be/2018/01/documenting-a-rule/"&gt;third&lt;/a&gt; post in this series), it is time to consider the validation of the settings in an automated manner. The preferred method for this is to use &lt;em&gt;Open Vulnerability and Assessment Language (OVAL)&lt;/em&gt;, which â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;With the configuration baseline for a technical service being described fully (see the &lt;a href="https://blog.siphos.be/2018/01/documenting-configuration-changes/"&gt;first&lt;/a&gt;, &lt;a href="https://blog.siphos.be/2018/01/structuring-a-configuration-baseline/"&gt;second&lt;/a&gt; and &lt;a href="https://blog.siphos.be/2018/01/documenting-a-rule/"&gt;third&lt;/a&gt; post in this series), it is time to consider the validation of the settings in an automated manner. The preferred method for this is to use &lt;em&gt;Open Vulnerability and Assessment Language (OVAL)&lt;/em&gt;, which is nowadays managed by the &lt;a href="https://oval.cisecurity.org/"&gt;Center for Internet Security&lt;/a&gt;, abbreviated as CISecurity. Previously, OVAL was maintained and managed by Mitre under NIST supervision, and Google searches will often still point to the old sites. However, documentation is now maintained on CISecurity's &lt;a href="https://github.com/OVALProject/Language/tree/5.11.2/docs"&gt;github repositories&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But I digress...&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Read-only compliance validation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One of the main ideas with OVAL is to have a language (XML-based) that represents state information (what something should be) which can be verified in a read-only fashion. Even more, from an operational perspective, it is very important that compliance checks &lt;em&gt;do not alter&lt;/em&gt; anything, but only report.&lt;/p&gt;
&lt;p&gt;Within its design, OVAL engineering has considered how to properly manage huge sets of assessment rules, and how to document this in an unambiguous manner. In the previous blog posts, ambiguity was resolved through writing style, and not much through actual, enforced definitions.&lt;/p&gt;
&lt;p&gt;OVAL enforces this. You can't write a generic or ambiguous rule in OVAL. It is very specific, but that also means that it is daunting to implement the first few times. I've written many OVAL sets, and I still struggle with it (although that's because I don't do it enough in a short time-frame, and need to reread my own documentation regularly).&lt;/p&gt;
&lt;p&gt;The capability to perform read-only validation with OVAL leads to a number of possible use cases. In the &lt;a href="http://oval.mitre.org/language/version5.10/OVAL_Language_Specification_09-14-2011.pdf"&gt;5.10 specification&lt;/a&gt; a number of use cases are provided. Basically, it boils down to vulnerability discovery (is a system vulnerable or not), patch management (is the system patched accordingly or not), configuration management (are the settings according to the rules or not), inventory management (detect what is installed on the system or what the systems' assets are), malware and threat indicator (detect if a system has been compromised or particular malware is active), policy enforcement (verify if a client system adheres to particular rules before it is granted access to a network), change tracking (regularly validating the state of a system and keeping track of changes), and security information management (centralizing results of an entire organization or environment and doing standard analytics on it).&lt;/p&gt;
&lt;p&gt;In this blog post series, I'm focusing on configuration management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OVAL structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Although the OVAL standard (just like the XCCDF standard actually) entails a number of major components, I'm going to focus on the OVAL definitions. Be aware though that the results of an OVAL scan are also standardized format, as are results of XCCDF scans for instance.&lt;/p&gt;
&lt;p&gt;OVAL definitions have 4 to 5 blocks in them:
- the &lt;strong&gt;definition&lt;/strong&gt; itself, which describes what is being validated and how. It refers to one or more tests that are to be executed or validated for the definition result to be calculated
- the &lt;strong&gt;test&lt;/strong&gt; or tests, which are referred to by the definition. In each test, there is at least a reference to an object (what is being tested) and optionally to a state (what should the object look like)
- the &lt;strong&gt;object&lt;/strong&gt;, which is a unique representation of a resource or resources on the system (a file, a process, a mount point, a kernel parameter, etc.). Object definitions can refer to multiple resources, depending on the definition.
- the &lt;strong&gt;state&lt;/strong&gt;, which is a sort-of value mapping or validation that needs to be applied to an object to see if it is configured correctly
- the &lt;strong&gt;variable&lt;/strong&gt;, an optional definition which is what it sounds like, a variable that substitutes an abstract definition with an actual definition,  allowing to write more reusable tests.&lt;/p&gt;
&lt;p&gt;Let's get an example going, but without the XML structure, so in human language. We want to define that the Kerberos definition on a Linux system should allow forwardable tickets by default. This is accomplished by ensuring that, inside the &lt;code&gt;/etc/krb5.conf&lt;/code&gt; file (which is an INI-style configuration file), the value of the &lt;code&gt;forwardable&lt;/code&gt; key inside the &lt;code&gt;[libdefaults]&lt;/code&gt; section is set to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In OVAL, the definition itself will document the above in human readable text, assign it a unique ID (like &lt;code&gt;oval:com.example.oval:def:1&lt;/code&gt;) and mark it as being a definition for configuration validation (&lt;code&gt;compliance&lt;/code&gt;). Then, it defines the criteria that need to be checked in order to properly validate if the rule is applicable or not. These criteria include validation if the OVAL statement is actually being run on a Linux system (as it makes no sense to run it against a Cisco router) which is Kerberos enabled, and then the criteria of the file check itself. Each criteria links to a test.&lt;/p&gt;
&lt;p&gt;The test of the file itself links to an object and a state. There are a number of ways how we can check for this specific case. One is that the object is the &lt;code&gt;forwardable&lt;/code&gt; key in the &lt;code&gt;[libdefaults]&lt;/code&gt; section of the &lt;code&gt;/etc/krb5.conf&lt;/code&gt; file, and the state is the value &lt;code&gt;true&lt;/code&gt;. In this case, the state will point to those two entries (through their unique IDs) and define that the object must exist, and all matches must have a matching state. The "all matches" here is not that important, because there will generally only be one such definition in the &lt;code&gt;/etc/krb5.conf&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Note however that a different approach to the test can be declared as well. We could state that the object is the &lt;code&gt;[libdefaults]&lt;/code&gt; section inside the &lt;code&gt;/etc/krb5.conf&lt;/code&gt; file, and the state is the value &lt;code&gt;true&lt;/code&gt; for the &lt;code&gt;forwardable&lt;/code&gt; key. In this case, the test declares that multiple objects must exist, and (at least) one must match the state.&lt;/p&gt;
&lt;p&gt;As you can see, the OVAL language tries to map definitions to unambiguous definitions. So, how does this look like in OVAL XML?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The OVAL XML structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://blog.siphos.be/static/2018/oval.xml"&gt;full example&lt;/a&gt; contains a few more entries than those we declare next, in order to be complete. The most important definitions though are documented below.&lt;/p&gt;
&lt;p&gt;Let's start with the definition. As stated, it will refer to tests that need to match for the definition to be valid.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;definitions&amp;gt;
  &amp;lt;definition id=&amp;quot;oval:com.example.oval:def:1&amp;quot; version=&amp;quot;1&amp;quot; class=&amp;quot;compliance&amp;quot;&amp;gt;
    &amp;lt;metadata&amp;gt;
      &amp;lt;title&amp;gt;libdefaults.forwardable in /etc/krb5.conf must be set to true&amp;lt;/title&amp;gt;
      &amp;lt;affected family=&amp;quot;unix&amp;quot;&amp;gt;
        &amp;lt;platform&amp;gt;Red Hat Enterprise Linux 7&amp;lt;/platform&amp;gt;
      &amp;lt;/affected&amp;gt;
      &amp;lt;description&amp;gt;
        By default, tickets obtained from the Kerberos environment must be forwardable.
      &amp;lt;/description&amp;gt;
    &amp;lt;/metadata&amp;gt;
    &amp;lt;criteria operator=&amp;quot;AND&amp;quot;&amp;gt;
      &amp;lt;criterion test_ref=&amp;quot;oval:com.example.oval:tst:1&amp;quot; comment=&amp;quot;Red Hat Enterprise Linux is installed&amp;quot;/&amp;gt;
      &amp;lt;criterion test_ref=&amp;quot;oval:com.example.oval:tst:2&amp;quot; comment=&amp;quot;/etc/krb5.conf&amp;#39;s libdefaults.forwardable is set to true&amp;quot;/&amp;gt;
    &amp;lt;/criteria&amp;gt;
  &amp;lt;/definition&amp;gt;
&amp;lt;/definitions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first thing to keep in mind is the (weird) identification structure. Just like with XCCDF, it is not sufficient to have your own id convention. You need to start an id with &lt;code&gt;oval:&lt;/code&gt; followed by the reverse domain definition (here &lt;code&gt;com.example.oval&lt;/code&gt;), followed by the type (&lt;code&gt;def&lt;/code&gt; for definition) and a sequence number.&lt;/p&gt;
&lt;p&gt;Also, take a look at the criteria. Here, two tests need to be compliant (hence the &lt;code&gt;AND&lt;/code&gt; operator). However, more complex operations can be done as well. It is even allowed to nest multiple criteria, and refer to previous definitions, like so (taken from the &lt;a href="https://raw.githubusercontent.com/GovReady/ubuntu-scap/master/ssg-rhel6-oval.xml"&gt;ssg-rhel6-oval.xml file&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;criteria comment=&amp;quot;package hal removed or service haldaemon is not configured to start&amp;quot; operator=&amp;quot;OR&amp;quot;&amp;gt;
  &amp;lt;extend_definition comment=&amp;quot;hal removed&amp;quot; definition_ref=&amp;quot;oval:ssg:def:211&amp;quot;/&amp;gt;
  &amp;lt;criteria operator=&amp;quot;AND&amp;quot; comment=&amp;quot;service haldaemon is not configured to start&amp;quot;&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 0&amp;quot; test_ref=&amp;quot;oval:ssg:tst:212&amp;quot;/&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 1&amp;quot; test_ref=&amp;quot;oval:ssg:tst:213&amp;quot;/&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 2&amp;quot; test_ref=&amp;quot;oval:ssg:tst:214&amp;quot;/&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 3&amp;quot; test_ref=&amp;quot;oval:ssg:tst:215&amp;quot;/&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 4&amp;quot; test_ref=&amp;quot;oval:ssg:tst:216&amp;quot;/&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 5&amp;quot; test_ref=&amp;quot;oval:ssg:tst:217&amp;quot;/&amp;gt;
    &amp;lt;criterion comment=&amp;quot;haldaemon runlevel 6&amp;quot; test_ref=&amp;quot;oval:ssg:tst:218&amp;quot;/&amp;gt;
  &amp;lt;/criteria&amp;gt;
&amp;lt;/criteria&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, let's look at the tests.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;tests&amp;gt;
  &amp;lt;unix:file_test id=&amp;quot;oval:com.example.oval:tst:1&amp;quot; version=&amp;quot;1&amp;quot; check_existence=&amp;quot;all_exist&amp;quot; check=&amp;quot;all&amp;quot; comment=&amp;quot;/etc/redhat-release exists&amp;quot;&amp;gt;
    &amp;lt;unix:object object_ref=&amp;quot;oval:com.example.oval:obj:1&amp;quot; /&amp;gt;
  &amp;lt;/unix:file_test&amp;gt;
  &amp;lt;ind:textfilecontent54_test id=&amp;quot;oval:com.example.oval:tst:2&amp;quot; check=&amp;quot;all&amp;quot; check_existence=&amp;quot;all_exist&amp;quot; version=&amp;quot;1&amp;quot; comment=&amp;quot;The value of forwardable in /etc/krb5.conf&amp;quot;&amp;gt;
    &amp;lt;ind:object object_ref=&amp;quot;oval:com.example.oval:obj:2&amp;quot; /&amp;gt;
    &amp;lt;ind:state state_ref=&amp;quot;oval:com.example.oval:ste:2&amp;quot; /&amp;gt;
  &amp;lt;/ind:textfilecontent54_test&amp;gt;
&amp;lt;/tests&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There are two tests defined here. The first test just checks if &lt;code&gt;/etc/redhat-release&lt;/code&gt; exists. If not, then the test will fail and the definition itself will result to false (as in, not compliant). This isn't actually a proper definition, because you want the test to not run when it is on a different platform, but for the sake of example and simplicity, let's keep it as is.&lt;/p&gt;
&lt;p&gt;The second test will check for the value of the &lt;code&gt;forwardable&lt;/code&gt; key in &lt;code&gt;/etc/krb5.conf&lt;/code&gt;. For it, it refers to an object and a state. The test states that all objects must exist (&lt;code&gt;check_existence="all_exist"&lt;/code&gt;) and that all objects must match the state (&lt;code&gt;check="all"&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The object definition looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;objects&amp;gt;
  &amp;lt;unix:file_object id=&amp;quot;oval:com.example.oval:obj:1&amp;quot; comment=&amp;quot;The /etc/redhat-release file&amp;quot; version=&amp;quot;1&amp;quot;&amp;gt;
    &amp;lt;unix:filepath&amp;gt;/etc/redhat-release&amp;lt;/unix:filepath&amp;gt;
  &amp;lt;/unix:file_object&amp;gt;
  &amp;lt;ind:textfilecontent54_object id=&amp;quot;oval:com.example.oval:obj:2&amp;quot; comment=&amp;quot;The forwardable key&amp;quot; version=&amp;quot;1&amp;quot;&amp;gt;
    &amp;lt;ind:filepath&amp;gt;/etc/krb5.conf&amp;lt;/ind:filepath&amp;gt;
    &amp;lt;ind:pattern operation=&amp;quot;pattern match&amp;quot;&amp;gt;^\s*forwardable\s*=\s*((true|false))\w*&amp;lt;/ind:pattern&amp;gt;
    &amp;lt;ind:instance datatype=&amp;quot;int&amp;quot; operation=&amp;quot;equals&amp;quot;&amp;gt;1&amp;lt;/ind:instance&amp;gt;
  &amp;lt;/ind:textfilecontent54_object&amp;gt;
&amp;lt;/objects&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first object is a simple file reference. The second is a text file content object. More specifically, it matches the line inside &lt;code&gt;/etc/krb5.conf&lt;/code&gt; which has &lt;code&gt;forwardable = true&lt;/code&gt; or &lt;code&gt;forwardable = false&lt;/code&gt; in it. An expression is made on it, so that we can refer to the subexpression as part of the test.&lt;/p&gt;
&lt;p&gt;This test looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;states&amp;gt;
  &amp;lt;ind:textfilecontent54_state id=&amp;quot;oval:com.example.oval:ste:2&amp;quot; version=&amp;quot;1&amp;quot;&amp;gt;
    &amp;lt;ind:subexpression datatype=&amp;quot;string&amp;quot;&amp;gt;true&amp;lt;/ind:subexpression&amp;gt;
  &amp;lt;/ind:textfilecontent54_state&amp;gt;
&amp;lt;/states&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This test refers to a subexpression, and wants it to be &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testing the checks with Open-SCAP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The Open-SCAP tool is able to test OVAL statements directly. For instance, with the above definition in a file called &lt;code&gt;oval.xml&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ oscap oval eval --results oval-results.xml oval.xml
Definition oval:com.example.oval:def:1: true
Evaluation done.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The output of the command shows that the definition was evaluated successfully. If you want more information, open up the &lt;code&gt;oval-results.xml&lt;/code&gt; file which contains all the details about the test. This results file is also very useful while developing OVAL as it shows the entire result of objects, tests and so forth.&lt;/p&gt;
&lt;p&gt;For instance, the &lt;code&gt;/etc/redhat-release&lt;/code&gt; file was only checked to see if it exists, but the results file shows what other parameters can be verified with it as well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;unix-sys:file_item id=&amp;quot;1233781&amp;quot; status=&amp;quot;exists&amp;quot;&amp;gt;
  &amp;lt;unix-sys:filepath&amp;gt;/etc/redhat-release&amp;lt;/unix-sys:filepath&amp;gt;
  &amp;lt;unix-sys:path&amp;gt;/etc&amp;lt;/unix-sys:path&amp;gt;
  &amp;lt;unix-sys:filename&amp;gt;redhat-release&amp;lt;/unix-sys:filename&amp;gt;
  &amp;lt;unix-sys:type&amp;gt;regular&amp;lt;/unix-sys:type&amp;gt;
  &amp;lt;unix-sys:group_id datatype=&amp;quot;int&amp;quot;&amp;gt;0&amp;lt;/unix-sys:group_id&amp;gt;
  &amp;lt;unix-sys:user_id datatype=&amp;quot;int&amp;quot;&amp;gt;0&amp;lt;/unix-sys:user_id&amp;gt;
  &amp;lt;unix-sys:a_time datatype=&amp;quot;int&amp;quot;&amp;gt;1515186666&amp;lt;/unix-sys:a_time&amp;gt;
  &amp;lt;unix-sys:c_time datatype=&amp;quot;int&amp;quot;&amp;gt;1514927465&amp;lt;/unix-sys:c_time&amp;gt;
  &amp;lt;unix-sys:m_time datatype=&amp;quot;int&amp;quot;&amp;gt;1498674992&amp;lt;/unix-sys:m_time&amp;gt;
  &amp;lt;unix-sys:size datatype=&amp;quot;int&amp;quot;&amp;gt;52&amp;lt;/unix-sys:size&amp;gt;
  &amp;lt;unix-sys:suid datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:suid&amp;gt;
  &amp;lt;unix-sys:sgid datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:sgid&amp;gt;
  &amp;lt;unix-sys:sticky datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:sticky&amp;gt;
  &amp;lt;unix-sys:uread datatype=&amp;quot;boolean&amp;quot;&amp;gt;true&amp;lt;/unix-sys:uread&amp;gt;
  &amp;lt;unix-sys:uwrite datatype=&amp;quot;boolean&amp;quot;&amp;gt;true&amp;lt;/unix-sys:uwrite&amp;gt;
  &amp;lt;unix-sys:uexec datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:uexec&amp;gt;
  &amp;lt;unix-sys:gread datatype=&amp;quot;boolean&amp;quot;&amp;gt;true&amp;lt;/unix-sys:gread&amp;gt;
  &amp;lt;unix-sys:gwrite datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:gwrite&amp;gt;
  &amp;lt;unix-sys:gexec datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:gexec&amp;gt;
  &amp;lt;unix-sys:oread datatype=&amp;quot;boolean&amp;quot;&amp;gt;true&amp;lt;/unix-sys:oread&amp;gt;
  &amp;lt;unix-sys:owrite datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:owrite&amp;gt;
  &amp;lt;unix-sys:oexec datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:oexec&amp;gt;
  &amp;lt;unix-sys:has_extended_acl datatype=&amp;quot;boolean&amp;quot;&amp;gt;false&amp;lt;/unix-sys:has_extended_acl&amp;gt;
&amp;lt;/unix-sys:file_item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, this is just on OVAL level. The final step is to link it in the XCCDF file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Referring to OVAL in XCCDF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The XCCDF Rule entry allows for a &lt;code&gt;check&lt;/code&gt; element, which refers to an automated check for compliance.&lt;/p&gt;
&lt;p&gt;For instance, the above rule could be referred to like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;Rule id=&amp;quot;xccdf_com.example_rule_krb5-forwardable-true&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Enable forwardable tickets on RHEL systems&amp;lt;/title&amp;gt;
  ...
  &amp;lt;check system=&amp;quot;http://oval.mitre.org/XMLSchema/oval-definitions-5&amp;quot;&amp;gt;
    &amp;lt;check-content-ref href=&amp;quot;oval.xml&amp;quot; name=&amp;quot;oval:com.example.oval:def:1&amp;quot; /&amp;gt;
  &amp;lt;/check&amp;gt;
&amp;lt;/Rule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this set in the Rule, Open-SCAP can validate it while checking the configuration baseline:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ oscap xccdf eval --oval-results --results xccdf-results.xml xccdf.xml
...
Title   Enable forwardable kerberos tickets in krb5.conf libdefaults
Rule    xccdf_com.example_rule_krb5-forwardable-tickets
Ident   RHEL7-01007
Result  pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A huge advantage here is that, alongside the detailed results of the run, there is also better human readable output as it shows the title of the Rule being checked.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The detailed capabilities of OVAL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In the above example I've used two examples: a file validation (against &lt;code&gt;/etc/redhat-release&lt;/code&gt;) and a file content one (against &lt;code&gt;/etc/krb5.conf&lt;/code&gt;). However, OVAL has many more checks and support for it, and also has constraints that you need to be aware of.&lt;/p&gt;
&lt;p&gt;In the &lt;a href="https://github.com/OVALProject/Language/tree/master/docs"&gt;OVAL Project&lt;/a&gt; github account, the Language repository keeps track of the current documentation. By browsing through it, you'll notice that the OVAL capabilities are structured based on the target technology that you can check. Right now, this is AIX, Android, Apple iOS, Cisco ASA, Cisco CatOS, VMWare ESX, FreeBSD, HP-UX, Cisco iOS and iOS-XE, Juniper JunOS, Linux, MacOS, NETCONF, Cisco PIX, Microsoft SharePoint, Unix (generic), Microsoft Windows, and independent.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/OVALProject/Language/blob/master/docs/independent-definitions-schema.md"&gt;independent&lt;/a&gt; one contains tests and support for resources that are often reusable toward different platforms (as long as your OVAL and XCCDF supporting tools can run it on those platforms). A few notable supporting tests are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filehash58_test&lt;/code&gt; which can check for a number of common hashes (such as SHA-512 and MD5). This is useful when you want to make sure that a particular (binary or otherwise) file is available on the system. In enterprises, this could be useful for license files, or specific library files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;textfilecontent54_test&lt;/code&gt; which can check the content of a file, with support for regular expressions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xmlfilecontent_test&lt;/code&gt; which is a specialized test toward XML files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keep in mind though that, as we have seen above, INI files specifically have no specialization available. It would be nice if CISecurity would develop support for common textual data formats, such as CSV (although that one is easily interpretable with the existing ones), JSON, YAML and INI.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/OVALProject/Language/blob/master/docs/unix-definitions-schema.md"&gt;unix&lt;/a&gt; one contains tests specific to Unix and Unix-like operating systems (so yes, it is also useful for Linux), and together with the &lt;a href="https://github.com/OVALProject/Language/blob/master/docs/linux-definitions-schema.md"&gt;linux&lt;/a&gt; one a wide range of configurations can be checked. This includes support for generic extended attributes (&lt;code&gt;fileextendedattribute_test&lt;/code&gt;) as well as SELinux specific rules (&lt;code&gt;selinuxboolean_test&lt;/code&gt; and &lt;code&gt;selinuxsecuritycontext_test&lt;/code&gt;), network interface settings (&lt;code&gt;interface_test&lt;/code&gt;), runtime processes (&lt;code&gt;process58_test&lt;/code&gt;), kernel parameters (&lt;code&gt;sysctl_test&lt;/code&gt;), installed software tests (such as &lt;code&gt;rpminfo_test&lt;/code&gt; for RHEL and other RPM enabled operating systems) and more.&lt;/p&gt;</content><category term="Security"></category><category term="xccdf"></category><category term="oval"></category><category term="scap"></category><category term="baseline"></category></entry><entry><title>Doing a content check with OVAL</title><link href="https://blog.siphos.be/2013/12/doing-a-content-check-with-oval/" rel="alternate"></link><published>2013-12-24T04:25:00+01:00</published><updated>2013-12-24T04:25:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-12-24:/2013/12/doing-a-content-check-with-oval/</id><summary type="html">&lt;p&gt;Let's create an OVAL check to see if &lt;code&gt;/etc/inittab&lt;/code&gt;'s single user
definitions only refer to &lt;code&gt;/sbin/sulogin&lt;/code&gt; or &lt;code&gt;/sbin/rc single&lt;/code&gt;. First,
the skeleton:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;The first thing we notice is that there are several namespaces defined
within OVAL. These namespaces refer to â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Let's create an OVAL check to see if &lt;code&gt;/etc/inittab&lt;/code&gt;'s single user
definitions only refer to &lt;code&gt;/sbin/sulogin&lt;/code&gt; or &lt;code&gt;/sbin/rc single&lt;/code&gt;. First,
the skeleton:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;The first thing we notice is that there are several namespaces defined
within OVAL. These namespaces refer to the platforms on which the tests
can be executed. OVAL has independent definitions, unix-global
definitions or linux-specific definitions. You can find the overview of
&lt;a href="http://oval.mitre.org/language/version5.10.1/"&gt;all supported schemas and definitions
online&lt;/a&gt; - definitely
something to bookmark if you plan on developing your own OVAL checks.&lt;/p&gt;
&lt;p&gt;So let's create the definition:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;There is lots of information to be found in this simple snippet.&lt;/p&gt;
&lt;p&gt;First of all, notice the &lt;code&gt;class="compliance"&lt;/code&gt; part. OVAL definitions can
be given a class that informs the OVAL interpreter what kind of test it
is.&lt;/p&gt;
&lt;p&gt;Supported classes are:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;compliance&lt;/dt&gt;
&lt;dd&gt;Does the system adhere to a predefined wanted state&lt;/dd&gt;
&lt;dt&gt;inventory&lt;/dt&gt;
&lt;dd&gt;Is the given software or hardware available/installed on the system&lt;/dd&gt;
&lt;dt&gt;patch&lt;/dt&gt;
&lt;dd&gt;Is the selected patch installed on the system&lt;/dd&gt;
&lt;dt&gt;vulnerability&lt;/dt&gt;
&lt;dd&gt;Is the system vulnerable towards this particular exposure (CVE)&lt;/dd&gt;
&lt;dt&gt;miscellaneous&lt;/dt&gt;
&lt;dd&gt;Everything that doesn't fit the above&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Next, we see metadata that tells the OVAL interpreter that the
definition applies to Unix family systems, and more specifically a
Gentoo Linux system. However, this is not a CPE entry
(&lt;em&gt;cpe:/o:gentoo:linux&lt;/em&gt;). The idea is that the OVAL Interpreter should
interpret the information as it wants without focusing on CPE details -
I think (I might be mistaken though) because the SCAP standard does not
want to introduce loops - a CPE that refers to an OVAL to validate,
which in turn refers to the same CPE.&lt;/p&gt;
&lt;p&gt;Also, a reference is included in the OVAL. Remember that we also had
references in the XCCDF document? Well, the same is true for OVAL
statements - you can add in references that help administrators get more
information about a definition. In this case, it refers to a &lt;strong&gt;CCE
(Common Configuration Enumeration)&lt;/strong&gt; entry. You can find all official
CCE entries &lt;a href="https://nvd.nist.gov/cce/index.cfm"&gt;online as well&lt;/a&gt;. This
particular one, CCE-4241-6, sais:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CCE-4241-6  Platform: rhel5     Date: (C)2011-10-07   (M)2013-11-28

The requirement for a password to boot into single-user mode should be configured correctly.

Parameter: enabled/disabled

Technical Mechanism: via /etc/inittab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By requiring &lt;strong&gt;sulogin&lt;/strong&gt; or &lt;strong&gt;rc single&lt;/strong&gt; in &lt;code&gt;inittab&lt;/code&gt;, Gentoo Linux
will ask for the root password before granting a shell, thereby
complying with the requirement to have a password before providing a
shell in single-user mode.&lt;/p&gt;
&lt;p&gt;Finally, the definition refers to a single test, which we will now look
into:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;This particular test is part of the &lt;em&gt;independent&lt;/em&gt; definitions. Checking
the content of a file is something all platforms support. Within this
independent definition set, a &lt;a href="http://oval.mitre.org/language/version5.10.1/ovaldefinition/documentation/independent-definitions-schema.html"&gt;large set of
tests&lt;/a&gt;
are supported, including file hash checking (does the checksum of a file
still match), environment variable test (verifying the existence and
content of an environment variable), LDAP tests and also text file
content tests.&lt;/p&gt;
&lt;p&gt;In the test, there are two important attributes to closely look into:
&lt;code&gt;check&lt;/code&gt; and &lt;code&gt;check_existence&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;check_existence&lt;/code&gt; attribute tells the OVAL interpreter how to deal
with the object definition. In our case, the object will refer to the
lines in the &lt;code&gt;/etc/inittab&lt;/code&gt; file that match a certain pattern. With
&lt;code&gt;check_existence="at_least_one_exists"&lt;/code&gt; the OVAL interpreter knows it
has to have at least one line that matches the pattern before it can
continue. If no line matches, then the test fails.&lt;/p&gt;
&lt;p&gt;Other values for &lt;code&gt;check_existence&lt;/code&gt; are "all_exist" (every object
described must exist), any_exist (doesn't matter if zero, one or more
exists), none_exist (no object described must exist) and
"only_one_exists" (one, and only one match for the described objects
must exist).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;check&lt;/code&gt; attributes tells the OVAL interpreter how to match the
object (if there is one) with the state. In our example, &lt;code&gt;check="all"&lt;/code&gt;
tells the OVAL interpreter that all lines that match the object
definition must also match the state definition.&lt;/p&gt;
&lt;p&gt;Other values for &lt;code&gt;check&lt;/code&gt; are "at least one", "none satisfy" and "only
one". These should be self-explanatory. Notice that there are no
underscores involved here (unlike with the &lt;code&gt;check_existence&lt;/code&gt; attribute).&lt;/p&gt;
&lt;p&gt;See the &lt;a href="https://oval.mitre.org/language/version5.10.1/ovaldefinition/documentation/oval-common-schema.html"&gt;common
schema&lt;/a&gt;
for more general OVAL attribute information.&lt;/p&gt;
&lt;p&gt;The test refers to the following object:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;The object represents lines in the &lt;code&gt;/etc/inittab&lt;/code&gt; file that match the
expression &lt;code&gt;^[\S]+:S:[\S]+:.*&lt;/code&gt;. The OVAL definition uses &lt;a href="http://oval.mitre.org/language/about/perlre.html"&gt;perl-style
regular expressions&lt;/a&gt;,
so this means that the lines must start with a non-whitespace string,
followed by a colon (:), followed by the letter "S", followed by a
colon, followed by non-whitespace string, followed by colon and then a
remainder string.&lt;/p&gt;
&lt;p&gt;Also, the object evaluates if at least one such line is found.&lt;/p&gt;
&lt;p&gt;The state, also referred to by the test, looks like so:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;Here again we see a regular expression; this time, the expression sais
that the line must start with "su" and that the fourth field equals
&lt;code&gt;/sbin/rc single&lt;/code&gt; or &lt;code&gt;/sbin/sulogin&lt;/code&gt;. In our example, if there is at
least one "single user" line that does not match this expression, then
the OVAL statement will return a failure and the system is
non-compliant.&lt;/p&gt;
&lt;p&gt;Now you could be wondering if this is the best approach. We can create
an object that refers to all single-user lines in &lt;code&gt;/etc/inittab&lt;/code&gt; that do
not comply with the expression just in the object definition. The
expression would be more complex by itself, but wouldn't need a state
anymore. True, but the advantage here is that the object itself matches
all single user lines, and can be reused later in other tests. Also, if
we later evaluate the OVAL statements, we will get an overview of all
lines that match the object (and then evaluate these lines against the
state) - similar to the script output we got with SCE tests.&lt;/p&gt;
&lt;p&gt;We can create other OVALs for all other tests. To refer to these OVAL
tests in an XCCDF document, take a look at the following example:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;Instead of referring to the SCE engine (with
&lt;code&gt;system="http://open-scap.org/page/SCE"&lt;/code&gt;) we refer to the OVAL with
&lt;code&gt;system="http://oval.mitre.org/XMLSchema/oval-definitions-5"&lt;/code&gt;, point the
XCCDF interpreter where the OVAL statements are stored in
&lt;code&gt;href="gentoo-oval.xml"&lt;/code&gt; and what definition we want to test
(&lt;code&gt;oval:org.gentoo.dev.swift:def:22&lt;/code&gt;). The XCCDF interpreter will then
pass this information on to the OVAL interpreter (in case of openscap,
this is the same tool, but it doesn't have to be) so it can evaluate the
right OVAL statement on the system.&lt;/p&gt;
&lt;p&gt;In the next post, I'll use the &lt;a href="http://dev.gentoo.org/~swift/docs/security_benchmarks/guide-gentoo-xccdf.html"&gt;Gentoo Security
Benchmark&lt;/a&gt;
as a guide to explain how to further structure and document things in
XCCDF/OVAL.&lt;/p&gt;
&lt;p&gt;This post is part of a series on SCAP content:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/documenting-security-best-practices-xccdf-introduction/"&gt;Documenting security best practices - XCCDF
    introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/an-xccdf-skeleton-for-postgresql/"&gt;An XCCDF skeleton for
    PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/xccdf-documenting-a-bit-more-than-just-descriptions/"&gt;Documenting a bit more than just
    descriptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/running-a-bit-with-the-xccdf-document/"&gt;Running a bit with the XCCDF
    document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/remediation-through-scap/"&gt;Remediation through
    SCAP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/what-is-oval/"&gt;What is OVAL?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="Security"></category><category term="openscap"></category><category term="oval"></category><category term="scap"></category><category term="xccdf"></category></entry><entry><title>What is OVAL?</title><link href="https://blog.siphos.be/2013/12/what-is-oval/" rel="alternate"></link><published>2013-12-22T04:40:00+01:00</published><updated>2013-12-22T04:40:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-12-22:/2013/12/what-is-oval/</id><summary type="html">&lt;p&gt;Time to discuss &lt;strong&gt;OVAL (Open Vulnerability Assessment Language)&lt;/strong&gt;. In
all the &lt;a href="http://blog.siphos.be/2013/12/running-a-bit-with-the-xccdf-document/"&gt;previous
posts&lt;/a&gt;
I focused the checking of rules (does the system comply with the given
rule) on scripts, through the Script Check Engine supported by openscap.
The advantage of SCE is that most people can quickly provide automated
checks â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Time to discuss &lt;strong&gt;OVAL (Open Vulnerability Assessment Language)&lt;/strong&gt;. In
all the &lt;a href="http://blog.siphos.be/2013/12/running-a-bit-with-the-xccdf-document/"&gt;previous
posts&lt;/a&gt;
I focused the checking of rules (does the system comply with the given
rule) on scripts, through the Script Check Engine supported by openscap.
The advantage of SCE is that most people can quickly provide automated
checks to run in script format. But SCE has a few downsides.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You cannot guarantee that the scripts will do no harm on the system.
    A badly written script might manipulate system settings, get a huge
    amount of resources, leave stale result files on the system, flood
    file systems and more. If you get scripts from other parties, you'll
    need to review them thoroughly before running them against all
    your systems. Especially when you run the compliance validation tool
    (openscap in our example) as root.&lt;/li&gt;
&lt;li&gt;SCE support is only available for openscap (and perhaps one or
    two others) as it is not an international standard. If you use any
    of the &lt;a href="https://nvd.nist.gov/scapproducts.cfm"&gt;SCAP validated tools&lt;/a&gt;
    then you will not be able to benefit from the SCE scripts. And that
    would make the XCCDF document back to a purely documenting
    best practice.&lt;/li&gt;
&lt;li&gt;Every rule requires separate scripts, even though many of the rules
    will be very similar and thus reuse a lot of the scripts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OVAL on the other hand provides those advantages. An OVAL file is an XML
file that contains the tests to run, in an (I must say) somewhat complex
manner. Really, OVAL is not simple, but it does contain advantages that
SCE doesn't.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is a standard, part of the SCAP standards. OVAL files are
    reusable across multiple tools, allowing you to focus once on the
    rules rather than having to rewrite the rules for every time you
    change the tool.&lt;/li&gt;
&lt;li&gt;OVAL can be platform-agnostic. Of course, not all tests are
    platform-agnostic (validating registry keys is a Windows-only check)
    but many are.&lt;/li&gt;
&lt;li&gt;All rules can be mentioned in a single file (or spread across
    multiple files if that makes management easier), but more
    importantly rules will also reuse definitions from other rules. If
    you have three rules that pertain to a file (say &lt;code&gt;/etc/rc.conf&lt;/code&gt;)
    then the definition of that file is shared across all rules.&lt;/li&gt;
&lt;li&gt;The OVAL standard is designed to be non-intrusive. All declarations
    you do in an OVAL file are pure read-only statements. This gives
    more confidence to have OVAL statements from third parties ran
    across your organization. Of course, reviewing them never hurts, but
    you already know that they will not modify any setting.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Like SCE, OVAL checks are individual checks that are executed and
returned. They too return a success or failure (or error) and can
deliver more detailed information as part of their result (like the SCE
results output we looked at before) so allow administrators to
investigate further why a rule failed (without needing to log on to the
system and look for themselves).&lt;/p&gt;
&lt;p&gt;A basic structure of OVAL is a &lt;em&gt;definition&lt;/em&gt; that describes what the rule
is for. The definition refers to one or more &lt;em&gt;tests&lt;/em&gt; that are evaluated
on a system. These tests refer to an &lt;em&gt;object&lt;/em&gt; that needs to be checked,
and optionally a &lt;em&gt;state&lt;/em&gt; to which the object should (or shouldn't)
match.&lt;/p&gt;
&lt;p&gt;Consider the test we made with SCE to see if a platform is a Gentoo
Linux system:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="c1"&gt;# If /etc/gentoo-release exists then the system is a Gentoo Linux system.&lt;/span&gt;
&lt;span class="nb"&gt;test&lt;/span&gt; -f /etc/gentoo-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;XCCDF_RESULT_PASS&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;XCCDF_RESULT_FAIL&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In OVAL, this would be structured as follows (pseudo-OVAL):&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;definition&lt;/dt&gt;
&lt;dd&gt;The system is a Gentoo Linux system&lt;/dd&gt;
&lt;dt&gt;test&lt;/dt&gt;
&lt;dd&gt;The object that represents /etc/gentoo-release must exist&lt;/dd&gt;
&lt;dt&gt;object&lt;/dt&gt;
&lt;dd&gt;The /etc/gentoo-release file&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;The resulting OVAL file is quite complex for a simple rule. I see the
OVAL complexity as part of a normalization (similar to database
normalization) process to allow higher reuse. If we later want to check
the content of the &lt;code&gt;gentoo-release&lt;/code&gt; file, we will reuse the definition
(object with id &lt;em&gt;oval:org.gentoo.dev.swift:obj:1&lt;/em&gt;) rather than making a
second object for it, and use that definition to create new tests.&lt;/p&gt;
&lt;p&gt;The structure of OVAL is the same everywhere. First define the
definitions, then the tests, then the objects and then, optionally, the
states. A very important aspect is to have the identifiers (&lt;code&gt;id="..."&lt;/code&gt;)
correct. The structure of OVAL identifiers is standardized as well:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;namespace&lt;/dt&gt;
&lt;dd&gt;Like the namespace used in XCCDF documents, this is the reverse
notation of a domainname. In the example above, this
is org.gentoo.dev.swift.&lt;/dd&gt;
&lt;dt&gt;type&lt;/dt&gt;
&lt;dd&gt;The type of the entry in OVAL. This can be def (definition), tst
(test), obj (object), ste (state) or var (variable).&lt;/dd&gt;
&lt;dt&gt;id&lt;/dt&gt;
&lt;dd&gt;The identifier of this particular entry. This identifier has to be a
positive integer.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;By standardizing the identifiers, you can create repositories within
your organization, and have other teams reuse your OVAL components when
needed. As the identifier remains the same (even when you update the
OVAL object itself to be more precise) those tests keep validating
correctly. For instance, say that Gentoo Linux would be changed in the
future not to provide a &lt;code&gt;gentoo-release&lt;/code&gt; file anymore, but
&lt;code&gt;gentoo-linux-release&lt;/code&gt; file instead (not that it is planning that, it is
just hypothetical), then you can update the test (with description
"Gentoo Linux is installed") to check if either of the two files exist:&lt;/p&gt;
&lt;p&gt;(XML content lost due to blog conversion)&lt;/p&gt;
&lt;p&gt;If we save all Gentoo releated OVAL statements in a file called
&lt;code&gt;gentoo-oval.xml&lt;/code&gt; then we can update the &lt;code&gt;gentoo-cpe.xml&lt;/code&gt; file (which we
discussed in the past) to the following:&lt;/p&gt;
&lt;p&gt;(XML content lost during blog conversion)&lt;/p&gt;
&lt;p&gt;With this change, openscap (or any other XCCDF interpreter) will use the
OVAL definition to see if a platform is Gentoo Linux or not, and does
not need to execute the &lt;code&gt;gentoo-platform.sh&lt;/code&gt; script anymore, which is
now fully deprecated and superceded by the OVAL statement.&lt;/p&gt;
&lt;p&gt;In the next posts, I'll write up one of the other tests we had (which
checks the content of a file - one of the most used tests I think) in
OVAL, and have the XCCDF document updated to only use OVAL statements.&lt;/p&gt;
&lt;p&gt;This post is part of a series on SCAP content:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/documenting-security-best-practices-xccdf-introduction/"&gt;Documenting security best practices - XCCDF
    introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/an-xccdf-skeleton-for-postgresql/"&gt;An XCCDF skeleton for
    PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/xccdf-documenting-a-bit-more-than-just-descriptions/"&gt;Documenting a bit more than just
    descriptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/running-a-bit-with-the-xccdf-document/"&gt;Running a bit with the XCCDF
    document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.siphos.be/2013/12/remediation-through-scap/"&gt;Remediation through
    SCAP&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="Security"></category><category term="openscap"></category><category term="oval"></category><category term="scap"></category><category term="sce"></category><category term="xccdf"></category></entry><entry><title>Putting OVAL at work</title><link href="https://blog.siphos.be/2013/08/putting-oval-at-work/" rel="alternate"></link><published>2013-08-01T15:01:00+02:00</published><updated>2013-08-01T15:01:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-01:/2013/08/putting-oval-at-work/</id><summary type="html">&lt;p&gt;When we look at the &lt;a href="http://scap.nist.gov/"&gt;SCAP security standards&lt;/a&gt;,
you might get the feeling of "How does this work". The underlying
interfaces, like OVAL and XCCDF, might seem a bit daunting to implement.&lt;/p&gt;
&lt;p&gt;This is correct, but you need to remember that the standards are
protocols, agreements that can be made â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;When we look at the &lt;a href="http://scap.nist.gov/"&gt;SCAP security standards&lt;/a&gt;,
you might get the feeling of "How does this work". The underlying
interfaces, like OVAL and XCCDF, might seem a bit daunting to implement.&lt;/p&gt;
&lt;p&gt;This is correct, but you need to remember that the standards are
protocols, agreements that can be made across products so that several
products, each with their own expertise, can work together easily. It is
a matter of interoperability between components.&lt;/p&gt;
&lt;p&gt;Let's look at the following diagram to see how OVAL and XCCDF &lt;em&gt;can&lt;/em&gt; be
used. I'm not saying this is the only way forward, but it is a possible
approach.&lt;/p&gt;
&lt;p&gt;(Diagram lost during blog conversion)&lt;/p&gt;
&lt;p&gt;On the local side (and local here doesn't mean a single server, but
rather an organization or company) a list of checks is maintained. These
checks are OVAL checks, which can be downloaded from reputable sites
like NVD or are given to you by vendors (some vendors provide OVAL as
part of vulnerability reports). Do not expect this list to be hundreds
of checks - start small, the local database of checks will grow anyhow.&lt;/p&gt;
&lt;p&gt;The advantage is that the downloaded checks (OVALs) already have a
unique identifier (the OVAL ID). For instance, the check "Disable Java
in Firefox" for Windows is &lt;code&gt;oval:org.mitre.oval:def:12609&lt;/code&gt;. If
additional Windows operating systems are added, this ID remains the same
(it is updated) because the check (and purpose) remains the same.&lt;/p&gt;
&lt;p&gt;Locally, the OVAL checks are ran against targets by an OVAL interpreter.
Usually, you will have multiple interpreters in the organization, some
of them focused on desktops, some on servers, some perhaps on network
equipment, etc. By itself that doesn't matter, as long as they interpret
the OVAL checks. The list of targets to check against are usually
managed in a configuration management database.&lt;/p&gt;
&lt;p&gt;Targets can be of various granularity. The "Disable Java in Firefox"
will be against an operating system (where the check then sees if the
installed Firefox indeed has the setting disabled), but a check that
validates the permissions (rights) of a user will be against this user
account.&lt;/p&gt;
&lt;p&gt;The results of the OVAL checks are stored in a database that maps the
result against the target. By itself this result database does not
contain much more logic than "This rule is OK against this target and
that rule isn't" (well, there is some granularity, but not much more)
and the time stamp when this was done.&lt;/p&gt;
&lt;p&gt;Next comes the XCCDF. XCCDF defines the state that you want the system
to be in. It is a benchmark, a document describing how the system /
target should be configured. XCCDF documents usually contain the whole
shebang of configuration settings, and then differentiate them based on
profiles. For instance, a web server attached to the Internet might have
a different profile than a web server used internally or for development
purposes.&lt;/p&gt;
&lt;p&gt;The XCCDF document refers to OVAL checks, and thus uses the results from
the OVAL result database to see if a target is fully aligned with the
requirements or not. The XCCDF results themselves are also stored, often
together with exceptions (if any) that are approved (for instance, you
want to keep track of the workstations where Java &lt;em&gt;is&lt;/em&gt; enabled in
Firefox and only report for those systems where it is enabled by the
user without approval). Based on these results, reports can be generated
on the state of your park.&lt;/p&gt;
&lt;p&gt;Not all checks are already available as OVAL checks. Of course you can
write them yourself, but there are also other possibilities. Next to
OVAL, there are (less standardized) methods for doing checks which
integrate with XCCDF as well. The idea you'll need to focus on then is
the same as with OVAL: what is your source, how do you store it, you
need interpreters that can "play" it, and on the reporting side you'll
need to store the results so you can combine them later in your
reporting.&lt;/p&gt;</content><category term="Security"></category><category term="baseline"></category><category term="benchmark"></category><category term="oval"></category><category term="security"></category><category term="xccdf"></category></entry></feed>