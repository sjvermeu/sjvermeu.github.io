<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Simplicity is a form of art... - selinux</title><link href="https://blog.siphos.be/" rel="alternate"></link><link href="https://blog.siphos.be/tag/selinux/feed/atom.xml" rel="self"></link><id>https://blog.siphos.be/</id><updated>2021-01-06T20:00:00+01:00</updated><entry><title>SELinux System Administration 3rd Edition</title><link href="https://blog.siphos.be/2021/01/selinux-system-administration-3rd-edition/" rel="alternate"></link><published>2021-01-06T20:00:00+01:00</published><updated>2021-01-06T20:00:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2021-01-06:/2021/01/selinux-system-administration-3rd-edition/</id><summary type="html">&lt;p&gt;As I mentioned previously, recently my latest installment of "SELinux System
Administration" has been released by Packt Publishing. This is already the
third edition of the book, after the first (2013) and second (2016) editions
have gotten reasonable success given the technical and often hard nature of
full SELinux administration.&lt;/p&gt;
&lt;p&gt;Like with the previous editions, this book remains true to the public of
system administrators, rather than SELinux policy developers. Of course,
SELinux policy development is not ignored in the book.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;As I mentioned previously, recently my latest installment of "SELinux System
Administration" has been released by Packt Publishing. This is already the
third edition of the book, after the first (2013) and second (2016) editions
have gotten reasonable success given the technical and often hard nature of
full SELinux administration.&lt;/p&gt;
&lt;p&gt;Like with the previous editions, this book remains true to the public of
system administrators, rather than SELinux policy developers. Of course,
SELinux policy development is not ignored in the book.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;What has changed&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First and foremost, it of course updates the content of the previous edition
to be up to date with the latest evolutions within SELinux. There are no earth
shattering changes, so the second edition isn't suddenly deprecated. The examples
are brought up to date with a recent distribution setup, for which I used
Gentoo Linux and CentOS.&lt;/p&gt;
&lt;p&gt;The latter is, given the recent announcement of CentOS stopping support for
CentOS version 8 in general, a bit confrontational, although it doesn't
really matter that much for the scope of the book. I hope that &lt;a href="https://rockylinux.org/"&gt;Rocky
Linux&lt;/a&gt; will get the focus and support it deserves.&lt;/p&gt;
&lt;p&gt;Anyway, I digress. A significant part of the updates on the existing content
is on SELinux-enabled applications, applications that act as a so-called object
manager themselves. While quite a few were already covered in the past, these
applications continue to enhance their SELinux support, and in the third edition
a few of these receive a full dedicated chapter.&lt;/p&gt;
&lt;p&gt;There are also a small set of SELinux behavioral changes, like SELinux' NNP
support, as well as SELinux userspace changes like specific extended attributes
for restorecon.&lt;/p&gt;
&lt;p&gt;Most of the book though isn't about changes, but about new content.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What has been added&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As administrators face SELinux-aware applications more and more, the book
goes into much more detail on how to tune SELinux with those SELinux-aware
applications. If we look at the book's structure, you'll find that it has
roughly three parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Using SELinux, which covers the fundamentals of using SELinux and
   understanding what SELinux is.&lt;/li&gt;
&lt;li&gt;SELinux-aware platforms, which dives into the SELinux-aware application
   suites that administrators might come in contact with&lt;/li&gt;
&lt;li&gt;Policy management, which focuses on managing, analyzing and even
   developing SELinux policies.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By including additional content on SEPostgreSQL, libvirt, container
platforms like Kubernetes, and even Xen Security Modules (which is not
SELinux itself, but strongly influenced and aligned to it to the level
that it even uses the SELinux userspace utilities) the book is showing how
wide SELinux is being used.&lt;/p&gt;
&lt;p&gt;Even on policy development, the book now includes more support than before.
While another book of mine, SELinux Cookbook, is more applicable to policy
development, I did not want to keep administrators out of the loop on how
to develop SELinux policies at all. Especially not since there are more
tools available nowadays that support policy creation, like udica.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELinux CIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One of the changes I also introduced in the book is to include SELinux
Common Intermediate Language (CIL) information and support. When we need
to add in a small SELinux policy change, the book will suggest CIL based
changes as well.&lt;/p&gt;
&lt;p&gt;SELinux CIL is not commonly used in large-scale policy development. Or at
least, not directly. The most significant policy development out there,
the &lt;a href="https://github.com/SELinuxProject/refpolicy/wiki"&gt;SELinux Reference Policy&lt;/a&gt;,
does not use CIL directly itself, and the level of support you find for
the current development approach is very much the default way of working. So
I do not ignore this more traditional approach.&lt;/p&gt;
&lt;p&gt;The reason I did include more CIL focus is because CIL has a few advantages
up its sleeve that is harder to get with the traditional language. Nothing
major perhaps, but enough that I feel it should be more actively promoted
anyway. And this book is hopefully a nice start to it.&lt;/p&gt;
&lt;p&gt;I hope the book is a good read for administrators or even architects that
would like to know more about the technology.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="packt"></category><category term="book"></category></entry><entry><title>SELinux and extended permissions</title><link href="https://blog.siphos.be/2017/11/selinux-and-extended-permissions/" rel="alternate"></link><published>2017-11-20T17:00:00+01:00</published><updated>2017-11-20T17:00:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-11-20:/2017/11/selinux-and-extended-permissions/</id><summary type="html">&lt;p&gt;One of the features present in the &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Releases"&gt;August release&lt;/a&gt; of the SELinux user space is its support for ioctl xperm rules in modular policies. In the past, this was only possible in monolithic ones (and CIL). Through this, allow rules can be extended to not only cover source (domain) and target (resource) identifiers, but also a specific number on which it applies. And ioctl's are the first (and currently only) permission on which this is implemented.&lt;/p&gt;
&lt;p&gt;Note that ioctl-level permission controls isn't a new feature by itself, but the fact that it can be used in modular policies is.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;One of the features present in the &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Releases"&gt;August release&lt;/a&gt; of the SELinux user space is its support for ioctl xperm rules in modular policies. In the past, this was only possible in monolithic ones (and CIL). Through this, allow rules can be extended to not only cover source (domain) and target (resource) identifiers, but also a specific number on which it applies. And ioctl's are the first (and currently only) permission on which this is implemented.&lt;/p&gt;
&lt;p&gt;Note that ioctl-level permission controls isn't a new feature by itself, but the fact that it can be used in modular policies is.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;What is ioctl?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Many interactions on a Linux system are done through system calls. From a security perspective, most system calls can be properly categorized based on who is executing the call and what the target of the call is. For instance, the unlink() system call has the following prototype:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int unlink(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Considering that a process (source) is executing unlink (system call) against a target (path) is sufficient for most security implementations. Either the source has the permission to unlink that file or directory, or it hasn't. SELinux maps this to the unlink permission within the file or directory classes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : { file dir }  unlink;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, &lt;code&gt;ioctl()&lt;/code&gt; is somewhat different. It is a system call that allows device-specific operations which cannot be expressed by regular system calls. Devices can have multiple functions/capabilities, and with &lt;code&gt;ioctl()&lt;/code&gt; these capabilities can be interrogated or updated. It has the following interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int ioctl(int fd, unsigned long request, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The file descriptor is the target device on which an operation is launched. The second argument is the request, which is an integer whose value identifiers what kind of operation the &lt;code&gt;ioctl()&lt;/code&gt; call is trying to execute. So unlike regular system calls, where the operation itself is the system call, &lt;code&gt;ioctl()&lt;/code&gt; actually has a parameter that identifies this.&lt;/p&gt;
&lt;p&gt;A list of possible parameter values on a socket for instance is available in the Linux kernel source code, under &lt;a href="https://elixir.free-electrons.com/linux/latest/source/include/uapi/linux/sockios.h"&gt;include/uapi/linnux/sockios.h&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELinux allowxperm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For SELinux, having the purpose of the call as part of a parameter means that a regular mapping isn't sufficient. Allowing &lt;code&gt;ioctl()&lt;/code&gt; commands for a domain against a resource is expressed as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : &amp;lt;class&amp;gt; ioctl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This of course does not allow policy developers to differentiate between harmless or informative calls (like SIOCGIFHWADDR to obtain the hardware address associated with a network device) and impactful calls (like SIOCADDRT to add a routing table entry).&lt;/p&gt;
&lt;p&gt;To allow for a fine-grained policy approach, the SELinux developers introduced an extended allow permission, which is capable of differentiating based on an integer value.&lt;/p&gt;
&lt;p&gt;For instance, to allow a domain to get a hardware address (SIOCGIFHWADDR, which is 0x8927) from a TCP socket:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allowxperm &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : tcp_socket ioctl 0x8927;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This additional parameter can also be ranged:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allowxperm &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : &amp;lt;class&amp;gt; ioctl 0x8910-0x8927;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And of course, it can also be used to complement (i.e. allow all ioctl parameters except a certain value):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allowxperm &amp;lt;domain&amp;gt; &amp;lt;resource&amp;gt; : &amp;lt;class&amp;gt; ioctl ~0x8927;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Small or negligible performance hit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;According to a &lt;a href="http://kernsec.org/files/lss2015/vanderstoep.pdf"&gt;presentation given by Jeff Vander Stoep&lt;/a&gt; on the Linux Security Summit in 2015, the performance impact of this addition in SELinux is well under control, which helped in the introduction of this capability in the Android SELinux implementation.&lt;/p&gt;
&lt;p&gt;As a result, interested readers can find examples of allowxperm invocations in the SELinux policy in Android, such as in the &lt;a href="https://android.googlesource.com/platform/system/sepolicy/+/master/private/app.te"&gt;app.te&lt;/a&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# only allow unprivileged socket ioctl commands
allowxperm { appdomain -bluetooth } self:{ rawip_socket tcp_socket udp_socket } ioctl { unpriv_sock_ioctls unpriv_tty_ioctls };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with that, we again show how fine-grained the SELinux access controls can be.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="ioctl"></category></entry><entry><title>SELinux Userspace 2.7</title><link href="https://blog.siphos.be/2017/09/selinux-userspace-2.7/" rel="alternate"></link><published>2017-09-26T14:50:00+02:00</published><updated>2017-09-26T14:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-09-26:/2017/09/selinux-userspace-2.7/</id><summary type="html">&lt;p&gt;A few days ago, &lt;a href="http://blog.perfinion.com/"&gt;Jason "perfinion" Zaman&lt;/a&gt; stabilized the 2.7 SELinux userspace on
Gentoo. This release has quite a &lt;a href="https://raw.githubusercontent.com/wiki/SELinuxProject/selinux/files/releases/20170804/RELEASE-20170804.txt"&gt;few new features&lt;/a&gt;, which I'll cover in later
posts, but for distribution packagers the main change is that the userspace
now has many more components to package. The project has split up the
policycoreutils package in separate packages so that deployments can be made
more specific.&lt;/p&gt;
&lt;p&gt;Let's take a look at all the various userspace packages again, learn what their
purpose is, so that you can decide if they're needed or not on a system. Also,
when I cover the contents of a package, be aware that it is based on the deployment
on my system, which might or might not be a complete installation (as with Gentoo,
different USE flags can trigger different package deployments).&lt;/p&gt;
</summary><content type="html">&lt;p&gt;A few days ago, &lt;a href="http://blog.perfinion.com/"&gt;Jason "perfinion" Zaman&lt;/a&gt; stabilized the 2.7 SELinux userspace on
Gentoo. This release has quite a &lt;a href="https://raw.githubusercontent.com/wiki/SELinuxProject/selinux/files/releases/20170804/RELEASE-20170804.txt"&gt;few new features&lt;/a&gt;, which I'll cover in later
posts, but for distribution packagers the main change is that the userspace
now has many more components to package. The project has split up the
policycoreutils package in separate packages so that deployments can be made
more specific.&lt;/p&gt;
&lt;p&gt;Let's take a look at all the various userspace packages again, learn what their
purpose is, so that you can decide if they're needed or not on a system. Also,
when I cover the contents of a package, be aware that it is based on the deployment
on my system, which might or might not be a complete installation (as with Gentoo,
different USE flags can trigger different package deployments).&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;libsepol - manipulating SELinux binary policies&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The first package, known in Gentoo as &lt;code&gt;sys-libs/libsepol&lt;/code&gt;, is the library that
enables manipulating the SELinux binary policies. This is a core library, and is
the first SELinux userspace package that is installed on a system.&lt;/p&gt;
&lt;p&gt;It contains one command, &lt;code&gt;chkcon&lt;/code&gt;, which allows users to validate if a specific
security context exists within a binary policy file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ chkcon policy.29 user_u:user_r:mozilla_t:s0
user_u:user_r:mozilla_t:s0 is valid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The package does contain two manpages of old commands which are no longer available
(or I'm blind, either way, they're not installed and not found in the SELinux userspace
repository either) such as genpolusers and genpolbools.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libselinux - the main SELinux handling library&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The libselinux library, known in Gentoo as &lt;code&gt;sys-libs/libselinux&lt;/code&gt;, is the main SELinux
library. Almost all applications that are SELinux-aware (meaning they not only know SELinux
is a thing, but are actively modifying their behavior with SELinux-specific code) will
link to libselinux.&lt;/p&gt;
&lt;p&gt;Because it is so core, the package also provides the necessary bindings for different
scripting languages besides the standard shared objects approach, namely Python (as
many SELinux related tooling is written in Python) and Ruby.&lt;/p&gt;
&lt;p&gt;Next to the bindings and libraries, libselinux also offers quite a few executables
to query and manipulate SELinux settings on the system, which are shortly described
on the &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Tools"&gt;SELinux userspace wiki&lt;/a&gt; but repeated here for convenience. Most of these
are meant for debugging purposes, as they are simple wrappers toward the libselinux
provided functions, but some of them are often used by administrations.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;avcstat&lt;/code&gt; gives statistics about the in-kernel access vector cache, such as number
  of lookups, hits and misses&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_create&lt;/code&gt; queries the kernel security server for a transition decision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_av&lt;/code&gt; queries the kernel security server for an access vector decision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_relabel&lt;/code&gt; queries the kernel security server for a relabel decision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_member&lt;/code&gt; queries the kernel security server for a labeling decision on a
  polyinstantiated object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getconlist&lt;/code&gt; uses the &lt;code&gt;security\_compute\_user()&lt;/code&gt; function, and orders the resulting
  list based on the &lt;code&gt;default\_contexts&lt;/code&gt; file and per-user context files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getdefaultcon&lt;/code&gt; is like &lt;code&gt;getconlist&lt;/code&gt; but only returns the first context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_user&lt;/code&gt; queries the kernel security server fo a set of reachable user contexts
  from a source context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getfilecon&lt;/code&gt; gets the context of a file by path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getpidcon&lt;/code&gt; gets the context of a process by PID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getseuser&lt;/code&gt; queries the &lt;code&gt;seuser&lt;/code&gt; file for the resulting SELinux user and contxt for a
  particular linux login and login context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getsebool&lt;/code&gt; gets the current state of a SELinux boolean in the SELinux security server&lt;/li&gt;
&lt;li&gt;&lt;code&gt;matchpathcon&lt;/code&gt; queries the active filecontext file for how a particular path should
  be labeled&lt;/li&gt;
&lt;li&gt;&lt;code&gt;policyvers&lt;/code&gt; queries the kernel security server for the maximum policy version supported&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getenforce&lt;/code&gt; gets the enforcing state of the kernel access vector cache&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sefcontext_compile&lt;/code&gt; generates binary filecontext files, optimized for fast querying&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_lookup&lt;/code&gt; looks up what the target default context is for various classes
  (supporting the X related SELinux types, database types, etc.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_digest&lt;/code&gt; calculates the SHA1 digest of spec files, and returns a list
  of the specfiles used to calculate the digest. This is used by Android.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_partial_match&lt;/code&gt; determines if a direct or partial match is possible
  on a file path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selabel_lookup_best_match&lt;/code&gt; obtains the best matching SELinux security context
  for file-based operations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinux_check_securetty_context&lt;/code&gt; checks whether a SELinux tty security context
  is defined as a securetty context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinux_check_access&lt;/code&gt; checks if the source context has the access permission
  for the specified class on the target context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinuxexeccon&lt;/code&gt; reports the SELinux context for an executable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinuxenabled&lt;/code&gt; returns if SELinux is enabled or not&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setfilecon&lt;/code&gt; sets the context of a path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setenforce&lt;/code&gt; sets the enforcing state of the kernel access vector cache&lt;/li&gt;
&lt;li&gt;&lt;code&gt;togglesebool&lt;/code&gt; toggles a SELinux boolean, but only runtime (so it does not
  persist across reboots)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;checkpolicy - policy compiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The checkpolicy package, known in Gentoo as &lt;code&gt;sys-apps/checkpolicy&lt;/code&gt;, provides two
main applications, &lt;code&gt;checkpolicy&lt;/code&gt; and &lt;code&gt;checkmodule&lt;/code&gt;. Both applications are compilers
(unlike what the name implies) which build a binary SELinux policy. The main difference
between these two is that one builds a policy binary, whereas the other one builds a 
SELinux module binary.&lt;/p&gt;
&lt;p&gt;Developers don't often call these applications themselves, but use the build scripts.
For instance, the &lt;code&gt;semodule_package&lt;/code&gt; binary would be used to combine the binary policy
with additional files such as file contexts.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libsemanage - facilitating use of SELinux overall&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The libsemanage library, known in Gentoo as &lt;code&gt;sys-libs/libsemanage&lt;/code&gt;, contains SELinux
supporting functions that are needed for any regular SELinux use. Whereas libselinux
would be used everywhere, even for embedded systems, libsemanage is generally not for
embedded systems but is very important for Linux systems in overall.&lt;/p&gt;
&lt;p&gt;Most SELinux management applications that administrators come in contact with will be
linked with the libsemanage library. As can be expected, the &lt;code&gt;semanage&lt;/code&gt; application
as offered by the &lt;code&gt;selinux-python&lt;/code&gt; package is one of them.&lt;/p&gt;
&lt;p&gt;The only application that is provided by libsemanage is the &lt;code&gt;semanage_migrate_store&lt;/code&gt;,
used to migrate the policy store from the &lt;code&gt;/etc/selinux&lt;/code&gt; to the &lt;code&gt;/var/lib/selinux&lt;/code&gt;
location. This was done with the introduction of the 2.4 userspace.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-python - Python-based command-line management utilities&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-python package, known in Gentoo as &lt;code&gt;sys-apps/selinux-python&lt;/code&gt;, is one of
the split packages that originally where part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. It
contains the majority of management utilities that administrators use for handling
SELinux on their systems.&lt;/p&gt;
&lt;p&gt;The most known application here is &lt;code&gt;semanage&lt;/code&gt;, but it contains quite a few others
as well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sepolgen&lt;/code&gt; generates an initial SELinux policy module template, and is short for
  the &lt;code&gt;sepolicy generate&lt;/code&gt; command&lt;/li&gt;
&lt;li&gt;&lt;code&gt;audit2why&lt;/code&gt; translates SELinux audit messages into a description of why the access
  was denied. It is short for the &lt;code&gt;audit2allow -w&lt;/code&gt; command.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;audit2allow&lt;/code&gt; generates SELinux policy allow/dontaudit rules from logs of denied
  operations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sepolgen-ifgen&lt;/code&gt; generates an overview of available interfaces. This overview is used
  by &lt;code&gt;audit2allow&lt;/code&gt; to guess the right interface to use when allowing or dontauditing certain
  operations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sepolicy&lt;/code&gt; is the SELinux policy inspection tool, allowing to query various aspects of
  a SELinux configuration (namely booleans, communication flows, interfaces, network information
  and transition information). It also provides the ability to generate skeleton policies (as
  described with &lt;code&gt;sepolgen&lt;/code&gt;) and manual pages.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chcat&lt;/code&gt; changes a file's SELinux security category&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sepolgen-ifgen-attr-helper&lt;/code&gt; generates an overview of attributes and attribute mappings.
  This overview is used by &lt;code&gt;audit2allow&lt;/code&gt; to guess the right attribute to use when allowing
  or dontauditing certain operations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semanage&lt;/code&gt; is a SELinux policy management tool, allowing a multitude of operations
  against the SELinux policy and the configuration. This includes definition import/export,
  login mappings, user definitions, ports and interface management, module handling, 
  file contexts, booleans and more.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;semodule-utils - Developing SELinux modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The semodule-utils package, known in Gentoo as &lt;code&gt;sys-apps/semodule-utils&lt;/code&gt;, is another split package
that originally was part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. In it, SELinux policy module
development utilities are provided. The package is not needed for basic operations such
as loading and unloading modules though.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;semodule_expand&lt;/code&gt; expands a SELinux base module package into a kernel binary policy file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_deps&lt;/code&gt; shows the dependencies between SELinux policy packages&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_link&lt;/code&gt; links SELinux policy module packages together into a single SELinux policy
  module&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_unpackage&lt;/code&gt; extracts a SELinux module into the binary policy and its associated
  files (such as file context definitions)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule_package&lt;/code&gt; combines a modular binary policy file with its associated files (such
  as file context definitions) into a module package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;mcstrans - Translate context info in human readable names&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The mcstrans package, known in Gentoo as &lt;code&gt;sys-apps/mcstrans&lt;/code&gt;, is another split package
that originally was part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. In it, the MCS translation
daemon is hosted. This daemon translates the SELinux-specific context ranges, like 
&lt;code&gt;s0-s0:c0.c1024&lt;/code&gt; to a human-readable set, like &lt;code&gt;SystemLow-SystemHigh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is a purely cosmetic approach (as SELinux internally always uses the sensitivity
and category numbers) but helps when dealing with a large number of separate categories.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;restorecond - Automatically resetting file contexts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The restorecond package, known in Gentoo as &lt;code&gt;sys-apps/restorecond&lt;/code&gt;, is another split
package that originally was part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. It contains the
&lt;code&gt;restorecond&lt;/code&gt; daemon, which watches over files and directories and forces the right
SELinux label on it.&lt;/p&gt;
&lt;p&gt;This daemon was originally intended to resolve a missing feature in SELinux (having
more fine-grained rules for label naming) but with the named file transition support, the
need for this daemon has diminished a lot.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;secilc - SELinux common intermediate language compiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The secilc package, known in Gentoo as &lt;code&gt;sys-apps/secilc&lt;/code&gt;, is the CIL compiler which
builds kernel binary policies based on the passed on CIL code. Although the majority
of policy development still uses the more traditional SELinux language (and supporting
macro's from the reference policy), developers can already use CIL code for policy generation.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;secilc&lt;/code&gt;, a final policy file can be generated through the CIL code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-dbus - SELinux DBus server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-dbus package (not packaged in Gentoo at this moment) provides a SELinux DBus
service which systems can use to query and interact with SELinux management utilities
on the system. If installed, the &lt;code&gt;org.selinux&lt;/code&gt; domain is used for various supported
operations (such as listing SELinux modules, through &lt;code&gt;org.selinux.semodule_list&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-gui - Graphical SELinux settings manager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-gui package (not packaged in Gentoo at this moment) provides the
&lt;code&gt;system-config-selinux&lt;/code&gt; application which offers basic SELinux management support
in a graphical application. It supports boolean handling, file labeling, user mapping,
SELinux user management, network port definitions and module handling. As such, it can
be seen as the graphical helper utility for the &lt;code&gt;semanage&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selinux-sandbox - Sandbox utility utilizing SELinux sandbox domains&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The selinux-sandbox package (not packaged in Gentoo at this moment) is a set of scripts
to facilitate the creation of SELinux sandboxes. With these utilities, which not only
use SELinux sandbox domains like &lt;code&gt;sandbox_t&lt;/code&gt; but also Linux namespaces, end users can
launch applications in a restricted environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;policycoreutils - Core SELinux management utilities&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The policycoreutils package, known in Gentoo as &lt;code&gt;sys-apps/policycoreutils&lt;/code&gt;, contains 
basic SELinux tooling which is necessary to handle SELinux in a regular environment.
Supported utilities are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newrole&lt;/code&gt; to switch a user session from one role to another&lt;/li&gt;
&lt;li&gt;&lt;code&gt;secon&lt;/code&gt; to query the SELinux context of a file, program or user input&lt;/li&gt;
&lt;li&gt;&lt;code&gt;genhomedircon&lt;/code&gt; to regenerate home directory context files, necessary when new users are
  defined on the system&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setfiles&lt;/code&gt; to set SELinux file security contexts on resources&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semodule&lt;/code&gt; to list, load and unload SELinux modules&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run_init&lt;/code&gt; to launch an init script in the right domain&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open_init_pty&lt;/code&gt; to run a program under a pseudo terminal with the right context set&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sestatus&lt;/code&gt; to query current policy status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setsebool&lt;/code&gt; to set and, if wanted, persist a SELinux boolean value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selinuxconfig&lt;/code&gt; to display the current active configuration paths&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restorecon&lt;/code&gt; to set SELinux file security contexts on resources&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load_policy&lt;/code&gt; to load the SELinux policy, generally called from initramfs systems if the
  init system is not SELinux-aware&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restorecon_xattr&lt;/code&gt; manages the &lt;code&gt;security.restorecon_last&lt;/code&gt; extended attribute which is set
  by &lt;code&gt;setfiles&lt;/code&gt; or &lt;code&gt;restorecon&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gentoo also adds in two additional scripts:
* &lt;code&gt;rlpkg&lt;/code&gt; to reset file contexts on files provided by a Gentoo package
* &lt;code&gt;selocal&lt;/code&gt; to easily handle small SELinux rule additions to the active policy&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There are even more&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Attentive readers will notice that the &lt;code&gt;setools&lt;/code&gt; package is not discussed here. This package
is not provided by the SELinux userspace project, but is an important package for SELinux
policy developers as it contains the &lt;code&gt;sesearch&lt;/code&gt; command - an often used command to query
the active policy.&lt;/p&gt;
&lt;p&gt;The above list is thus a picture of the SELinux userspace utilities, which is becoming
quite a big application set now that some functionality is split off from the &lt;code&gt;policycoreutils&lt;/code&gt;
package.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="userspace"></category></entry><entry><title>Using nVidia with SELinux</title><link href="https://blog.siphos.be/2017/08/using-nvidia-with-selinux/" rel="alternate"></link><published>2017-08-23T19:04:00+02:00</published><updated>2017-08-23T19:04:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-08-23:/2017/08/using-nvidia-with-selinux/</id><summary type="html">&lt;p&gt;Yesterday I've &lt;a href="http://blog.siphos.be/2017/08/switch-to-gentoo-sources/"&gt;switched to the gentoo-sources kernel package&lt;/a&gt; on Gentoo Linux.
And with that, I also attempted (succesfully) to use the propriatary nvidia drivers
so that I can enjoy both a smoother 3D experience while playing minecraft, as well
as use the CUDA support so I don't need to use cloud-based services for small
exercises.&lt;/p&gt;
&lt;p&gt;The move to nvidia was quite simple, as the &lt;a href="https://wiki.gentoo.org/wiki/NVidia/nvidia-drivers"&gt;nvidia-drivers wiki article&lt;/a&gt; on
the Gentoo wiki was quite easy to follow.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Yesterday I've &lt;a href="http://blog.siphos.be/2017/08/switch-to-gentoo-sources/"&gt;switched to the gentoo-sources kernel package&lt;/a&gt; on Gentoo Linux.
And with that, I also attempted (succesfully) to use the propriatary nvidia drivers
so that I can enjoy both a smoother 3D experience while playing minecraft, as well
as use the CUDA support so I don't need to use cloud-based services for small
exercises.&lt;/p&gt;
&lt;p&gt;The move to nvidia was quite simple, as the &lt;a href="https://wiki.gentoo.org/wiki/NVidia/nvidia-drivers"&gt;nvidia-drivers wiki article&lt;/a&gt; on
the Gentoo wiki was quite easy to follow.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Signing the modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One difference I found with the article (which I've promply changed) is that
the signing command, necessary to sign the Linux kernel modules so that they
can be loaded (as unsigned or wrongly signed modules are not allowed on the
system), was different.&lt;/p&gt;
&lt;p&gt;It used to be as follows (example for a single module, it had to be repeated
for each affected kernel module):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# perl /usr/src/linux/scripts/sign-file sha512 \
      /usr/src/linux/signing_key.priv \
      /usr/src/linux/signing_key.x509 \
      /lib/modules/4.12.5-gentoo/video/nvidia-uvm.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, from version 4.3.3 onward (as also explained by this excellent
&lt;a href="https://wiki.gentoo.org/wiki/Signed_kernel_module_support"&gt;Signed kernel module support article&lt;/a&gt; on the Gentoo wiki) this command
no longer uses a Perl script, but is an ELF binary. Also, the location
of the default signing key is moved into a &lt;code&gt;certs/&lt;/code&gt; subdirectory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enabling nvidia device files&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When the nvidia modules are loaded, additional device files are enabled.
One is the &lt;code&gt;nvidia0&lt;/code&gt; character device file, while the other is the
&lt;code&gt;nvidiactl&lt;/code&gt; character device file. And although I can imagine that the
&lt;code&gt;nvidiactl&lt;/code&gt; one is a control-related device file, I don't exactly know
for sure.&lt;/p&gt;
&lt;p&gt;However, attempts to use 3D applications showed (through SELinux denials)
that access to these device files is needed. Without that, applications just
crashed, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;org.lwjgl.LWJGLException: X Error - disp: 0x7fd164907b00 serial: 150 error: BadValue (integer parameter out of range for operation) request_code: 153 minor_code: 24
        at org.lwjgl.opengl.LinuxDisplay.globalErrorHandler(LinuxDisplay.java:320)
        at org.lwjgl.opengl.LinuxContextImplementation.nCreate(Native Method)
        at org.lwjgl.opengl.LinuxContextImplementation.create(LinuxContextImplementation.java:51)
        at org.lwjgl.opengl.ContextGL.&amp;lt;init&amp;gt;(ContextGL.java:132)
        at org.lwjgl.opengl.Display.create(Display.java:850)
        at org.lwjgl.opengl.Display.create(Display.java:757)
        at org.lwjgl.opengl.Display.create(Display.java:739)
        at bib.at(SourceFile:635)
        at bib.aq(SourceFile:458)
        at bib.a(SourceFile:404)
        at net.minecraft.client.main.Main.main(SourceFile:123)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Not really useful to debug for me, but the SELinux denials were a bit more obvious,
showing requests for read and write to the &lt;code&gt;nvidiactl&lt;/code&gt; character device.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;code&gt;matchpathcon&lt;/code&gt; I found out that the device files had to have the
&lt;code&gt;xserver_misc_device_t&lt;/code&gt; type (which they didn't have to begin with, as the device
files were added after the automated &lt;code&gt;restorecon&lt;/code&gt; was done on the &lt;code&gt;/dev&lt;/code&gt; location).&lt;/p&gt;
&lt;p&gt;So, adding the following command to my local init script fixed the context setting
at boot up:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;restorecon /dev/nvidiactl /dev/nvidia0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Also, the domains that needed to use nVidia had to receive the following
addition SELinux-policy-wise:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dev_rw_xserver_misc(...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Perhaps this can be made more fine-grained (as there are several other device
files marked as &lt;code&gt;xserver_misc_device_t&lt;/code&gt;) but for now this should suffice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Optimus usage with X server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The other challenge I had was that my workstation uses an integrated Intel
device, and offloads calculations and rendering to nVidia. The detection by
X server did not work automatically though, and it took some fiddling to get
it to work.&lt;/p&gt;
&lt;p&gt;In the end, I had to add in an &lt;code&gt;nvidia.conf&lt;/code&gt; file inside &lt;code&gt;/etc/X11/xorg.conf.d&lt;/code&gt;
with the following content:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Section &amp;quot;ServerLayout&amp;quot;
        Identifier      &amp;quot;layout&amp;quot;
        Screen  0       &amp;quot;nvidia&amp;quot;
        Inactive        &amp;quot;intel&amp;quot;
EndSection

Section &amp;quot;Device&amp;quot;
        Identifier      &amp;quot;nvidia&amp;quot;
        Driver          &amp;quot;nvidia&amp;quot;
        BusID           &amp;quot;PCI:1:0:0&amp;quot;
EndSection

Section &amp;quot;Screen&amp;quot;
        Identifier      &amp;quot;nvidia&amp;quot;
        Device          &amp;quot;nvidia&amp;quot;
        Option          &amp;quot;AllowEmptyInitialConfiguration&amp;quot;
EndSection

Section &amp;quot;Device&amp;quot;
        Identifier      &amp;quot;intel&amp;quot;
        Driver          &amp;quot;modesetting&amp;quot;
EndSection

Section &amp;quot;Screen&amp;quot;
        Identifier      &amp;quot;intel&amp;quot;
        Device          &amp;quot;intel&amp;quot;
EndSection
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with a single &lt;code&gt;xrandr&lt;/code&gt; command I re-enabled split screen support (as by
default it now showed the same output on both screens):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ xrandr --output eDP-1-1 --left-of HDMI-1-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I also had to set the output source to the nVidia device, by adding the following
lines to my &lt;code&gt;~/.xinitrc&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xrandr --setprovideroutputsource modesetting NVIDIA-0
xrandr --auto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And with that, another thing was crossed off from my TODO list. Which has become
quite large after my holidays (went to Kos, Greece) as I had many books and articles
on my ebook reader with me, which inspired a lot.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="nvidia"></category></entry><entry><title>Switch to Gentoo sources</title><link href="https://blog.siphos.be/2017/08/switch-to-gentoo-sources/" rel="alternate"></link><published>2017-08-22T19:04:00+02:00</published><updated>2017-08-22T19:04:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2017-08-22:/2017/08/switch-to-gentoo-sources/</id><summary type="html">&lt;p&gt;You've might already read it on the Gentoo news site, the &lt;a href="https://www.gentoo.org/news/2017/08/19/hardened-sources-removal.html"&gt;Hardened Linux kernel sources
are removed from the tree&lt;/a&gt; due to the &lt;a href="http://grsecurity.net/"&gt;grsecurity&lt;/a&gt; change where the grsecurity
Linux kernel patches are no longer provided for free. The decision was made due to
supportability and maintainability reasons.&lt;/p&gt;
&lt;p&gt;That doesn't mean that users who want to stick with the grsecurity related hardening
features are left alone. &lt;a href="https://blogs.gentoo.org/ago/2017/08/21/sys-kernel-grsecurity-sources-available/#utm_source=feed&amp;amp;utm_medium=feed&amp;amp;utm_campaign=feed"&gt;Agostino Sarubbo has started providing sys-kernel/grsecurity-sources&lt;/a&gt;
for the users who want to stick with it, as it is based on &lt;a href="https://github.com/minipli/linux-unofficial_grsec"&gt;minipli's unofficial patchset&lt;/a&gt;.
I seriously hope that the patchset will continue to be maintained and, who knows, even evolve further.&lt;/p&gt;
&lt;p&gt;Personally though, I'm switching to the Gentoo sources, and stick with SELinux as one of the
protection measures. And with that, I might even start using my NVidia graphics card a bit more, 
as that one hasn't been touched in several years (I have an Optimus-capable setup with both an
Intel integrated graphics card and an NVidia one, but all attempts to use nouveau for the one game
I like to play - minecraft - didn't work out that well).&lt;/p&gt;
</summary><content type="html">&lt;p&gt;You've might already read it on the Gentoo news site, the &lt;a href="https://www.gentoo.org/news/2017/08/19/hardened-sources-removal.html"&gt;Hardened Linux kernel sources
are removed from the tree&lt;/a&gt; due to the &lt;a href="http://grsecurity.net/"&gt;grsecurity&lt;/a&gt; change where the grsecurity
Linux kernel patches are no longer provided for free. The decision was made due to
supportability and maintainability reasons.&lt;/p&gt;
&lt;p&gt;That doesn't mean that users who want to stick with the grsecurity related hardening
features are left alone. &lt;a href="https://blogs.gentoo.org/ago/2017/08/21/sys-kernel-grsecurity-sources-available/#utm_source=feed&amp;amp;utm_medium=feed&amp;amp;utm_campaign=feed"&gt;Agostino Sarubbo has started providing sys-kernel/grsecurity-sources&lt;/a&gt;
for the users who want to stick with it, as it is based on &lt;a href="https://github.com/minipli/linux-unofficial_grsec"&gt;minipli's unofficial patchset&lt;/a&gt;.
I seriously hope that the patchset will continue to be maintained and, who knows, even evolve further.&lt;/p&gt;
&lt;p&gt;Personally though, I'm switching to the Gentoo sources, and stick with SELinux as one of the
protection measures. And with that, I might even start using my NVidia graphics card a bit more, 
as that one hasn't been touched in several years (I have an Optimus-capable setup with both an
Intel integrated graphics card and an NVidia one, but all attempts to use nouveau for the one game
I like to play - minecraft - didn't work out that well).&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;How secure is Gentoo sources with SELinux?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It is hard to just say that one kernel tree or another is safe(r) or not. Security is not something
one can get with a simple check-list. It is a matter of properly configuring services and systems,
patching it when needed, limiting expoosure and what not.&lt;/p&gt;
&lt;p&gt;A huge advantage of grsecurity was that it had very insightful and advanced protection measures
(many of them focusing on memory-related attacks), and prevented unwanted behavior from applications
(and users) in a very fine-grained manner. With SELinux, I can still prevent some unwanted behavior,
but it is important to know that SELinux and grsecurity's kernel hardening features are orthogonal
to each other. It is only the grsecurity RBAC model that is somewhat in competition with SELinux.&lt;/p&gt;
&lt;p&gt;SELinux is able to define and manage behavior between types. However, within a single type, many
actions are not governed at all. SELinux can manage which types (domains) are able to invoke which
system calls, but once a call is allowed, SELinux doesn't do any additional controls anymore.&lt;/p&gt;
&lt;p&gt;Loosing protection controls from grsecurity, as a security activist, is not something I like. But
on the other hand, I need to consider the wide SELinux using audience in Gentoo, who is most likely
going to switch to the gentoo sources as well (at least the majority of them).&lt;/p&gt;
&lt;p&gt;Gentoo sources is not insecure by itself, as are many other kernel sources. A huge advantage is that
the gentoo sources are well maintained, so any kernel vulnerability that gets reported and fixed will
receive the proper fix in the Gentoo sources quickly as well (and if you think it can go even faster,
consider &lt;a href="https://wiki.gentoo.org/wiki/Project:Security/Padawan_Process"&gt;becoming a Gentoo security padawan&lt;/a&gt;. And with SELinux enabled, some additional security
controls can be implemented (the efficacy of it depends on the quality of the policy).&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project"&gt;Kernel Self Protection Project&lt;/a&gt; also aims to improve the Linux kernel security, and immediately
through upstreamed and accepted patches. This means that the protection measures, once in the kernel,
should remain inside (awkward regressions notwithstanding). I truly hope that the KSPP moves forward.
In the mean time, read up on the &lt;a href="https://www.kernel.org/doc/html/latest/security/self-protection.html"&gt;Kernel Self-Protection&lt;/a&gt; document to learn more about how to harden
the Linux kernel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So that's it, just one less security control?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For now, there is no immediate substitute. But that doesn't mean that there is nothing one can do
to increase the secure state of a Linux desktop, workstation or even IoT device. Although remotely
executable exploits do pop up and exist, many vulnerabilities in the Linux kernel are mainly exploitable
through a local access pattern.&lt;/p&gt;
&lt;p&gt;That means that vulnerabilities often can only be exploited through a local invocation (or through chaining
by using other vulnerabilities - often in completely different applications or services - in order to
execute the local malware). Hence, hardening of the entire system is extremely important.&lt;/p&gt;
&lt;p&gt;Previously, I had an account with multiple SELinux roles assigned to it. Depending on what I wanted to
do, I transitioned to the right role (either through the &lt;code&gt;newrole&lt;/code&gt; command, or through &lt;code&gt;sudo&lt;/code&gt; which
has integrated SELinux support). With the switch to the gentoo sources, I decided to make it a bit
harder for malware on my system to work: i start using separate Linux accounts depending on the purpose
(which I call persona).&lt;/p&gt;
&lt;p&gt;Developing SELinux policies is now done on a separate account, managing remote systems through another
account (although my servers use multi-factor authentication so there was already some additional safeguard
in place there), handling my side-work with another account, playing games with another account, etc.&lt;/p&gt;
&lt;p&gt;It isn't that I don't trust SELinux for this (as each domain is well isolated and controlled). But SELinux
cannot prevent vulnerabilities within applications if the action/result of a succesfully exploited
vulnerability does not change the expected behavior of the application versus the other resources
on the system (and even there, the fine-grained approach of policies might not even be sufficiently
fine-grained, as SELinux uses labels, and many resources have the same label assigned).&lt;/p&gt;
&lt;p&gt;Suppose some malware is able to capture me giving in my password, or is trying to phish for it. By
using separate accounts (with separate passphrazes of course) the impact is reduced a bit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Other things on the plate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The change to different accounts was one thing I wanted to establish before switching to a new kernel
tree. There are other aspects that I want to investigate in the near future as well though.&lt;/p&gt;
&lt;p&gt;First of all, I'm probably going to enable &lt;a href="https://github.com/Yubico/pam-u2f"&gt;U2F authentication&lt;/a&gt; on my workstation as well for
all interactive accounts. It has been on my list for quite some time, and quickly going through the
publicly available fora doesn't reveal any major challenges to do so. Build the PAM module, update
the PAM service configurations and you're done. Hopefully. ;-)&lt;/p&gt;
&lt;p&gt;Next, I'm going to play around a bit with &lt;a href="https://wiki.gentoo.org/wiki/AddressSanitizer"&gt;AddressSanitizer&lt;/a&gt;. ASAN was incompatible with grsecurity,
but now that that's out of the way, there's no reason not to investigate it further. I am not going
to enable it for the kernel though (as some KSPP implemented measures are incompatible with ASAN as well),
and probably not for my complete workstation yet (even though it is sufficiently powerful to handle the major
performance impact).&lt;/p&gt;
&lt;p&gt;I'm going to put some more focus on &lt;a href="https://wiki.gentoo.org/wiki/Integrity_Measurement_Architecture"&gt;Integrity Measurement Architecture support&lt;/a&gt;, although my main protection
measure with IMA - the TPM or Trusted Platform Module - has been fried (don't ask) so I can't use it anymore.
Perhaps I'm going to buy a very lightweight/small system with a TPM on it to continue development. We'll see.&lt;/p&gt;
&lt;p&gt;My current knowledge of &lt;a href="https://en.wikipedia.org/wiki/Seccomp"&gt;seccomp&lt;/a&gt; is fairly theoretical (with a few hands-on tutorials, but that's it). It
has been on my TODO list for some time to look in more depth to it. Perhaps this is the right time.&lt;/p&gt;</content><category term="Gentoo"></category><category term="gentoo"></category><category term="hardened"></category><category term="grsecurity"></category><category term="selinux"></category></entry><entry><title>SELinux System Administration, 2nd Edition</title><link href="https://blog.siphos.be/2016/12/selinux-system-administration-2nd-edition/" rel="alternate"></link><published>2016-12-22T19:26:00+01:00</published><updated>2016-12-22T19:26:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2016-12-22:/2016/12/selinux-system-administration-2nd-edition/</id><content type="html">&lt;p&gt;While still working on a few other projects, one of the time consumers of the
past half year (haven't you noticed? my blog was quite silent) has come to an
end: the &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-system-administration-second-edition"&gt;SELinux System Administration - Second Edition&lt;/a&gt;
book is now available. With almost double the amount of pages and a serious
update of the content, the book can now be bought either through Packt Publishing
itself, or the various online bookstores such as &lt;a href="https://www.amazon.com/SELinux-System-Administration-Sven-Vermeulen-ebook/dp/B01LWM02WI"&gt;Amazon&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With the holidays now approaching, I hope to be able to execute a few tasks
within the Gentoo community (and of the Gentoo Foundation) and get back on track.
Luckily, my absence was not jeopardizing the state of &lt;a href="https://wiki.gentoo.org/wiki/SELinux"&gt;SELinux&lt;/a&gt;
in Gentoo thanks to the efforts of Jason Zaman.&lt;/p&gt;
</content><category term="SELinux"></category><category term="selinux"></category><category term="gentoo"></category><category term="rhel"></category><category term="redhat"></category><category term="packt"></category><category term="book"></category><category term="publishing"></category></entry><entry><title>We do not ship SELinux sandbox</title><link href="https://blog.siphos.be/2016/09/we-do-not-ship-selinux-sandbox/" rel="alternate"></link><published>2016-09-27T20:47:00+02:00</published><updated>2016-09-27T20:47:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2016-09-27:/2016/09/we-do-not-ship-selinux-sandbox/</id><summary type="html">&lt;p&gt;A few days ago a vulnerability was reported in the SELinux sandbox user space
utility. The utility is part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. Luckily, Gentoo's
&lt;code&gt;sys-apps/policycoreutils&lt;/code&gt; package is not vulnerable - and not because we were
clairvoyant about this issue, but because we don't ship this utility.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;A few days ago a vulnerability was reported in the SELinux sandbox user space
utility. The utility is part of the &lt;code&gt;policycoreutils&lt;/code&gt; package. Luckily, Gentoo's
&lt;code&gt;sys-apps/policycoreutils&lt;/code&gt; package is not vulnerable - and not because we were
clairvoyant about this issue, but because we don't ship this utility.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;What is the SELinux sandbox?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SELinux sandbox utility, aptly named &lt;code&gt;sandbox&lt;/code&gt;, is a simple C application which
executes its arguments, but only after ensuring that the task it launches is
going to run in the &lt;code&gt;sandbox_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;This domain is specifically crafted to allow applications most standard privileges
needed for interacting with the user (so that the user can of course still use the
application) but removes many permissions that might be abused to either obtain 
information from the system, or use to try and exploit vulnerabilities to gain
more privileges. It also hides a number of resources on the system through
namespaces.&lt;/p&gt;
&lt;p&gt;It was &lt;a href="http://danwalsh.livejournal.com/28545.html"&gt;developed in 2009&lt;/a&gt; for Fedora
and Red Hat. Given the necessary SELinux policy support though, it was usable on
other distributions as well, and thus became part of the SELinux user space itself.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What is the vulnerability about?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SELinux sandbox utility used an execution approach that did not shield off
the users' terminal access sufficiently. In the &lt;a href="http://www.openwall.com/lists/oss-security/2016/09/25/1"&gt;POC post&lt;/a&gt;
we notice that characters could be sent to the terminal through the &lt;code&gt;ioctl()&lt;/code&gt;
function (which executes the ioctl system call used for input/output operations
against devices) which are eventually executed when the application finishes.&lt;/p&gt;
&lt;p&gt;That's bad of course. Hence the CVE-2016-7545 registration, and of course also
a possible &lt;a href="https://github.com/SELinuxProject/selinux/commit/acca96a135a4d2a028ba9b636886af99c0915379"&gt;fix has been committed upstream&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Why isn't Gentoo vulnerable / shipping with SELinux sandbox?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There's some history involved why Gentoo does not ship the SELinux sandbox (anymore).&lt;/p&gt;
&lt;p&gt;First of all, Gentoo already has a command that is called &lt;code&gt;sandbox&lt;/code&gt;, installed through
the &lt;code&gt;sys-apps/sandbox&lt;/code&gt; application. So back in the days that we still shipped with
the SELinux sandbox, we continuously had to patch &lt;code&gt;policycoreutils&lt;/code&gt; to use a
different name for the sandbox application (we used &lt;code&gt;sesandbox&lt;/code&gt; then).&lt;/p&gt;
&lt;p&gt;But then we had a couple of security issues with the SELinux sandbox application.
In 2011, &lt;a href="http://www.cvedetails.com/cve/CVE-2011-1011/"&gt;CVE-2011-1011&lt;/a&gt;
came up in which the &lt;code&gt;seunshare_mount&lt;/code&gt; function had a security issue. And in 2014,
&lt;a href="http://www.cvedetails.com/cve/CVE-2014-3215/"&gt;CVE-2014-3215&lt;/a&gt; came up with - again -
a security issue with &lt;code&gt;seunshare&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At that point, I had enough of this sandbox utility. First of all, it never quite worked
enough on Gentoo as it is (as it also requires a policy which is not part of the
upstream release) and given its wide open access approach (it was meant to contain
various types of workloads, so security concessions had to be made), I decided to
&lt;a href="http://blog.siphos.be/2014/05/dropping-sesandbox-support/"&gt;no longer support the SELinux sandbox in Gentoo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;None of the Gentoo SELinux users ever approached me with the question to add it back.&lt;/p&gt;
&lt;p&gt;And that is why Gentoo is not vulnerable to this specific issue.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="sandbox"></category><category term="gentoo"></category><category term="vulnerability"></category><category term="seunshare"></category></entry><entry><title>Getting su to work in init scripts</title><link href="https://blog.siphos.be/2015/09/getting-su-to-work-in-init-scripts/" rel="alternate"></link><published>2015-09-14T16:37:00+02:00</published><updated>2015-09-14T16:37:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-09-14:/2015/09/getting-su-to-work-in-init-scripts/</id><summary type="html">&lt;p&gt;While developing an init script which has to switch user, I got a couple of
errors from SELinux and the system itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;~# rc-service hadoop-namenode format&lt;/span&gt;
&lt;span class="go"&gt;Authenticating root.&lt;/span&gt;
&lt;span class="go"&gt; * Formatting HDFS ...&lt;/span&gt;
&lt;span class="go"&gt;su: Authentication service cannot retrieve authentication info&lt;/span&gt;
&lt;span class="gp gp-VirtualEnv"&gt;(Ignored)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</summary><content type="html">&lt;p&gt;While developing an init script which has to switch user, I got a couple of
errors from SELinux and the system itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;~# rc-service hadoop-namenode format&lt;/span&gt;
&lt;span class="go"&gt;Authenticating root.&lt;/span&gt;
&lt;span class="go"&gt; * Formatting HDFS ...&lt;/span&gt;
&lt;span class="go"&gt;su: Authentication service cannot retrieve authentication info&lt;/span&gt;
&lt;span class="gp gp-VirtualEnv"&gt;(Ignored)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;The authentication log shows entries such as the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Sep 14 20:20:05 localhost unix_chkpwd[5522]: could not obtain user info (hdfs)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I've always had issues with getting su to work properly again. Now that I have
what I think is a working set, let me document it for later (as I still need to
review why they are needed):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Allow initrc_t to use unix_chkpwd to check entries&lt;/span&gt;
&lt;span class="c1"&gt;# Without it gives the retrieval failure&lt;/span&gt;
&lt;span class="n"&gt;auth_domtrans_chk_passwd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initrc_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Allow initrc_t to query selinux access, otherwise avc assertion&lt;/span&gt;
&lt;span class="n"&gt;allow&lt;/span&gt; &lt;span class="n"&gt;initrc_t&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="ss"&gt;:netlink_selinux_socket&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;selinux_compute_access_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initrc_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Allow initrc_t to honor the pam_rootok setting&lt;/span&gt;
&lt;span class="n"&gt;allow&lt;/span&gt; &lt;span class="n"&gt;initrc_t&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="ss"&gt;:passwd&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;passwd&lt;/span&gt; &lt;span class="n"&gt;rootok&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With these SELinux rules, switching the user works as expected from within an
init script.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="initrc"></category></entry><entry><title>Custom CIL SELinux policies in Gentoo</title><link href="https://blog.siphos.be/2015/09/custom-cil-selinux-policies-in-gentoo/" rel="alternate"></link><published>2015-09-10T07:13:00+02:00</published><updated>2015-09-10T07:13:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-09-10:/2015/09/custom-cil-selinux-policies-in-gentoo/</id><summary type="html">&lt;p&gt;In Gentoo, we have been supporting &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file"&gt;custom policy packages&lt;/a&gt;
for a while now. Unlike most other distributions, which focus on binary packages,
Gentoo has always supported source-based packages as default (although 
&lt;a href="https://wiki.gentoo.org/wiki/Binary_package_guide"&gt;binary packages&lt;/a&gt; are 
supported as well).&lt;/p&gt;
&lt;p&gt;A recent &lt;a href="https://gitweb.gentoo.org/repo/gentoo.git/commit/?id=8f2aa45db35bbf3a74f8db09ece9edac60e79ee4"&gt;commit&lt;/a&gt;
now also allows CIL files to be used.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In Gentoo, we have been supporting &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file"&gt;custom policy packages&lt;/a&gt;
for a while now. Unlike most other distributions, which focus on binary packages,
Gentoo has always supported source-based packages as default (although 
&lt;a href="https://wiki.gentoo.org/wiki/Binary_package_guide"&gt;binary packages&lt;/a&gt; are 
supported as well).&lt;/p&gt;
&lt;p&gt;A recent &lt;a href="https://gitweb.gentoo.org/repo/gentoo.git/commit/?id=8f2aa45db35bbf3a74f8db09ece9edac60e79ee4"&gt;commit&lt;/a&gt;
now also allows CIL files to be used.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Policy ebuilds, how they work&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gentoo provides its own SELinux policy, based on the &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Reference_policy"&gt;reference policy&lt;/a&gt;, 
and provides per-module ebuilds (packages). For instance, the SELinux policy for
the &lt;a href="https://packages.gentoo.org/package/app-misc/screen"&gt;screen&lt;/a&gt; package is
provided by the &lt;a href="https://packages.gentoo.org/package/sec-policy/selinux-screen"&gt;sec-policy/selinux-screen&lt;/a&gt;
package.&lt;/p&gt;
&lt;p&gt;The package itself is pretty straight forward:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Copyright 1999-2015 Gentoo Foundation&lt;/span&gt;
&lt;span class="c1"&gt;# Distributed under the terms of the GNU General Public License v2&lt;/span&gt;
&lt;span class="c1"&gt;# $Id$&lt;/span&gt;
&lt;span class="nv"&gt;EAPI&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;5&amp;quot;&lt;/span&gt;

&lt;span class="nv"&gt;IUSE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;MODS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;screen&amp;quot;&lt;/span&gt;

inherit selinux-policy-2

&lt;span class="nv"&gt;DESCRIPTION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SELinux policy for screen&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$PV&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;9999&lt;/span&gt;* &lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nv"&gt;KEYWORDS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nv"&gt;KEYWORDS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~amd64 ~x86&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The real workhorse lays within a &lt;a href="https://devmanual.gentoo.org/eclass-writing/"&gt;Gentoo eclass&lt;/a&gt;,
something that can be seen as a library for ebuilds. It allows consolidation of functions and
activities so that a large set of ebuilds can be simplified. The more ebuilds are standardized,
the more development can be put inside an eclass instead of in the ebuilds. As a result, some
ebuilds are extremely simple, and the SELinux policy ebuilds are a good example of this.&lt;/p&gt;
&lt;p&gt;The eclass for SELinux policy ebuilds is called &lt;a href="https://devmanual.gentoo.org/eclass-reference/selinux-policy-2.eclass/index.html"&gt;selinux-policy-2.eclass&lt;/a&gt;
and holds a number of functionalities. One of these (the one we focus on right now)
is to support custom SELinux policy modules.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Custom SELinux policy ebuilds&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Whenever a user has a SELinux policy that is not part of the Gentoo policy repository,
then the user might want to provide these policies through packages still. This has
the advantage that Portage (or whatever package manager is used) is aware of the
policies on the system, and proper dependencies can be built in.&lt;/p&gt;
&lt;p&gt;To use a custom policy, the user needs to create an ebuild which informs the eclass
not only about the module name (through the &lt;code&gt;MODS&lt;/code&gt; variable) but also about the
policy files themselves. These files are put in the &lt;code&gt;files/&lt;/code&gt; location of the ebuild,
and referred to through the &lt;code&gt;POLICY_FILES&lt;/code&gt; variable:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Copyright 1999-2015 Gentoo Foundation&lt;/span&gt;
&lt;span class="c1"&gt;# Distributed under the terms of the GNU General Public License v2&lt;/span&gt;
&lt;span class="c1"&gt;# $Id$&lt;/span&gt;
&lt;span class="nv"&gt;EAPI&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;5&amp;quot;&lt;/span&gt;

&lt;span class="nv"&gt;IUSE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;MODS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;oracle&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;POLICY_FILES&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;oracle.te oracle.if oracle.fc&amp;quot;&lt;/span&gt;

inherit selinux-policy-2

&lt;span class="nv"&gt;DESCRIPTION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SELinux policy for screen&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$PV&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;9999&lt;/span&gt;* &lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nv"&gt;KEYWORDS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nv"&gt;KEYWORDS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~amd64 ~x86&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The eclass generally will try to build the policies, converting them into &lt;code&gt;.pp&lt;/code&gt;
files. With CIL, this is no longer needed. Instead, what we do is copy the &lt;code&gt;.cil&lt;/code&gt;
files straight into the location where we place the &lt;code&gt;.pp&lt;/code&gt; files.&lt;/p&gt;
&lt;p&gt;From that point onwards, managing the &lt;code&gt;.cil&lt;/code&gt; files is similar to &lt;code&gt;.pp&lt;/code&gt; files.
They are loaded with &lt;code&gt;semodule -i&lt;/code&gt; and unloaded with &lt;code&gt;semodule -r&lt;/code&gt; when needed.&lt;/p&gt;
&lt;p&gt;Enabling CIL in our ebuilds is a small improvement (after the heavy workload
to support the 2.4 userspace) which allows Gentoo to stay ahead in the SELinux
world.&lt;/p&gt;</content><category term="Gentoo"></category><category term="gentoo"></category><category term="cil"></category><category term="selinux"></category><category term="ebuild"></category><category term="eclass"></category></entry><entry><title>Using multiple OpenSSH daemons</title><link href="https://blog.siphos.be/2015/09/using-multiple-openssh-daemons/" rel="alternate"></link><published>2015-09-06T16:37:00+02:00</published><updated>2015-09-06T16:37:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-09-06:/2015/09/using-multiple-openssh-daemons/</id><summary type="html">&lt;p&gt;I administer a couple of systems which provide interactive access by end users,
and for this interactive access I position &lt;a href="http://www.openssh.com/"&gt;OpenSSH&lt;/a&gt;. 
However, I also use this for administrative access to the system, and I tend to
have harder security requirements for OpenSSH than most users do.&lt;/p&gt;
&lt;p&gt;For instance, on one system, end users with a userid + password use the
sFTP server for publishing static websites. Other access is prohibited,
so I really like this OpenSSH configuration to use chrooted users, internal
sftp support, whereas a different OpenSSH is used for administrative access
(which is only accessible by myself and some trusted parties).&lt;/p&gt;
</summary><content type="html">&lt;p&gt;I administer a couple of systems which provide interactive access by end users,
and for this interactive access I position &lt;a href="http://www.openssh.com/"&gt;OpenSSH&lt;/a&gt;. 
However, I also use this for administrative access to the system, and I tend to
have harder security requirements for OpenSSH than most users do.&lt;/p&gt;
&lt;p&gt;For instance, on one system, end users with a userid + password use the
sFTP server for publishing static websites. Other access is prohibited,
so I really like this OpenSSH configuration to use chrooted users, internal
sftp support, whereas a different OpenSSH is used for administrative access
(which is only accessible by myself and some trusted parties).&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Running multiple instances&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Although I might get a similar result with a single OpenSSH instance, I
prefer to have multiple instances for this. The default OpenSSH port is used
for the non-administrative access whereas administrative access is on a
non-default port. This has a number of advantages...&lt;/p&gt;
&lt;p&gt;First of all, the SSH configurations are simple and clean. No complex
configurations, and more importantly: easy to manage through configuration
management tools like &lt;a href="http://saltstack.com/"&gt;SaltStack&lt;/a&gt;, my current favorite
orchestration/automation tool.&lt;/p&gt;
&lt;p&gt;Different instances also allow for different operational support services.
There is different monitoring for end-user SSH access versus administrative
SSH access. Also the &lt;a href="https://wiki.gentoo.org/wiki/Fail2ban"&gt;fail2ban&lt;/a&gt; configuration
is different for these instances.&lt;/p&gt;
&lt;p&gt;I can also easily shut down the non-administrative service while ensuring that
administrative access remains operational - something important in case of
changes and maintenance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dealing with multiple instances and SELinux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Beyond enabling a non-default port for SSH (i.e. by marking it as &lt;code&gt;ssh_port_t&lt;/code&gt;
as well) there is little additional tuning necessary, but that doesn't mean that
there is no additional tuning possible.&lt;/p&gt;
&lt;p&gt;For instance, we could leverage MCS' categories to only allow users (and thus the
SSH daemon) access to the files assigned only that category (and not the rest)
whereas the administrative SSH daemon can access all categories.&lt;/p&gt;
&lt;p&gt;On an MLS enabled system we could even use different sensitivity levels, allowing
the administrative SSH to access the full scala whereas the user-facing SSH can
only access the lowest sensitivity level. But as I don't use MLS myself, I won't go
into detail for this.&lt;/p&gt;
&lt;p&gt;A third possibility would be to fine-tune the permissions of the SSH daemons. However,
that would require different types for the daemon, which requires the daemons to be
started through different scripts (so that we first transition to dedicated 
types) before they execute the SSHd binary (which has the &lt;code&gt;sshd_exec_t&lt;/code&gt; type
assigned).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Requiring pubkey and password authentication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Recent OpenSSH daemons allow &lt;a href="https://lwn.net/Articles/544640/"&gt;chaining multiple authentication methods&lt;/a&gt;
before access is granted. This allows the systems to force SSH key authentication first, and then -
after succesful authentication - require the password to be passed on as well. Or a
second step such as &lt;a href="https://wiki.archlinux.org/index.php/Google_Authenticator"&gt;Google Authenticator&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;AuthenticationMethods publickey,password
PasswordAuthentication yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I don't use the Google Authenticator, but the &lt;a href="https://developers.yubico.com/yubico-pam/"&gt;Yubico PAM module&lt;/a&gt;
to require additional authentication through my U2F dongle (so ssh key, password
and u2f key). Don't consider this three-factor authentication: one thing I know
(password) and two things I have (U2F and ssh key). It's more that I have a couple
of devices with a valid SSH key (laptop, tablet, mobile) which are of course targets
for theft.&lt;/p&gt;
&lt;p&gt;The chance that both one of those devices is stolen &lt;em&gt;together&lt;/em&gt; with the U2F
dongle (which I don't keep attached to those devices of course) is somewhat less.&lt;/p&gt;</content><category term="Free Software"></category><category term="openssh"></category><category term="ssh"></category><category term="u2f"></category><category term="selinux"></category></entry><entry><title>Doing away with interfaces</title><link href="https://blog.siphos.be/2015/08/doing-away-with-interfaces/" rel="alternate"></link><published>2015-08-29T11:30:00+02:00</published><updated>2015-08-29T11:30:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-29:/2015/08/doing-away-with-interfaces/</id><summary type="html">&lt;p&gt;CIL is SELinux' Common Intermediate Language, which brings on a whole new set of
possibilities with policy development. I hardly know CIL but am (slowly)
learning. Of course, the best way to learn is to try and do lots of things with
it, but real-life work and time-to-market for now forces me to stick with the
M4-based refpolicy one.&lt;/p&gt;
&lt;p&gt;Still, I do try out some things here and there, and one of the things I wanted
to look into was how CIL policies would deal with interfaces.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;CIL is SELinux' Common Intermediate Language, which brings on a whole new set of
possibilities with policy development. I hardly know CIL but am (slowly)
learning. Of course, the best way to learn is to try and do lots of things with
it, but real-life work and time-to-market for now forces me to stick with the
M4-based refpolicy one.&lt;/p&gt;
&lt;p&gt;Still, I do try out some things here and there, and one of the things I wanted
to look into was how CIL policies would deal with interfaces.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Recap on interfaces&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With the M4 based reference policy, interfaces are M4 macros that expand into
the standard SELinux rules. They are used by the reference policy to provide 
a way to isolate module-specific code and to have "public" calls.&lt;/p&gt;
&lt;p&gt;Policy modules are not allowed (by convention) to call types or domains that
are not defined by the same module. If they want to interact with those modules,
then they need to call the interface(s):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# module &amp;quot;ntp&amp;quot;
# domtrans: when executing an ntpd_exec_t binary, the resulting process 
#           runs in ntpd_t
interface(`ntp_domtrans&amp;#39;,`
  domtrans_pattern($1, ntpd_exec_t, ntpd_t)
)

# module &amp;quot;hal&amp;quot;
ntp_domtrans(hald_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above example, the purpose is to have &lt;code&gt;hald_t&lt;/code&gt; be able to execute
binaries labeled as &lt;code&gt;ntpd_exec_t&lt;/code&gt; and have the resulting process run as the
&lt;code&gt;ntpd_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;The following would not be allowed inside the hal module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;domtrans_pattern(hald_t, ntpd_exec_t, ntpd_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This would imply that both &lt;code&gt;hald_t&lt;/code&gt;, &lt;code&gt;ntpd_exec_t&lt;/code&gt; and &lt;code&gt;ntpd_t&lt;/code&gt; are defined
by the same module, which is not the case.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interfaces in CIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It &lt;em&gt;seems&lt;/em&gt; that CIL will not use interface files. Perhaps some convention
surrounding it will be created - to know this, we'll have to wait until a
"cilrefpolicy" is created. However, functionally, this is no longer necessary.&lt;/p&gt;
&lt;p&gt;Consider the &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; declaration from a &lt;a href="http://blog.siphos.be/2015/08/filtering-network-access-per-application/"&gt;previous post&lt;/a&gt;.
In it, we wanted to allow &lt;code&gt;mozilla_t&lt;/code&gt; to send and receive these packets. The 
example didn't use an interface-like construction for this, so let's see
how this would be dealt with.&lt;/p&gt;
&lt;p&gt;First, the module is slightly adjusted to create a &lt;em&gt;macro&lt;/em&gt; called &lt;code&gt;myhttp_sendrecv_client_packet&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;macro&lt;/span&gt; &lt;span class="nv"&gt;myhttp_sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Another module would then call this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call&lt;/span&gt; &lt;span class="nv"&gt;myhttp_sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it. When the policy modules are both loaded, then the &lt;code&gt;mozilla_t&lt;/code&gt; domain is able
to send and receive &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; labeled packets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There's more: namespaces&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But it doesn't end there. Whereas the reference policy had a single namespace
for the interfaces, CIL is able to use namespaces. It allows to create an almost
object-like approach for policy development.&lt;/p&gt;
&lt;p&gt;The above &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; definition could be written as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;myhttp&lt;/span&gt;
  &lt;span class="c1"&gt;; MyHTTP client packet&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;roletype&lt;/span&gt; &lt;span class="nv"&gt;object_r&lt;/span&gt; &lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;client_packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;macro&lt;/span&gt; &lt;span class="nv"&gt;sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="nv"&gt;client_packet_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The other module looks as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="nv"&gt;mozilla&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call&lt;/span&gt; &lt;span class="nv"&gt;myhttp.sendrecv_client_packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The result is similar, but not fully the same. The packet is no longer called
&lt;code&gt;myhttp_client_packet_t&lt;/code&gt; but &lt;code&gt;myhttp.client_packet_t&lt;/code&gt;. In other words, a period (&lt;code&gt;.&lt;/code&gt;)
is used to separate the object name (&lt;code&gt;myhttp&lt;/code&gt;) and the object/type (&lt;code&gt;client_packet_t&lt;/code&gt;)
as well as interface/macro (&lt;code&gt;sendrecv_client_packet&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;~$ sesearch -s mozilla_t -c packet -p send -Ad&lt;/span&gt;
&lt;span class="go"&gt;  ...&lt;/span&gt;
&lt;span class="go"&gt;  allow mozilla_t myhttp.client_packet_t : packet { send recv };&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And it looks that namespace support goes even further than that, but I still
need to learn more about it first.&lt;/p&gt;
&lt;p&gt;Still, I find this a good evolution. With CIL interfaces are no longer separate
from the module definition: everything is inside the CIL file. I secretly hope
that tools such as &lt;code&gt;seinfo&lt;/code&gt; would support querying macros as well.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="cil"></category></entry><entry><title>Why we do confine Firefox</title><link href="https://blog.siphos.be/2015/08/why-we-do-confine-firefox/" rel="alternate"></link><published>2015-08-11T19:18:00+02:00</published><updated>2015-08-11T19:18:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-11:/2015/08/why-we-do-confine-firefox/</id><summary type="html">&lt;p&gt;If you're a bit following the SELinux development community you will know
&lt;a href="http://danwalsh.livejournal.com"&gt;Dan Walsh&lt;/a&gt;, a &lt;a href="http://people.redhat.com/dwalsh/"&gt;Red Hat&lt;/a&gt;
security engineer. Today he &lt;a href="http://danwalsh.livejournal.com/72697.html"&gt;blogged&lt;/a&gt; 
about &lt;em&gt;CVE-2015-4495 and SELinux, or why doesn't SELinux confine Firefox&lt;/em&gt;. He 
should've asked why the &lt;em&gt;reference policy&lt;/em&gt; or &lt;em&gt;Red Hat/Fedora policy&lt;/em&gt; does not
confine Firefox, because SELinux is, as I've
&lt;a href="http://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/"&gt;mentioned before&lt;/a&gt;,
not the same as its policy.&lt;/p&gt;
&lt;p&gt;In effect, Gentoo's SELinux policy &lt;em&gt;does&lt;/em&gt; confine Firefox by default. One of the
principles we focus on in Gentoo Hardened is to
&lt;a href="https://wiki.gentoo.org/wiki/Project:SELinux/Development_policy#Develop_desktop_policies"&gt;develop desktop policies&lt;/a&gt;
in order to reduce exposure and information leakage of user documents. We might
not have the manpower to confine all desktop applications, but I do think it is
worthwhile to at least attempt to do this, even though what Dan Walsh mentioned
is also correct: desktops are notoriously difficult to use a mandatory access
control system on.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;If you're a bit following the SELinux development community you will know
&lt;a href="http://danwalsh.livejournal.com"&gt;Dan Walsh&lt;/a&gt;, a &lt;a href="http://people.redhat.com/dwalsh/"&gt;Red Hat&lt;/a&gt;
security engineer. Today he &lt;a href="http://danwalsh.livejournal.com/72697.html"&gt;blogged&lt;/a&gt; 
about &lt;em&gt;CVE-2015-4495 and SELinux, or why doesn't SELinux confine Firefox&lt;/em&gt;. He 
should've asked why the &lt;em&gt;reference policy&lt;/em&gt; or &lt;em&gt;Red Hat/Fedora policy&lt;/em&gt; does not
confine Firefox, because SELinux is, as I've
&lt;a href="http://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/"&gt;mentioned before&lt;/a&gt;,
not the same as its policy.&lt;/p&gt;
&lt;p&gt;In effect, Gentoo's SELinux policy &lt;em&gt;does&lt;/em&gt; confine Firefox by default. One of the
principles we focus on in Gentoo Hardened is to
&lt;a href="https://wiki.gentoo.org/wiki/Project:SELinux/Development_policy#Develop_desktop_policies"&gt;develop desktop policies&lt;/a&gt;
in order to reduce exposure and information leakage of user documents. We might
not have the manpower to confine all desktop applications, but I do think it is
worthwhile to at least attempt to do this, even though what Dan Walsh mentioned
is also correct: desktops are notoriously difficult to use a mandatory access
control system on.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;How Gentoo wants to support more confined desktop applications&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What Gentoo Hardened tries to do is to support the
&lt;a href="http://standards.freedesktop.org/basedir-spec/basedir-spec-0.8.html"&gt;XDG Base Directory Specification&lt;/a&gt;
for several documentation types. Downloads are marked as &lt;code&gt;xdg_downloads_home_t&lt;/code&gt;,
pictures are marked as &lt;code&gt;xdg_pictures_home_t&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;With those types defined, we grant the regular user domains full access to
those types, but start removing access to user content from applications. Rules
such as the following are commented out or removed from the policies:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# userdom_manage_user_home_content_dirs(mozilla_t)
# userdom_manage_user_home_content_files(mozilla_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Instead, we add in a call to a template we have defined ourselves:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userdom_user_content_access_template(mozilla, { mozilla_t mozilla_plugin_t })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This call makes access to user content optional through SELinux booleans. For
instance, for the &lt;code&gt;mozilla_t&lt;/code&gt; domain (which is used for Firefox), the following
booleans are created:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Read generic (user_home_t) user content
mozilla_read_generic_user_content       -&amp;gt;      true

# Read all user content
mozilla_read_all_user_content           -&amp;gt;      false

# Manage generic (user_home_t) user content
mozilla_manage_generic_user_content     -&amp;gt;      false

# Manage all user content
mozilla_manage_all_user_content         -&amp;gt;      false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, the default setting is that Firefox can read user content, but
only non-specific types. So &lt;code&gt;ssh_home_t&lt;/code&gt;, which is used for the SSH related
files, is not readable by Firefox with our policy &lt;em&gt;by default&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;By changing these booleans, the policy is fine-tuned to the requirements of
the administrator. On my systems, &lt;code&gt;mozilla_read_generic_user_content&lt;/code&gt; is switched
off.&lt;/p&gt;
&lt;p&gt;You might ask how we can then still support a browser if it cannot access user
content to upload or download. Well, as mentioned before, we support the XDG
types. The browser is allowed to manage &lt;code&gt;xdg_download_home_t&lt;/code&gt; files and
directories. For the majority of cases, this is sufficient. I also don't mind
copying over files to the &lt;code&gt;~/Downloads&lt;/code&gt; directory just for uploading files. But
I am well aware that this is not what the majority of users would want, which
is why the default is as it is.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is much more work to be done sadly&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As said earlier, the default policy will allow &lt;em&gt;reading&lt;/em&gt; of user files if those
files are not typed specifically. Types that are protected by our policy (but not
by the reference policy standard) includes SSH related files at &lt;code&gt;~/.ssh&lt;/code&gt; and
GnuPG files at &lt;code&gt;~/.gnupg&lt;/code&gt;. Even other configuration files, such as for my Mutt
configuration (&lt;code&gt;~/.muttrc&lt;/code&gt;) which contains a password for an IMAP server I connect
to, are not reachable.&lt;/p&gt;
&lt;p&gt;However, it is still far from perfect. One of the reasons is that many desktop
applications are not "converted" yet to our desktop policy approach. Yes, Chromium
is also already converted, and policies we've added such as for Skype also do not
allow direct access unless the user explicitly enabled it. But Evolution for instance
isn't yet.&lt;/p&gt;
&lt;p&gt;Converting desktop policies to a more strict setup requires lots of testing, which
translates to many human resources. Within Gentoo, only a few developers and 
contributors are working on policies, and considering that this is not a change
that is already part of the (upstream) reference policy, some contributors also
do not want to put lots of focus on it either. But without having done the works,
it will not be easy (nor probably acceptable) to upstream this (the XDG patch has
been submitted a few times already but wasn't deemed ready yet then).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Having a more restrictive policy isn't the end&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As the blog post of Dan rightly mentioned, there are still quite some other
ways of accessing information that we might want to protect. An application 
might not have access to user files, but can be able to communicate (for instance
through DBus) with an application that does, and through that instruct it to
pass on the data.&lt;/p&gt;
&lt;p&gt;Plugins might require permissions which do not match with the principles set up
earlier. When we tried out Google Talk (needed for proper Google Hangouts support)
we noticed that it requires many, many more privileges. Luckily, we were able to
write down and develop a policy for the Google Talk plugin (&lt;code&gt;googletalk_plugin_t&lt;/code&gt;)
so it is still properly confined. But this is just a single plugin, and I'm sure
that more plugins exist which will have similar requirements. Which leads to more
policy development.&lt;/p&gt;
&lt;p&gt;But having workarounds does not make the effort we do worthless. Being able to
work around a firewall through application data does not make the firewall
useless, it is just one of the many security layers. The same is true with SELinux
policies.&lt;/p&gt;
&lt;p&gt;I am glad that we at least try to confine desktop applications more, and
that Gentoo Hardened users who use SELinux are at least somewhat more protected
from the vulnerability (even with the default case) and that our investment for
this is sound.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="policy"></category><category term="firefox"></category><category term="cve"></category><category term="vulnerability"></category><category term="xdg"></category></entry><entry><title>Can SELinux substitute DAC?</title><link href="https://blog.siphos.be/2015/08/can-selinux-substitute-dac/" rel="alternate"></link><published>2015-08-09T14:48:00+02:00</published><updated>2015-08-09T14:48:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-09:/2015/08/can-selinux-substitute-dac/</id><summary type="html">&lt;p&gt;A nice &lt;a href="https://twitter.com/sjvermeu/status/630107879123623936"&gt;twitter discussion&lt;/a&gt;
with &lt;a href="https://twitter.com/erlheldata"&gt;Erling Hellens&lt;/a&gt; caught my full attention later
when I was heading home: Can SELinux substitute DAC? I know it can't and doesn't
in the current implementation, but why not and what would be needed?&lt;/p&gt;
&lt;p&gt;SELinux is implemented through the &lt;a href="https://en.wikipedia.org/wiki/Linux_Security_Modules"&gt;Linux Security Modules framework&lt;/a&gt;
which allows for different security systems to be implemented and integrated
in the Linux kernel. Through LSM, various security-sensitive operations can be
secured further through &lt;em&gt;additional&lt;/em&gt; access checks. This criteria was made to
have LSM be as minimally invasive as possible.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;A nice &lt;a href="https://twitter.com/sjvermeu/status/630107879123623936"&gt;twitter discussion&lt;/a&gt;
with &lt;a href="https://twitter.com/erlheldata"&gt;Erling Hellens&lt;/a&gt; caught my full attention later
when I was heading home: Can SELinux substitute DAC? I know it can't and doesn't
in the current implementation, but why not and what would be needed?&lt;/p&gt;
&lt;p&gt;SELinux is implemented through the &lt;a href="https://en.wikipedia.org/wiki/Linux_Security_Modules"&gt;Linux Security Modules framework&lt;/a&gt;
which allows for different security systems to be implemented and integrated
in the Linux kernel. Through LSM, various security-sensitive operations can be
secured further through &lt;em&gt;additional&lt;/em&gt; access checks. This criteria was made to
have LSM be as minimally invasive as possible.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;The LSM design&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The basic LSM design paper, called &lt;a href="http://www.kroah.com/linux/talks/usenix_security_2002_lsm_paper/lsm.pdf"&gt;Linux Security Modules: General Security
Support for the Linux Kernel&lt;/a&gt;
as presented in 2002, is still one of the better references for learning and
understanding LSM. It does show that there was a whish-list from the community
where LSM hooks could override DAC checks, and that it has been partially
implemented through permissive hooks (not to be mistaken with SELinux' 
permissive mode).&lt;/p&gt;
&lt;p&gt;However, this definitely is &lt;em&gt;partially&lt;/em&gt; implemented because there are quite
a few restrictions. One of them is that, if a request is made towards a
resource and the UIDs match (see page 3, figure 2 of the paper) then
the LSM hook is not consulted. When they don't match, a permissive LSM
hook can be implemented. Support for permissive hooks is implemented
for capabilities, a powerful DAC control that Linux supports and which is
implemented &lt;a href="http://www.hep.by/gnu/kernel/lsm/cap.html"&gt;through LSM&lt;/a&gt; as
well. I have &lt;a href="http://blog.siphos.be/tag/capabilities/index.html"&gt;blogged&lt;/a&gt;
about this nice feature a while ago.&lt;/p&gt;
&lt;p&gt;These restrictions are also why some other security-conscious developers,
such as &lt;a href="http://grsecurity.net/lsm.php"&gt;grsecurity's team&lt;/a&gt; and &lt;a href="https://www.rsbac.org/documentation/why_rsbac_does_not_use_lsm"&gt;RSBAC&lt;/a&gt;
do not use the LSM system. Well, it's not only through these restrictions
of course - other reasons play a role in them as well. But knowing what
LSM can (and cannot) do also shows what SELinux can and cannot do.&lt;/p&gt;
&lt;p&gt;The LSM design itself is already a reason why SELinux cannot substitute
DAC controls. But perhaps we could disable DAC completely and thus only
rely on SELinux?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disabling DAC in Linux would be an excessive workload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The discretionary access controls in the Linux kernel are not easy to remove.
They are often part of the code itself (just grep through the source code
after &lt;code&gt;-EPERM&lt;/code&gt;). Some subsystems which use a common standard approach (such
as VFS operations) can rely on good integrated security controls, but these
too often allow the operation if DAC allows it, and will only consult the LSM
hooks otherwise.&lt;/p&gt;
&lt;p&gt;VFS operations are the most known ones, but DAC controls go beyond file access.
It also entails reading program memory, sending signals to applications,
accessing hardware and more. But let's focus on the easier controls (as in,
easier to use examples for), such as sharing files between users, restricting
access to personal documents and authorizing operations in applications based
on the user id (for instance, the owner can modify while other users can only
read the file).&lt;/p&gt;
&lt;p&gt;We could "work around" the Linux DAC controls by running everything as a single user
(the root user) and having all files and resources be fully accessible by this
user. But the problem with that is that SELinux would not be able to take
over controls either, because you will need some user-based access controls,
and within SELinux this implies that a mapping is done from a user to a 
SELinux user. Also, access controls based on the user id would no longer work,
and unless the application is made SELinux-aware it would lack any authorization
system (or would need to implement it itself).&lt;/p&gt;
&lt;p&gt;With DAC Linux also provides quite some "freedom" which is well established
in the Linux (and Unix) environment: a simple security model where the user
and group membership versus the owner-privileges, group-privileges and
"rest"-privileges are validated. Note that SELinux does not really know
what a "group" is. It knows SELinux users, roles, types and sensitivities.&lt;/p&gt;
&lt;p&gt;So, suppose we would keep multi-user support in Linux but completely remove
the DAC controls and rely solely on LSM (and SELinux). Is this something
reusable?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using SELinux for DAC-alike rules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider the use case of two users. One user wants another user to read a few
of his files. With DAC controls, he can "open up" the necessary resources
(files and directories) through &lt;a href="https://wiki.gentoo.org/wiki/Filesystem/Access_Control_List_Guide"&gt;extended access control lists&lt;/a&gt;
so that the other user can access it. No need to involve administrators.&lt;/p&gt;
&lt;p&gt;With a MAC(-only) system, updates on the MAC policy usually require the security
administrator to write additional policy rules to allow something. With SELinux
(and without DAC) it would require the users to be somewhat isolated from each
other (otherwise the users can just access everything from each other), which
SELinux can do through &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Constraints#UBAC_-_User_Based_Access_Control"&gt;User Based Access Control&lt;/a&gt;,
but the target resource itself should be labeled with a type that is not managed
through the UBAC control. Which means that the users will need the privilege to
change labels to this type (which is possible!), &lt;em&gt;assuming&lt;/em&gt; such a type is already
made available for them. Users can't create new types themselves.&lt;/p&gt;
&lt;p&gt;UBAC is by default disabled in many distributions, because it has some nasty
side-effects that need to be taken into consideration. Just recently one of these
&lt;a href="http://oss.tresys.com/pipermail/refpolicy/2015-August/007704.html"&gt;came up on the refpolicy mailinglist&lt;/a&gt;.
But even with UBAC enabled (I have it enabled on most of my systems, but considering
that I only have a couple of users to manage and am administrator on these systems
to quickly "update" rules when necessary) it does not provide equal functionality as
DAC controls.&lt;/p&gt;
&lt;p&gt;As mentioned before, SELinux does not know group membership. In order to create
something group-like, we will probably need to consider roles. But in SELinux,
roles are used to define what types are transitionable towards - it is not a
membership approach. A type which is usable by two roles (for instance, the
&lt;code&gt;mozilla_t&lt;/code&gt; type which is allowed for &lt;code&gt;staff_r&lt;/code&gt; and &lt;code&gt;user_r&lt;/code&gt;) does not care about
the role. This is unlike group membership.&lt;/p&gt;
&lt;p&gt;Also, roles only focus on &lt;em&gt;transitionable&lt;/em&gt; types (known as domains). It does not
care about &lt;em&gt;accessible&lt;/em&gt; resources (regular file types for instance). In order to
allow one person to read a certain file type but not another, SELinux will need
to control that one person can read this file through a particular domain while
the other user can't. And given that domains are part of the SELinux policy, any
situation that the policy has not thought about before will not be easily adaptable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So, we can't do it?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, I'm pretty sure that a very extensive policy and set of rules can be made
for SELinux which would make a number of DAC permissions obsolete, and that we could
theoretically remove DAC from the Linux kernel.&lt;/p&gt;
&lt;p&gt;End users would require a huge training to work with this system, and it would not
be reusable across other systems in different environments, because the policy
will be too specific to the system (unlike the current reference policy based ones,
which are quite reusable across many distributions).&lt;/p&gt;
&lt;p&gt;Furthermore, the effort to create these policies would be extremely high, whereas
the DAC permissions are very simple to implement, and have been proven to be
well suitable for many secured systems. &lt;/p&gt;
&lt;p&gt;So no, unless you do massive engineering, I do not believe it is possible to
substitute DAC with SELinux-only controls.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="refpolicy"></category><category term="linux"></category><category term="dac"></category><category term="lsm"></category></entry><entry><title>Filtering network access per application</title><link href="https://blog.siphos.be/2015/08/filtering-network-access-per-application/" rel="alternate"></link><published>2015-08-07T03:49:00+02:00</published><updated>2015-08-07T03:49:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-07:/2015/08/filtering-network-access-per-application/</id><summary type="html">&lt;p&gt;Iptables (and the successor nftables) is a powerful packet filtering system in
the Linux kernel, able to create advanced firewall capabilities. One of the 
features that it &lt;em&gt;cannot&lt;/em&gt; provide is per-application filtering. Together with
SELinux however, it is possible to implement this on a &lt;em&gt;per domain&lt;/em&gt; basis.&lt;/p&gt;
&lt;p&gt;SELinux does not know applications, but it knows domains. If we ensure that each
application runs in its own domain, then we can leverage the firewall
capabilities with SELinux to only allow those domains access that we need.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Iptables (and the successor nftables) is a powerful packet filtering system in
the Linux kernel, able to create advanced firewall capabilities. One of the 
features that it &lt;em&gt;cannot&lt;/em&gt; provide is per-application filtering. Together with
SELinux however, it is possible to implement this on a &lt;em&gt;per domain&lt;/em&gt; basis.&lt;/p&gt;
&lt;p&gt;SELinux does not know applications, but it knows domains. If we ensure that each
application runs in its own domain, then we can leverage the firewall
capabilities with SELinux to only allow those domains access that we need.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;SELinux network control: packet types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The basic network control we need to enable is SELinux' packet types. Most
default policies will grant application domains the right set of packet types:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# sesearch -s mozilla_t -c packet -A
Found 13 semantic av rules:
   allow mozilla_t ipp_client_packet_t : packet { send recv } ; 
   allow mozilla_t soundd_client_packet_t : packet { send recv } ; 
   allow nsswitch_domain dns_client_packet_t : packet { send recv } ; 
   allow mozilla_t speech_client_packet_t : packet { send recv } ; 
   allow mozilla_t ftp_client_packet_t : packet { send recv } ; 
   allow mozilla_t http_client_packet_t : packet { send recv } ; 
   allow mozilla_t tor_client_packet_t : packet { send recv } ; 
   allow mozilla_t squid_client_packet_t : packet { send recv } ; 
   allow mozilla_t http_cache_client_packet_t : packet { send recv } ; 
 DT allow mozilla_t server_packet_type : packet recv ; [ mozilla_bind_all_unreserved_ports ]
 DT allow mozilla_t server_packet_type : packet send ; [ mozilla_bind_all_unreserved_ports ]
 DT allow nsswitch_domain ldap_client_packet_t : packet recv ; [ authlogin_nsswitch_use_ldap ]
 DT allow nsswitch_domain ldap_client_packet_t : packet send ; [ authlogin_nsswitch_use_ldap ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As we can see, the &lt;code&gt;mozilla_t&lt;/code&gt; domain is able to send and receive packets of
type &lt;code&gt;ipp_client_packet_t&lt;/code&gt;, &lt;code&gt;soundd_client_packet_t&lt;/code&gt;, &lt;code&gt;dns_client_packet_t&lt;/code&gt;, 
&lt;code&gt;speech_client_packet_t&lt;/code&gt;, &lt;code&gt;ftp_client_packet_t&lt;/code&gt;, &lt;code&gt;http_client_packet_t&lt;/code&gt;, 
&lt;code&gt;tor_client_packet_t&lt;/code&gt;, &lt;code&gt;squid_client_packet_t&lt;/code&gt; and &lt;code&gt;http_cache_client_packet_t&lt;/code&gt;.
If the SELinux booleans mentioned at the end are enabled, additional packet
types are alloed to be used as well.&lt;/p&gt;
&lt;p&gt;But even with this default policy in place, SELinux is not being consulted for
filtering. To accomplish this, &lt;code&gt;iptables&lt;/code&gt; will need to be told to label the
incoming and outgoing packets. This is the &lt;a href="http://blog.siphos.be/2013/05/secmark-and-selinux/"&gt;SECMARK&lt;/a&gt;
functionality that I've blogged about earlier.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enabling SECMARK filtering through iptables&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To enable SECMARK filtering, we use the &lt;code&gt;iptables&lt;/code&gt; command and tell it to label
SSH incoming and outgoing packets as &lt;code&gt;ssh_server_packet_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# iptables -t mangle -A INPUT -m state --state ESTABLISHED,RELATED -j CONNSECMARK --restore
~# iptables -t mangle -A INPUT -p tcp --dport 22 -j SECMARK --selctx system_u:object_r:ssh_server_packet_t:s0
~# iptables -t mangle -A OUTPUT -m state --state ESTABLISHED,RELATED -j CONNSECMARK --restore
~# iptables -t mangle -A OUTPUT -p tcp --sport 22 -j SECMARK --selctx system_u:object_r:ssh_server_packet_t:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But be warned: the moment iptables starts with its SECMARK support, &lt;em&gt;all packets&lt;/em&gt;
will be labeled. Those that are not explicitly labeled through one of the above
commands will be labeled with the &lt;code&gt;unlabeled_t&lt;/code&gt; type, and most domains are not
allowed any access to &lt;code&gt;unlabeled_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are two things we can do to improve this situation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Define the necessary SECMARK rules for all supported ports (which is something
   that &lt;a href="https://www.linux.com/learn/tutorials/421152:using-selinux-and-iptables-together"&gt;secmarkgen&lt;/a&gt;
   does), and/or&lt;/li&gt;
&lt;li&gt;Allow &lt;code&gt;unlabeled_t&lt;/code&gt; for all domains.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To allow the latter, we can load a SELinux rule like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;domain&lt;/span&gt; &lt;span class="nv"&gt;unlabeled_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This will allow all domains to send and receive packets of the &lt;code&gt;unlabeled_t&lt;/code&gt; type.
Although this is something that might be security-sensitive, it might be a good idea
to allow at start, together with proper auditing (you can use &lt;code&gt;(auditallow ...)&lt;/code&gt; to
audit all granted packet communication) so that the right set of packet types can be
enabled. This way, administrators can iteratively improve the SECMARK rules and finally
remove the &lt;code&gt;unlabeled_t&lt;/code&gt; privilege from the &lt;code&gt;domain&lt;/code&gt; attribute.&lt;/p&gt;
&lt;p&gt;To list the current SECMARK rules, list the firewall rules for the &lt;code&gt;mangle&lt;/code&gt; table:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# iptables -t mangle -nvL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Only granting one application network access&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;These two together allow for creating a firewall that only allows a single domain
access to a particular target.&lt;/p&gt;
&lt;p&gt;For instance, suppose that we only want the &lt;code&gt;mozilla_t&lt;/code&gt; domain to connect to the
company proxy (10.15.10.5). We can't enable the &lt;code&gt;http_client_packet_t&lt;/code&gt; for this
connection, as all other web browsers and other HTTP-aware applications will have
policy rules enabled to send and receive that packet type. Instead, we are going
to create a new packet type to use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;;; Definition of myhttp_client_packet_t&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;roletype&lt;/span&gt; &lt;span class="nv"&gt;object_r&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;client_packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;packet_type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;; Grant the use to mozilla_t&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;typeattributeset&lt;/span&gt; &lt;span class="nv"&gt;cil_gen_require&lt;/span&gt; &lt;span class="nv"&gt;mozilla_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;allow&lt;/span&gt; &lt;span class="nv"&gt;mozilla_t&lt;/span&gt; &lt;span class="nv"&gt;myhttp_client_packet_t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;packet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;send&lt;/span&gt; &lt;span class="nv"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Putting the above in a &lt;code&gt;myhttppacket.cil&lt;/code&gt; file and loading it allows the type
to be used:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -i myhttppacket.cil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, the &lt;code&gt;myhttp_client_packet_t&lt;/code&gt; type can be used in &lt;code&gt;iptables&lt;/code&gt; rules. Also, 
only the &lt;code&gt;mozilla_t&lt;/code&gt; domain is allowed to send and receive these packets,
effectively creating an application-based firewall, as all we now need to do
is to mark the outgoing packets towards the proxy as &lt;code&gt;myhttp_client_packet_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# iptables -t mangle -A OUTPUT -p tcp --dport 80 -d 10.15.10.5 -j SECMARK --selctx system_u:object_r:myhttp_client_packet_t:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This shows that it is &lt;em&gt;possible&lt;/em&gt; to create such firewall rules with SELinux. It
is however not an out-of-the-box solution, requiring thought and development of
both firewall rules and SELinux code constructions. Still, with some advanced
scripting experience this will lead to a powerful addition to a hardened
system.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="network"></category><category term="iptables"></category></entry><entry><title>Don't confuse SELinux with its policy</title><link href="https://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/" rel="alternate"></link><published>2015-08-03T01:49:00+02:00</published><updated>2015-08-03T01:49:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-03:/2015/08/dont-confuse-selinux-with-its-policy/</id><summary type="html">&lt;p&gt;With the increased attention that SELinux is getting thanks to its inclusion in
recent &lt;a href="https://source.android.com/devices/tech/security/selinux/"&gt;Android&lt;/a&gt;
releases, more and more people are understanding that SELinux is not a singular
security solution. Many administrators are still disabling SELinux on their 
servers because it does not play well with their day-to-day operations. But
the Android inclusion shows that SELinux itself is not the culprit for this:
it is the policy.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;With the increased attention that SELinux is getting thanks to its inclusion in
recent &lt;a href="https://source.android.com/devices/tech/security/selinux/"&gt;Android&lt;/a&gt;
releases, more and more people are understanding that SELinux is not a singular
security solution. Many administrators are still disabling SELinux on their 
servers because it does not play well with their day-to-day operations. But
the Android inclusion shows that SELinux itself is not the culprit for this:
it is the policy.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Policy versus enforcement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELinux has conceptually segregated the enforcement from the rules/policy. 
There is an in-kernel enforcement (the SELinux subsystem) which is configured
through an administrator-provided policy (the SELinux rules). As long as 
SELinux was being used on servers, chances are very high that the policy that
is being used is based on the &lt;a href="https://github.com/TresysTechnology/refpolicy/wiki"&gt;SELinux Reference Policy&lt;/a&gt;
as this is, as far as I know, the only policy implementation for Linux systems
that is widely usable.&lt;/p&gt;
&lt;p&gt;The reference policy project aims to provide a well designed, broadly usable
yet still secure set of rules. And through this goal, it has to play ball with
all possible use cases that the various software titles require. Given the open
ecosystem of the free software world, and the Linux based ones in particular, 
managing such a policy is not for beginners. New policy development requires 
insight in the technology for which the policy is created, as well as knowledge
of how the reference policy works.&lt;/p&gt;
&lt;p&gt;Compare this to the Android environment. Applications have to follow more
rigid guidelines before they are accepted on Android systems. Communication
between applications and services is governed through Intents and Activities
which are managed by the &lt;a href="http://www.cubrid.org/blog/dev-platform/binder-communication-mechanism-of-android-processes/"&gt;Binder&lt;/a&gt;
application. Interactions with the user are based on well defined interfaces.
Heck, the Android OS even holds a number of permissions that applications
have to subscribe to before they can use it.&lt;/p&gt;
&lt;p&gt;Such an environment is much easier to create policies for, because it allows
policies to be created almost on-the-fly, with the application permissions
being mapped to predefined SELinux rules. Because the freedom of
implementations is limited (in order to create a manageable environment which
is used by millions of devices over the world) policies can be made more
strictly and yet enjoy the static nature of the environment: no continuous
updates on existing policies, something that Linux distributions have to do
on an almost daily basis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aiming for a policy development ecosystem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Having SELinux active on Android shows that one should not confuse SELinux
with its policies. SELinux is a nice security subsystem in the Linux kernel,
and can be used and tuned to cover whatever use case is given to it. The slow
adoption of SELinux by Linux distributions might be attributed to its lack
of policy diversification, which results in few ecosystems where additional
(and perhaps innovative) policies could be developed.&lt;/p&gt;
&lt;p&gt;It is however a huge advantage that a reference policy exists, so that
distributions can enjoy a working policy without having to put resources
into its own policy development and maintenance. Perhaps we should try to
further enhance the existing policies while support new policy ecosystems
and development initiatives.&lt;/p&gt;
&lt;p&gt;The maturation of the &lt;a href="https://github.com/SELinuxProject/cil/wiki"&gt;CIL&lt;/a&gt;
language by the &lt;a href="https://github.com/SELinuxProject/selinux"&gt;SELinux userland libraries and tools&lt;/a&gt;
might be a good catalyst for this. At one point, policies will need to be
migrated to CIL (although this can happen gradually as the userland utilities
can deal with CIL and other languages such as the legacy &lt;code&gt;.pp&lt;/code&gt; files 
simultaneously) and there are a few developers considering a renewal
of the reference policy. This would make use of the new benefits of the CIL
language and implementation: some restrictions that where applicable to the legacy
format no longer holds on CIL, such as rules which previously were only allowed
in the base policy which can now be made part of the modules as well.&lt;/p&gt;
&lt;p&gt;But next to renewing existing policies, there is plenty of room left for
innovative policy ideas and developments. The &lt;a href="http://selinuxproject.org/page/PolicyLanguage"&gt;SELinux language&lt;/a&gt;
is very versatile, and just like with programming languages we notice that only
a few set of constructs are used. Some applications might even benefit from
using SELinux as their decision and enforcement system (something that
&lt;a href="https://wiki.postgresql.org/wiki/SEPostgreSQL_Introduction"&gt;SEPostgreSQL&lt;/a&gt; has
tried).&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://freecomputerbooks.com/The-SELinux-Notebook-The-Foundations.html"&gt;SELinux Notebook&lt;/a&gt; by
Richard Haines is an excellent resource for developers that want to work more
closely with the SELinux language constructs. Just skimming through this resource
also shows how very open SELinux itself is, and that most of the users'
experience with SELinux is based on a singular policy implementation. This is
a prime reason why having a more open policy ecosystem makes perfect sense.&lt;/p&gt;
&lt;p&gt;If you don't like a particular car, do you ditch driving at all? No, you try out
another car. Let's create other cars in the SELinux world as well.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="policy"></category><category term="cil"></category></entry><entry><title>Loading CIL modules directly</title><link href="https://blog.siphos.be/2015/07/loading-cil-modules-directly/" rel="alternate"></link><published>2015-07-15T15:54:00+02:00</published><updated>2015-07-15T15:54:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-07-15:/2015/07/loading-cil-modules-directly/</id><summary type="html">&lt;p&gt;In a &lt;a href="http://blog.siphos.be/2015/06/where-does-cil-play-in-the-selinux-system/"&gt;previous
post&lt;/a&gt;
I used the &lt;code&gt;secilc&lt;/code&gt; binary to load an additional test policy. Little did
I know (and that's actually embarrassing because it was one of the
things I complained about) that you can just use the CIL policy as
modules directly.&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMMARY --&gt;

&lt;p&gt;With this I mean that a &lt;/p&gt;</summary><content type="html">&lt;p&gt;In a &lt;a href="http://blog.siphos.be/2015/06/where-does-cil-play-in-the-selinux-system/"&gt;previous
post&lt;/a&gt;
I used the &lt;code&gt;secilc&lt;/code&gt; binary to load an additional test policy. Little did
I know (and that's actually embarrassing because it was one of the
things I complained about) that you can just use the CIL policy as
modules directly.&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMMARY --&gt;

&lt;p&gt;With this I mean that a CIL policy as mentioned in the previous post can
be loaded like a prebuilt &lt;code&gt;.pp&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -i test.cil
~# semodule -l | grep test
test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's all that is to it. Loading the module resulted in the test port
to be immediately declared and available:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage port -l | grep test
test_port_t                    tcp      1440
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In hindsight, it makes sense that it is this easy. After all, support
for the old-style policy language is done by converting it into CIL when
calling &lt;code&gt;semodule&lt;/code&gt; so it makes sense to immediately put the module (in
CIL code) ready to be taken up.&lt;/p&gt;</content><category term="SELinux"></category><category term="cil"></category><category term="selinux"></category></entry><entry><title>Intermediate policies</title><link href="https://blog.siphos.be/2015/07/intermediate-policies/" rel="alternate"></link><published>2015-07-05T18:17:00+02:00</published><updated>2015-07-05T18:17:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-07-05:/2015/07/intermediate-policies/</id><summary type="html">&lt;p&gt;When developing SELinux policies for new software (or existing ones
whose policies I don't agree with) it is often more difficult to finish
the policies so that they are broadly usable. When dealing with personal
policies, having them "just work" is often sufficient. To make the
policies reusable for distributions (or for the upstream project), a
number of things are necessary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try structuring the policy using the style as suggested by refpolicy
    or Gentoo&lt;/li&gt;
&lt;li&gt;Add the role interfaces that are most likely to be used or required,
    or which are in the current draft implemented differently&lt;/li&gt;
&lt;li&gt;Refactor some of the policies to use refpolicy/Gentoo style
    interfaces&lt;/li&gt;
&lt;li&gt;Remove the comments from the policies (as refpolicy does not want
    too verbose policies)&lt;/li&gt;
&lt;li&gt;Change or update the file context definitions for default
    installations (rather than the custom installations I use)&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;When developing SELinux policies for new software (or existing ones
whose policies I don't agree with) it is often more difficult to finish
the policies so that they are broadly usable. When dealing with personal
policies, having them "just work" is often sufficient. To make the
policies reusable for distributions (or for the upstream project), a
number of things are necessary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try structuring the policy using the style as suggested by refpolicy
    or Gentoo&lt;/li&gt;
&lt;li&gt;Add the role interfaces that are most likely to be used or required,
    or which are in the current draft implemented differently&lt;/li&gt;
&lt;li&gt;Refactor some of the policies to use refpolicy/Gentoo style
    interfaces&lt;/li&gt;
&lt;li&gt;Remove the comments from the policies (as refpolicy does not want
    too verbose policies)&lt;/li&gt;
&lt;li&gt;Change or update the file context definitions for default
    installations (rather than the custom installations I use)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This often takes quite some effort. Some of these changes (such as the
style updates and commenting) are even counterproductive for me
personally (in the sense that I don't gain any value from doing so and
would have to start maintaining two different policy files for the same
policy), and necessary only for upstreaming policies. As a result, I
often finish with policies that I just leave for me personally or
somewhere on a public repository (like these
&lt;a href="https://github.com/sjvermeu/small.coding/tree/master/selinux-modules/neo4j"&gt;Neo4J&lt;/a&gt;
and
&lt;a href="https://github.com/sjvermeu/small.coding/tree/master/selinux-modules/ceph"&gt;Ceph&lt;/a&gt;
policies), without any activities already scheduled to attempt to
upstream those.&lt;/p&gt;
&lt;p&gt;But not contributing the policies to a broader public means that the
effort is not known, and other contributors might be struggling with
creating policies for their favorite (or necessary) technologies. So the
majority of policies that I write I still hope to eventually push them
out. But I noticed that these last few steps for upstreaming (the ones
mentioned above) might only take a few hours of work, but take me over 6
months (or more) to accomplish (as I often find other stuff more
interesting to do).&lt;/p&gt;
&lt;p&gt;I don't know yet how to change the process to make it more interesting
to use. However, I do have a couple of wishes that might make it easier
for me, and perhaps others, to contribute:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of reacting on contribution suggestions, work on a common
    repository together. Just like with a wiki, where we don't aim for a
    100% correct and well designed document from the start, we should
    use the strength of the community to continuously improve policies
    (and to allow multiple people to work on the same policy). Right
    now, policies are a one-man publication with a number of people
    commenting on the suggested changes and asking the one person to
    refactor or update the change himself.&lt;/li&gt;
&lt;li&gt;Document the style guide properly, but don't disallow contributions
    if they do not adhere to the style guide completely. Instead, merge
    and update. On successful wikis there are even people that update
    styles without content updates, and their help is greatly
    appreciated by the community.&lt;/li&gt;
&lt;li&gt;If a naming convention is to be followed (which is the case
    with policies) make it clear. Too often the name of an interface is
    something that takes a few days of discussion. That's not productive
    for policy development.&lt;/li&gt;
&lt;li&gt;Find a way to truly create a "core" part of the policy and a
    modular/serviceable approach to handle additional policies. The idea
    of the &lt;code&gt;contrib/&lt;/code&gt; repository was like that, but failed to live up to
    its expectations: the number of people who have commit access to the
    contrib is almost the same as to the core, a few exceptions
    notwithstanding, and whenever policies are added to contrib they
    often require changes on the core as well. Perhaps even support
    overlay-type approaches to policies so that intermediate policies
    can be "staged" and tested by a larger audience before they are
    vetted into the upstream reference policy.&lt;/li&gt;
&lt;li&gt;Settle on how to deal with networking controls. My suggestion would
    be to immediately support the TCP/UDP ports as assigned by IANA (or
    another set of sources) so that additional policies do not need to
    wait for the base policy to support the ports. Or find and support a
    way for contributions to declare the port types themselves (we
    probably need to focus on CIL for this).&lt;/li&gt;
&lt;li&gt;Document "best practices" on policy development where certain types
    of policies are documented in more detail. For instance, desktop
    application profiles, networked daemons, user roles, etc. These best
    practices should not be mandatory and should in fact support a broad
    set of privilege isolation. With the latter, I mean that there are
    policies who cover an entire category of systems (init systems, web
    servers), a single software package or even the sub-commands and
    sub-daemons of that package. It would surprise me if this can't be
    supported better out-of-the-box (as in, through a well
    thought-through base policy framework and styleguide).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I believe that this might create a more active community surrounding
policy development.&lt;/p&gt;</content><category term="SELinux"></category><category term="community"></category><category term="contributions"></category><category term="policy development"></category><category term="selinux"></category></entry><entry><title>Where does CIL play in the SELinux system?</title><link href="https://blog.siphos.be/2015/06/where-does-cil-play-in-the-selinux-system/" rel="alternate"></link><published>2015-06-13T23:12:00+02:00</published><updated>2015-06-13T23:12:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-06-13:/2015/06/where-does-cil-play-in-the-selinux-system/</id><summary type="html">&lt;p&gt;SELinux policy developers already have a number of file formats to work
with. Currently, policy code is written in a set of three files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;.te&lt;/code&gt; file contains the SELinux policy code (type
    enforcement rules)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.if&lt;/code&gt; file contains functions which turn a set of arguments into
    blocks of SELinux policy code (interfaces). These functions are
    called by other interface files or type enforcement files&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.fc&lt;/code&gt; file contains mappings of file path expressions towards
    labels (file contexts)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These files are compiled into loadable modules (or a base module) which
are then transformed to an active policy. But this is not a single-step
approach.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;SELinux policy developers already have a number of file formats to work
with. Currently, policy code is written in a set of three files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;.te&lt;/code&gt; file contains the SELinux policy code (type
    enforcement rules)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.if&lt;/code&gt; file contains functions which turn a set of arguments into
    blocks of SELinux policy code (interfaces). These functions are
    called by other interface files or type enforcement files&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.fc&lt;/code&gt; file contains mappings of file path expressions towards
    labels (file contexts)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These files are compiled into loadable modules (or a base module) which
are then transformed to an active policy. But this is not a single-step
approach.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Transforming policy code into policy file&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For the Linux kernel SELinux subsystem, only a single file matters - the
&lt;code&gt;policy.##&lt;/code&gt; file (for instance &lt;code&gt;policy.29&lt;/code&gt;). The suffix denotes the
binary format used as higher numbers mean that additional SELinux
features are supported which require different binary formats for the
SELinux code in the Linux kernel.&lt;/p&gt;
&lt;p&gt;With the 2.4 userspace, the transformation of the initial files as
mentioned above towards a policy file is done as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="SELinux transformation diagram" src="http://dev.gentoo.org/~swift/blog/201506/formats_selinux.png"&gt;&lt;/p&gt;
&lt;p&gt;When a developer builds a policy module, first &lt;code&gt;checkmodule&lt;/code&gt; is used to
build a &lt;code&gt;.mod&lt;/code&gt; intermediate file. This file contains the type
enforcement rules with the expanded rules of the various interface
files. Next, &lt;code&gt;semodule_package&lt;/code&gt; is called which transforms this
intermediate file, together with the file context file, into a &lt;code&gt;.pp&lt;/code&gt;
file.&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;.pp&lt;/code&gt; file is, in the 2.4 userspace, called a "high level language"
file. There is little high-level about it, but the idea is that such
high-level language files are then transformed into &lt;code&gt;.cil&lt;/code&gt; files (CIL
stands for &lt;em&gt;Common Intermediate Language&lt;/em&gt;). If at any moment other
frameworks come around, they could create high-level languages
themselves and provide a transformation engine to convert these HLL
files into CIL files.&lt;/p&gt;
&lt;p&gt;For the current &lt;code&gt;.pp&lt;/code&gt; files, this transformation is supported through
the &lt;code&gt;/usr/libexec/selinux/hll/pp&lt;/code&gt; binary which, given a &lt;code&gt;.pp&lt;/code&gt; file,
outputs CIL code.&lt;/p&gt;
&lt;p&gt;Finally, all CIL files (together) are compiled into a binary &lt;code&gt;policy.29&lt;/code&gt;
file. All the steps coming from a &lt;code&gt;.pp&lt;/code&gt; file towards the final binary
file are handled by the &lt;code&gt;semodule&lt;/code&gt; command. For instance, if an
administrator loads an additional &lt;code&gt;.pp&lt;/code&gt; file, its (generated) CIL code
is added to the other active CIL code and together, a new policy binary
file is created.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adding some CIL code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SELinux userspace development repository contains a &lt;code&gt;secilc&lt;/code&gt; command
which can compile CIL code into a binary policy file. As such, it can
perform the (very) last step of the file conversions above. However, it
is not &lt;em&gt;integrated&lt;/em&gt; in the sense that, if additional code is added, the
administrator can "play" with it as he would with SELinux policy
modules.&lt;/p&gt;
&lt;p&gt;Still, that shouldn't prohibit us from playing around with it to
experiment with the CIL language construct. Consider the following CIL
SELinux policy code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;; Declare a test_port_t type
(type test_port_t)
; Assign the type to the object_r role
(roletype object_r test_port_t)

; Assign the right set of attributes to the port
(typeattributeset defined_port_type test_port_t)
(typeattributeset port_type test_port_t)

; Declare tcp:1440 as test_port_t
(portcon tcp 1440 (system_u object_r test_port_t ((s0) (s0))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code declares a port type (&lt;code&gt;test_port_t&lt;/code&gt;) and uses it for the TCP
port 1440.&lt;/p&gt;
&lt;p&gt;In order to use this code, we have to build a policy file which includes
all currently active CIL code, together with the test code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ secilc -c 29 /var/lib/selinux/mcs/active/modules/400/*/cil testport.cil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The result is a &lt;code&gt;policy.29&lt;/code&gt; (the command forces version 29 as the
current Linux kernel used on this system does not support version 30)
file, which can now be copied to &lt;code&gt;/etc/selinux/mcs/policy&lt;/code&gt;. Then, after
having copied the file, load the new policy file using &lt;code&gt;load_policy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And lo and behold, the port type is now available:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage port -l | grep 1440
test_port_t           tcp      1440
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To verify that it really is available and not just parsed by the
userspace, let's connect to it and hope for a nice denial message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ ssh -p 1440 localhost
ssh: connect to host localhost port 1440: Permission denied

~$ sudo ausearch -ts recent
time-&amp;gt;Thu Jun 11 19:35:45 2015
type=PROCTITLE msg=audit(1434044145.829:296): proctitle=737368002D700031343430006C6F63616C686F7374
type=SOCKADDR msg=audit(1434044145.829:296): saddr=0A0005A0000000000000000000000000000000000000000100000000
type=SYSCALL msg=audit(1434044145.829:296): arch=c000003e syscall=42 success=no exit=-13 a0=3 a1=6d4d1ce050 a2=1c a3=0 items=0 ppid=2005 pid=18045 auid=1001 uid=1001 gid=1001 euid=1001 suid=1001 fsuid=1001 egid=1001 sgid=1001 fsgid=1001 tty=pts0 ses=1 comm=&amp;quot;ssh&amp;quot; exe=&amp;quot;/usr/bin/ssh&amp;quot; subj=staff_u:staff_r:ssh_t:s0 key=(null)
type=AVC msg=audit(1434044145.829:296): avc:  denied  { name_connect } for  pid=18045 comm=&amp;quot;ssh&amp;quot; dest=1440 scontext=staff_u:staff_r:ssh_t:s0 tcontext=system_u:object_r:test_port_t:s0 tclass=tcp_socket permissive=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category><category term="cil"></category><category term="selinux"></category><category term="userspace"></category></entry><entry><title>Live SELinux userspace ebuilds</title><link href="https://blog.siphos.be/2015/06/live-selinux-userspace-ebuilds/" rel="alternate"></link><published>2015-06-10T20:07:00+02:00</published><updated>2015-06-10T20:07:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-06-10:/2015/06/live-selinux-userspace-ebuilds/</id><summary type="html">&lt;p&gt;In between courses, I pushed out live ebuilds for the SELinux userspace
applications: libselinux, policycoreutils, libsemanage, libsepol,
sepolgen, checkpolicy and secilc. These live ebuilds (with Gentoo
version 9999) pull in the current development code of the &lt;a href="https://github.com/SELinuxProject/selinux"&gt;SELinux
userspace&lt;/a&gt; so that developers
and contributors can already work with in-progress code developments as
well as see how they work on a Gentoo platform.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In between courses, I pushed out live ebuilds for the SELinux userspace
applications: libselinux, policycoreutils, libsemanage, libsepol,
sepolgen, checkpolicy and secilc. These live ebuilds (with Gentoo
version 9999) pull in the current development code of the &lt;a href="https://github.com/SELinuxProject/selinux"&gt;SELinux
userspace&lt;/a&gt; so that developers
and contributors can already work with in-progress code developments as
well as see how they work on a Gentoo platform.&lt;/p&gt;


&lt;p&gt;That being said, I do not recommend using the live ebuilds for anyone
else except developers and contributors in development zones (definitely
not on production). One of the reasons is that the ebuilds do not apply
Gentoo-specific patches to the ebuilds. I would also like to remove the
Gentoo-specific manipulations that we do, such as small Makefile
adjustments, but let's start with just ignoring the Gentoo patches.&lt;/p&gt;
&lt;p&gt;Dropping the patches makes sure that we track upstream libraries and
userspace closely, and allows developers to try and send out patches to
the SELinux project to fix Gentoo related build problems. But as not all
packages can be deployed successfully on a Gentoo system some patches
need to be applied anyway. For this, users can drop the necessary
patches inside &lt;code&gt;/etc/portage/patches&lt;/code&gt; as all userspace ebuilds use the
&lt;em&gt;epatch_user&lt;/em&gt; method.&lt;/p&gt;
&lt;p&gt;Finally, observant users will notice that "secilc" is also provided.
This is a new package, which is probably going to have an official
release with a new userspace release. It allows for building CIL-based
SELinux policy code, and was one of the drivers for me to create the
live ebuilds as I'm experimenting with the CIL constructions. So expect
more on that later.&lt;/p&gt;</content><category term="Gentoo"></category><category term="cil"></category><category term="Gentoo"></category><category term="selinux"></category><category term="userspace"></category></entry><entry><title>Testing with permissive domains</title><link href="https://blog.siphos.be/2015/05/testing-with-permissive-domains/" rel="alternate"></link><published>2015-05-18T13:40:00+02:00</published><updated>2015-05-18T13:40:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-05-18:/2015/05/testing-with-permissive-domains/</id><summary type="html">&lt;p&gt;When testing out new technologies or new setups, not having (proper)
SELinux policies can be a nuisance. Not only are the number of SELinux
policies that are available through the standard repositories limited,
some of these policies are not even written with the same level of
confinement that an administrator might expect. Or perhaps the
technology to be tested is used in a completely different manner.&lt;/p&gt;
&lt;p&gt;Without proper policies, any attempt to start such a daemon or
application might or will cause permission violations. In many cases,
developers or users tend to disable SELinux enforcing then so that they
can continue playing with the new technology. And why not? After all,
policy development is to be done &lt;em&gt;after&lt;/em&gt; the technology is understood.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;When testing out new technologies or new setups, not having (proper)
SELinux policies can be a nuisance. Not only are the number of SELinux
policies that are available through the standard repositories limited,
some of these policies are not even written with the same level of
confinement that an administrator might expect. Or perhaps the
technology to be tested is used in a completely different manner.&lt;/p&gt;
&lt;p&gt;Without proper policies, any attempt to start such a daemon or
application might or will cause permission violations. In many cases,
developers or users tend to disable SELinux enforcing then so that they
can continue playing with the new technology. And why not? After all,
policy development is to be done &lt;em&gt;after&lt;/em&gt; the technology is understood.&lt;/p&gt;


&lt;p&gt;But completely putting the system in permissive mode is overshooting. It
is much easier to make a very simple policy to start with, and then mark
the domain as a permissive domain. What happens is that the software
then, after transitioning into the "simple" domain, is not part of the
SELinux enforcements anymore whereas the rest of the system remains in
SELinux enforcing mode.&lt;/p&gt;
&lt;p&gt;For instance, create a minuscule policy like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(testdom, 1.0)

type testdom_t;
type testdom_exec_t;
init_daemon_domain(testdom_t, testdom_exec_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Mark the executable for the daemon as &lt;code&gt;testdom_exec_t&lt;/code&gt; (after building
and loading the minuscule policy):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# chcon -t testdom_exec_t /opt/something/bin/daemond
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, tell SELinux that &lt;code&gt;testdom_t&lt;/code&gt; is to be seen as a permissive
domain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage permissive -a testdom_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When finished, don't forget to remove the permissive bit
(&lt;code&gt;semanage permissive -d testdom_t&lt;/code&gt;) and unload/remove the SELinux
policy module.&lt;/p&gt;
&lt;p&gt;And that's it. If the daemon is now started (through a standard init
script) it will run as &lt;code&gt;testdom_t&lt;/code&gt; and everything it does will be
logged, but not enforced by SELinux. That might even help in
understanding the application better.&lt;/p&gt;</content><category term="SELinux"></category><category term="permissive"></category><category term="policy"></category><category term="selinux"></category><category term="semanage"></category><category term="test"></category></entry><entry><title>Audit buffering and rate limiting</title><link href="https://blog.siphos.be/2015/05/audit-buffering-and-rate-limiting/" rel="alternate"></link><published>2015-05-10T14:18:00+02:00</published><updated>2015-05-10T14:18:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-05-10:/2015/05/audit-buffering-and-rate-limiting/</id><summary type="html">&lt;p&gt;Be it because of SELinux experiments, or through general audit
experiments, sometimes you'll get in touch with a message similar to the
following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;audit: audit_backlog=321 &amp;gt; audit_backlog_limit=320
audit: audit_lost=44395 audit_rate_limit=0 audit_backlog_limit=320
audit: backlog limit exceeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;!-- PELICAN_END_SUMMMARY --&gt;

&lt;p&gt;The message shows up when certain audit events could not be &lt;/p&gt;</summary><content type="html">&lt;p&gt;Be it because of SELinux experiments, or through general audit
experiments, sometimes you'll get in touch with a message similar to the
following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;audit: audit_backlog=321 &amp;gt; audit_backlog_limit=320
audit: audit_lost=44395 audit_rate_limit=0 audit_backlog_limit=320
audit: backlog limit exceeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;!-- PELICAN_END_SUMMMARY --&gt;

&lt;p&gt;The message shows up when certain audit events could not be logged
through the audit subsystem. Depending on the system configuration, they
might be either ignored, sent through the kernel logging infrastructure
or even have the system panic. And if the messages are sent to the
kernel log then they might show up, but even that log has its
limitations, which can lead to output similar to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;__ratelimit: 53 callbacks suppressed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this post, I want to give some pointers in configuring the audit
subsystem as well as understand these messages...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is auditd and kauditd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you take a look at the audit processes running on the system, you'll
notice that (assuming Linux auditing is used of course) two processes
are running:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# ps -ef | grep audit
root      1483     1  0 10:11 ?        00:00:00 /sbin/auditd
root      1486     2  0 10:11 ?        00:00:00 [kauditd]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;/sbin/auditd&lt;/code&gt; daemon is the user-space audit daemon. It &lt;a href="http://man7.org/linux/man-pages/man3/audit_open.3.html"&gt;registers
itself&lt;/a&gt; with the
Linux kernel audit subsystem (through the audit netlink system), which
responds with spawning the &lt;code&gt;kauditd&lt;/code&gt; kernel thread/process. The fact
that the process is a kernel-level one is why the &lt;code&gt;kauditd&lt;/code&gt; is
surrounded by brackets in the &lt;code&gt;ps&lt;/code&gt; output.&lt;/p&gt;
&lt;p&gt;Once this is done, audit messages are communicated through the netlink
socket to the user-space audit daemon. For the detail-oriented people
amongst you, look for the &lt;em&gt;kauditd_send_skb()&lt;/em&gt; method in the
&lt;a href="http://lxr.free-electrons.com/source/kernel/audit.c"&gt;kernel/audit.c&lt;/a&gt;
file. Now, generated audit event messages are not directly relayed to
the audit daemon - they are first queued in a sort-of backlog, which is
where the backlog-related messages above come from.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Audit backlog queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In the kernel-level audit subsystem, a socket buffer queue is used to
hold audit events. Whenever a new audit event is received, it is logged
and prepared to be added to this queue. Adding to this queue can be
controlled through a few parameters.&lt;/p&gt;
&lt;p&gt;The first parameter is the backlog limit. Be it through a kernel boot
parameter (&lt;code&gt;audit_backlog_limit=N&lt;/code&gt;) or through a message relayed by the
user-space audit daemon (&lt;code&gt;auditctl -b N&lt;/code&gt;), this limit will ensure that a
queue cannot grow beyond a certain size (expressed in the amount of
messages). If an audit event is logged which would grow the queue beyond
this limit, then a failure occurs and is handled according to the system
configuration (more on that later).&lt;/p&gt;
&lt;p&gt;The second parameter is the rate limit. When more audit events are
logged within a second than set through this parameter (which can be
controlled through a message relayed by the user-space audit system,
using &lt;code&gt;auditctl -r N&lt;/code&gt;) then those audit events are not added to the
queue. Instead, a failure occurs and is handled according to the system
configuration.&lt;/p&gt;
&lt;p&gt;Only when the limits are not reached is the message added to the queue,
allowing the user-space audit daemon to consume those events and log
those according to the audit configuration. There are some good
resources on audit configuration available on the Internet. I find &lt;a href="http://webapp5.rrz.uni-hamburg.de/SuSe-Dokumentation/manual/sles-manuals_en/cha.audit.comp.html"&gt;this
SuSe
chapter&lt;/a&gt;
worth reading, but many others exist as well.&lt;/p&gt;
&lt;p&gt;There is a useful command related to the subject of the audit backlog
queue. It queries the audit subsystem for its current status:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# auditctl -s
AUDIT_STATUS: enabled=1 flag=1 pid=1483 rate_limit=0 backlog_limit=8192 lost=3 backlog=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The command displays not only the audit state (enabled or not) but also
the settings for rate limits (on the audit backlog) and backlog limit.
It also shows how many events are currently still waiting in the backlog
queue (which is zero in our case, so the audit user-space daemon has
properly consumed and logged the audit events).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Failure handling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If an audit event cannot be logged, then this failure needs to be
resolved. The Linux audit subsystem can be configured do either silently
discard the message, switch to the kernel log subsystem, or panic. This
can be configured through the audit user-space (&lt;code&gt;auditctl -f [0..2]&lt;/code&gt;),
but is usually left at the default (which is 1, being to switch to the
kernel log subsystem).&lt;/p&gt;
&lt;p&gt;Before that is done, the message is displayed which reveals the cause of
the failure handling:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;audit: audit_backlog=321 &amp;gt; audit_backlog_limit=320
audit: audit_lost=44395 audit_rate_limit=0 audit_backlog_limit=320
audit: backlog limit exceeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this case, the backlog queue was set to contain at most 320 entries
(which is low for a production system) and more messages were being
added (the Linux kernel in certain cases allows to have a few more
entries than configured for performance and consistency reasons). The
number of events already lost is displayed, as well as the current
limitation settings. The message "backlog limit exceeded" can be "rate
limit exceeded" if that was the limitation that was triggered.&lt;/p&gt;
&lt;p&gt;Now, if the system is not configured to silently discard it, or to panic
the system, then the "dropped" messages are sent to the kernel log
subsystem. The calls however are also governed through a configurable
limitation: it uses a rate limit which can be set through &lt;code&gt;sysctl&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# sysctl -a | grep kernel.printk_rate
kernel.printk_ratelimit = 5
kernel.printk_ratelimit_burst = 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above example, this system allows one message every 5 seconds,
but does allow a burst of up to 10 messages at once. When the rate
limitation kicks in, then the kernel will log (at most one per second)
the number of suppressed events:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[40676.545099] __ratelimit: 246 callbacks suppressed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Although this limit is kernel-wide, not all kernel log events are
governed through it. It is the caller subsystem (in our case, the audit
subsystem) which is responsible for having its events governed through
this rate limitation or not.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Finishing up&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Before waving goodbye, I would like to point out that the backlog queue
is a memory queue (and not &lt;a href="https://access.redhat.com/solutions/19327"&gt;on disk, Red
Hat&lt;/a&gt;), just in case it wasn't
obvious. Increasing the queue size can result in more kernel memory
consumption. Apparently, a &lt;a href="https://www.redhat.com/archives/linux-audit/2011-October/msg00007.html"&gt;practical size
estimate&lt;/a&gt;
is around 9000 bytes per message. On production systems, it is advised
not to make this setting too low. I personally set it to 8192.&lt;/p&gt;
&lt;p&gt;Lost audit events might result in difficulties for troubleshooting,
which is the case when dealing with new or experimental SELinux
policies. It would also result in missing security-important events. It
is the audit subsystem, after all. So tune it properly, and enjoy the
power of Linux' audit subsystem.&lt;/p&gt;</content><category term="Free Software"></category><category term="audit"></category><category term="kernel"></category><category term="security"></category><category term="selinux"></category></entry><entry><title>Use change management when you are using SELinux to its fullest</title><link href="https://blog.siphos.be/2015/04/use-change-management-when-you-are-using-selinux-to-its-fullest/" rel="alternate"></link><published>2015-04-30T20:58:00+02:00</published><updated>2015-04-30T20:58:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-04-30:/2015/04/use-change-management-when-you-are-using-selinux-to-its-fullest/</id><summary type="html">&lt;p&gt;If you are using SELinux on production systems (with which I mean
systems that you offer services with towards customers or other parties
beyond you, yourself and your ego), please consider proper change
management if you don't do already. SELinux is a very sensitive security
subsystem - not in the sense &lt;/p&gt;</summary><content type="html">&lt;p&gt;If you are using SELinux on production systems (with which I mean
systems that you offer services with towards customers or other parties
beyond you, yourself and your ego), please consider proper change
management if you don't do already. SELinux is a very sensitive security
subsystem - not in the sense that it easily fails, but because it is
very fine-grained and as such can easily stop applications from running
when their behavior changes just a tiny bit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sensitivity of SELinux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELinux is a wonderful security measure for Linux systems that can
prevent successful exploitation of vulnerabilities or misconfigurations.
Of course, it is not the sole security measure that systems should take.
Proper secure configuration of services, least privilege accounts,
kernel-level mitigations such as grSecurity and more are other measures
that certainly need to be taken if you really find system security to be
a worthy goal to attain. But I'm not going to talk about those others
right now. What I am going to focus on is SELinux, and how sensitive it
is to changes.&lt;/p&gt;
&lt;p&gt;An important functionality of SELinux to understand is that it
segregates the security control system itself (the SELinux subsystem)
from its configuration (the policy). The security control system itself
is relatively small, and focuses on enforcement of the policy and
logging (either because the policy asks to log something, or because
something is prevented, or because an error occurred). The most
difficult part of handling SELinux on a system is not enabling or
interacting with it. No, it is its policy.&lt;/p&gt;
&lt;p&gt;The policy is also what makes SELinux so darn sensitive for small system
changes (or behavior that is not either normal, or at least not allowed
through the existing policy). Let me explain with a small situation that
I recently had.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case in point: Switching an IP address&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A case that beautifully shows how sensitive SELinux can be is an IP
address change. My systems all obtain their IP address (at least for
IPv4) from a DHCP system. This is of course acceptable behavior as
otherwise my systems would never be able to boot up successfully anyway.
The SELinux policy that I run also allows this without any hindrance. So
that was not a problem.&lt;/p&gt;
&lt;p&gt;Yet recently I had to switch an IP address for a system in production.
All the services I run are set up in a dual-active mode, so I started
with the change by draining the services to the second system, shutting
down the service and then (after reconfiguring the DHCP system to now
provide a different IP address) reload the network configuration. And
then it happened - the DHCP client just stalled.&lt;/p&gt;
&lt;p&gt;As the change failed, I updated the DHCP system again to deliver the old
IP address and then reloaded the network configuration on the client.
Again, it failed. Dumbstruck, I looked at the AVC denials and lo and
behold, I notice a &lt;code&gt;dig&lt;/code&gt; process running in a DHCP client related domain
that is trying to do UDP binds, which the policy (at that time) did not
allow. But why now suddenly, after all - this system was running happily
for more than a year already (and with occasional reboots for kernel
updates).&lt;/p&gt;
&lt;p&gt;I won't bore you with the investigation. It boils down to the fact that
the DHCP client detected a change compared to previous startups, and was
configured to run a few hooks as additional steps in the IP lease setup.
As these hooks were never ran previously, the policy was never
challenged to face this. And since the address change occurred a revert
to the previous situation didn't work either (as its previous state
information was already deleted).&lt;/p&gt;
&lt;p&gt;I was able to revert the client (which is a virtual guest in KVM) to the
situation right before the change (thank you &lt;code&gt;savevm&lt;/code&gt; and &lt;code&gt;loadvm&lt;/code&gt;
functionality) so that I could work on the policy first in a
non-production environment so that the next change attempt was
successful.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Change management&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The previous situation might be "solved" by temporarily putting the DHCP
client domain in permissive mode just for the change and then back. But
that is ignoring the issue, and unless you have perfect operational
documentation that you always read before making system or configuration
changes, I doubt that you'll remember this for the next time.&lt;/p&gt;
&lt;p&gt;The case is also a good example on the sensitivity of SELinux. It is not
just when software is being upgraded. Every change (be it in
configuration, behavior or operational activity) might result in a
situation that is new for the loaded SELinux policy. As the default
action in SELinux is to deny everything, this will result in unexpected
results on the system. Sometimes very visible (no IP address obtained),
sometimes hidden behind some weird behavior (hostname correctly set but
not the domainname) or perhaps not even noticed until far later. Compare
it to the firewall rule configurations: you might be able to easily
confirm that standard flows are still passed through, but how are you
certain that fallback flows or one-in-a-month connection setups are not
suddenly prevented from happening.&lt;/p&gt;
&lt;p&gt;A somewhat better solution than just temporarily disabling SELinux
access controls for a domain is to look into proper change management.
Whenever a change has to be done, make sure that you&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can easily revert the change back to the previous
    situation (backups!)&lt;/li&gt;
&lt;li&gt;have tested the change on a non-vital (preproduction) system first&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These two principles are pretty vital when you are serious about using
SELinux in production. I'm not talking about a system that hardly has
any fine-grained policies, like where most of the system's services are
running in "unconfined" domains (although that's still better than not
running with SELinux at all), but where you are truly trying to put a
least privilege policy in place for all processes and services.&lt;/p&gt;
&lt;p&gt;Being able to revert a change allows you to quickly get a service up and
running again so that customers are not affected by the change (and
potential issues) for long time. First fix the service, then fix the
problem. If you are an engineer like me, you might rather focus on the
problem (and a permanent, correct solution) first. But that's wrong -
always first make sure that the customers are not affected by it. Revert
and put the service back up, and then investigate so that the next
change attempt will not go wrong anymore.&lt;/p&gt;
&lt;p&gt;Having a multi-master setup might give some more leeway into
investigating issues (as the service itself is not disrupted) so in the
case mentioned above I would probably have tried fixing the issue
immediately anyway if it wasn't policy-based. But most users do not have
truly multi-master service setups.&lt;/p&gt;
&lt;p&gt;Being able to test (and retest) changes in non-production also allows
you to focus on automation (so that changes can be done faster and in a
repeated, predictable and qualitative manner), regression testing as
well as change accumulation testing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;You don't have time for that?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Be honest with yourself. If you support services for others (be it in a
paid-for manner or because you support an organization in your free
time) you'll quickly learn that service availability is one of the most
qualitative aspects of what you do. No matter what mess is behind it,
most users don't see all that. All they see is the service itself (and
its performance / features). If a change you wanted to make made a
service unavailable for hours, users will notice. And if the change
wasn't communicated up front or it is the n-th time that this downtime
occurs, they will start asking questions you rather not hear.&lt;/p&gt;
&lt;p&gt;Using a non-production environment is not that much of an issue if the
infrastructure you work with supports bare metal restores, or
snapshot/cloning (in case of VMs). After doing those a couple of times,
you'll easily find that you can create a non-production environment from
the production one. Or, you can go for a permanent non-production
environment (although you'll need to take care that this environment is
at all times representative for the production systems).&lt;/p&gt;
&lt;p&gt;And regarding qualitative changes, I really recommend to use a
configuration management system. I recently switched from Puppet to
Saltstack and have yet to use the latter to its fullest set (most of
what I do is still scripted), but it is growing on me and I'm pretty
convinced that I'll have the majority of my change management scripts
removed by the end of this year towards Saltstack-based configurations.
And that'll allow me to automate changes and thus provide a more
qualitative service offering.&lt;/p&gt;
&lt;p&gt;With SELinux, of course.&lt;/p&gt;</content><category term="SELinux"></category><category term="change management"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Moving closer to 2.4 stabilization</title><link href="https://blog.siphos.be/2015/04/moving-closer-to-2-4-stabilization/" rel="alternate"></link><published>2015-04-27T19:18:00+02:00</published><updated>2015-04-27T19:18:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-04-27:/2015/04/moving-closer-to-2-4-stabilization/</id><summary type="html">&lt;p&gt;The &lt;a href="https://github.com/SELinuxProject/selinux/wiki"&gt;SELinux userspace&lt;/a&gt;
project has released version 2.4 in february this year, after release
candidates have been tested for half a year. After its release, we at
the &lt;a href="https://wiki.gentoo.org/wiki/Project:Hardened"&gt;Gentoo Hardened&lt;/a&gt;
project have been working hard to integrate it within Gentoo. This
effort has been made a bit more difficult &lt;/p&gt;</summary><content type="html">&lt;p&gt;The &lt;a href="https://github.com/SELinuxProject/selinux/wiki"&gt;SELinux userspace&lt;/a&gt;
project has released version 2.4 in february this year, after release
candidates have been tested for half a year. After its release, we at
the &lt;a href="https://wiki.gentoo.org/wiki/Project:Hardened"&gt;Gentoo Hardened&lt;/a&gt;
project have been working hard to integrate it within Gentoo. This
effort has been made a bit more difficult due to the migration of the
policy store from one location to another while at the same time
switching to HLL- and CIL based builds.&lt;/p&gt;
&lt;p&gt;Lately, 2.4 itself has been pretty stable, and we're focusing on the
proper migration from 2.3 to 2.4. The SELinux policy has been adjusted
to allow the migrations to work, and a few final fixes are being tested
so that we can safely transition our stable users from 2.3 to 2.4.
Hopefully we'll be able to stabilize the userspace this month or
beginning of next month.&lt;/p&gt;</content><category term="Gentoo"></category><category term="2.4"></category><category term="Gentoo"></category><category term="hardened"></category><category term="selinux"></category><category term="userspace"></category></entry><entry><title>CIL and attributes</title><link href="https://blog.siphos.be/2015/02/cil-and-attributes/" rel="alternate"></link><published>2015-02-15T15:49:00+01:00</published><updated>2015-02-15T15:49:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-02-15:/2015/02/cil-and-attributes/</id><summary type="html">&lt;p&gt;I keep on struggling to remember this, so let's make a blog post out of
it ;-)&lt;/p&gt;
&lt;p&gt;When the SELinux policy is being built, recent userspace (2.4 and
higher) will convert the policy into CIL language, and then build the
binary policy. When the policy supports type attributes, these are &lt;/p&gt;</summary><content type="html">&lt;p&gt;I keep on struggling to remember this, so let's make a blog post out of
it ;-)&lt;/p&gt;
&lt;p&gt;When the SELinux policy is being built, recent userspace (2.4 and
higher) will convert the policy into CIL language, and then build the
binary policy. When the policy supports type attributes, these are of
course also made available in the CIL code. For instance the
&lt;code&gt;admindomain&lt;/code&gt; attribute from the &lt;code&gt;userdomain&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
(typeattribute admindomain)
(typeattribute userdomain)
(typeattribute unpriv_userdomain)
(typeattribute user_home_content_type)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Interfaces provided by the module are also applied. You won't find the
interface CIL code in &lt;code&gt;/var/lib/selinux/mcs/active/modules&lt;/code&gt; though; the
code at that location is already "expanded" and filled in. So for the
&lt;code&gt;sysadm_t&lt;/code&gt; domain we have:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Equivalent of
# gen_require(`
#   attribute admindomain;
#   attribute userdomain;
# &amp;#39;)
# typeattribute sysadm_t admindomain;
# typeattribute sysadm_t userdomain;

(typeattributeset cil_gen_require admindomain)
(typeattributeset admindomain (sysadm_t ))
(typeattributeset cil_gen_require userdomain)
(typeattributeset userdomain (sysadm_t ))
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, when checking which domains use the &lt;code&gt;admindomain&lt;/code&gt; attribute,
notice the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# seinfo -aadmindomain -x
ERROR: Provided attribute (admindomain) is not a valid attribute name.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But don't panic - this has a reason: as long as there is no SELinux rule
applied towards the &lt;code&gt;admindomain&lt;/code&gt; attribute, then the SELinux policy
compiler will drop the attribute from the final policy. This can be
confirmed by adding a single, cosmetic rule, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## allow admindomain admindomain:process sigchld;

~# seinfo -aadmindomain -x
   admindomain
      sysadm_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So there you go. That does mean that if something previously used the
attribute assignation for any decisions (like "for each domain assigned
the userdomain attribute, do something") will need to make sure that the
attribute is really used in a policy rule.&lt;/p&gt;</content><category term="SELinux"></category><category term="attribute"></category><category term="cil"></category><category term="selinux"></category></entry><entry><title>SELinux is great for enterprises (but many don't know it yet)</title><link href="https://blog.siphos.be/2015/01/selinux-is-great-for-enterprises-but-many-dont-know-it-yet/" rel="alternate"></link><published>2015-01-03T13:36:00+01:00</published><updated>2015-01-03T13:36:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-01-03:/2015/01/selinux-is-great-for-enterprises-but-many-dont-know-it-yet/</id><summary type="html">&lt;p&gt;Large companies that handle their own IT often have internal support
teams for many of the technologies that they use. Most of the time, this
is for reusable components like database technologies, web application
servers, operating systems, middleware components (like file transfers,
messaging infrastructure, ...) and more. All components that are &lt;/p&gt;</summary><content type="html">&lt;p&gt;Large companies that handle their own IT often have internal support
teams for many of the technologies that they use. Most of the time, this
is for reusable components like database technologies, web application
servers, operating systems, middleware components (like file transfers,
messaging infrastructure, ...) and more. All components that are used
and deployed multiple times, and thus warrant the expenses of a
dedicated engineering team.&lt;/p&gt;
&lt;p&gt;Such teams often have (or need to write) secure configuration deployment
guides, so that these components are installed in the organization with
as little misconfigurations as possible. A wrongly configured component
is often worse than a vulnerable component, because vulnerabilities are
often fixed with the software upgrades (you do patch your software,
right?) whereas misconfigurations survive these updates and remain
exploitable for longer periods. Also, misuse of components is harder to
detect than exploiting vulnerabilities because they are often seen as
regular user behavior.&lt;/p&gt;
&lt;p&gt;But next to the redeployable components, most business services are
provided by a single application. Most companies don't have the budget
and resources to put dedicated engineering teams on each and every
application that is deployed in the organization. Even worse, many
companies hire external consultants to help in the deployment of the
component, and then the consultants hand over the maintenance of that
software to internal teams. Some consultants don't fully bother with
secure configuration deployment guides, or even feel the need to disable
security constraints put forth by the organization (policies and
standards) because "it is needed". A deployment is often seen as
successful when the software functionally works, which not necessarily
means that it is misconfiguration-free.&lt;/p&gt;
&lt;p&gt;As a recent example that I came across, consider an application that
needs &lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;. A consultancy firm is hired to set
up the infrastructure, and given full administrative rights on the
operating system to make sure that this particular component is deployed
fast (because the company wants to have the infrastructure in production
before the end of the week). Security is initially seen as less of a
concern, and the consultancy firm informs the customer (without any
guarantees though) that it will be set up "according to common best
practices". The company itself has no engineering team for Node.js nor
wants to invest in the appropriate resources (such as training) for
security engineers to review Node.js configurations. Yet the application
that is deployed on the Node.js application server is internet-facing,
so has a higher risk associated with it than a purely internal
deployment.&lt;/p&gt;
&lt;p&gt;So, how to ensure that these applications cannot be exploited or, if an
exploit is done, how to ensure that the risks involved with the exploit
are contained? Well, this is where I believe SELinux has a great
potential. And although I'm talking about SELinux here, the same goes
for other similar technologies like &lt;a href="http://en.wikipedia.org/wiki/TOMOYO_Linux"&gt;TOMOYO
Linux&lt;/a&gt;, &lt;a href="http://en.wikibooks.org/wiki/Grsecurity/The_RBAC_System"&gt;grSecurity's RBAC
system&lt;/a&gt;,
&lt;a href="http://www.rsbac.org/"&gt;RSBAC&lt;/a&gt; and more.&lt;/p&gt;
&lt;p&gt;SELinux can provide a container, decoupled from the application itself
(but of course built for that particular application) which restricts
the behavior of that application on the system to those activities that
are expected. The application itself is not SELinux-aware (or does not
need to be - some applications are, but those that I am focusing on here
usually don't), but the SELinux access controls ensure that exploits on
the application cannot reach beyond those activities/capabilities that
are granted to it.&lt;/p&gt;
&lt;p&gt;Consider the Node.js deployment from before. The Node.js application
server might need to connect to a &lt;a href="http://www.mongodb.org/"&gt;MongoDB&lt;/a&gt;
cluster, so we can configure SELinux to allow just that, but all other
connections that originate from the Node.js deployment should be
forbidden. Worms (if any) cannot use this deployment then to spread out.
Same with access to files - the Node.js application probably only needs
access to the application files and not to other system files. Instead
of trying to run the application in a chroot (which requires engineering
effort from those people implementing Node.js, which could be a
consultancy firm that does not know or want to deploy within a chroot)
SELinux is configured to disallow any file access beyond the application
files.&lt;/p&gt;
&lt;p&gt;With SELinux, the application can be deployed relatively safely while
ensuring that exploits (or abuse of misconfigurations) cannot spread.
All that the company itself has to do is to provide resources for a
SELinux engineering team (which can be just a responsibility of the
Linux engineering teams, but can be specialized as well). Such a team
does not need to be big, as policy development effort is usually only
needed during changes (for instance when the application is updated to
also send e-mails, in which case the SELinux policy can be adjusted to
allow that as well), and given enough experience, the SELinux
engineering team can build flexible policies that the administration
teams (those that do the maintenance of the servers) can tune the policy
as needed (for instance through SELinux booleans) without the need to
have the SELinux team work on the policies again.&lt;/p&gt;
&lt;p&gt;Using SELinux also has a number of additional advantages which other,
sometimes commercial tools (like Symantecs SPE/SCSP - really Symantec,
you ask customers to disable SELinux?) severly lack.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELinux is part of a default Linux installation in many cases.
    RedHat Enterprise Linux ships with SELinux by default, and actively
    supports SELinux when customers have any problems with it. This also
    improves the likelihood for SELinux to be accepted, as other, third
    party solutions might not be supported. Ever tried getting support
    for a system on which both McAfee AV for Linux and Symantec SCSP are
    running (if you got it to work together at all)? At least McAfee
    gives pointers to how to update &lt;a href="https://kc.mcafee.com/corporate/index?page=content&amp;amp;id=KB67360"&gt;SELinux
    settings&lt;/a&gt;
    when they would interfere with McAfee processes.&lt;/li&gt;
&lt;li&gt;SELinux is widely known and many resources exist for users,
    administrators and engineers to learn more about it. The resources
    are freely available, and often kept up2date by a very
    motivated community. Unlike commercial products, whose support pages
    are hidden behind paywalls, customers are usually prevented from
    interacting with each other and tips and tricks for using the
    product are often not found on the Internet, SELinux information can
    be found almost everywhere. And if you like books, I have a couple
    for you to read: &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-system-administration"&gt;SELinux System
    Administration&lt;/a&gt;
    and &lt;a href="https://www.packtpub.com/networking-and-servers/selinux-cookbook"&gt;SELinux
    Cookbook&lt;/a&gt;,
    written by yours truly.&lt;/li&gt;
&lt;li&gt;Using SELinux is widely supported by third party configuration
    management tools, especially in the free software world.
    &lt;a href="http://puppetlabs.com/"&gt;Puppet&lt;/a&gt;, &lt;a href="https://www.chef.io/chef/"&gt;Chef&lt;/a&gt;,
    &lt;a href="http://www.ansible.com/home"&gt;Ansible&lt;/a&gt;,
    &lt;a href="http://www.saltstack.com/"&gt;SaltStack&lt;/a&gt; and others all support
    SELinux and/or have modules that integrate SELinux support in the
    management system.&lt;/li&gt;
&lt;li&gt;Using SELinux incurs no additional licensing costs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, SELinux is definitely not a holy grail. It has its limitations, so
security should still be seen as a global approach where SELinux is just
playing one specific role in. For instance, SELinux does not prevent
application behavior that is allowed by the policy. If a user abuses a
configuration and can have an application expose information that the
user usually does not have access to, but the application itself does
(for instance because other users on that application might) SELinux
cannot do anything about it (well, not as long as the application is not
made SELinux-aware). Also, vulnerabilities that exploit application
internals are not controlled by SELinux access controls. It is the
application behavior ("external view") that SELinux controls. To
mitigate in-application vulnerabilities, other approaches need to be
considered (such as memory protections for free software solutions,
which can protect against some kinds of exploits - see
&lt;a href="http://grsecurity.net/"&gt;grsecurity&lt;/a&gt; as one of the solutions that could
be used).&lt;/p&gt;
&lt;p&gt;Still, I believe that SELinux can definitely provide additional
protections for such "one-time deployments" where a company cannot
invest in resources to provide engineering services on those
deployments. The SELinux security controls do not require engineering on
the application side, making investments in SELinux engineering very
much reusable.&lt;/p&gt;</content><category term="SELinux"></category><category term="companies"></category><category term="configuration"></category><category term="engineering"></category><category term="enterprise"></category><category term="selinux"></category></entry><entry><title>Why does it access /etc/shadow?</title><link href="https://blog.siphos.be/2014/12/why-does-it-access-etcshadow/" rel="alternate"></link><published>2014-12-30T22:48:00+01:00</published><updated>2014-12-30T22:48:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-12-30:/2014/12/why-does-it-access-etcshadow/</id><summary type="html">&lt;p&gt;While updating the SELinux policy for the Courier IMAP daemon, I noticed
that it (well, the authdaemon that is part of Courier) wanted to access
&lt;code&gt;/etc/shadow&lt;/code&gt;, which is of course a big no-no. It doesn't take long to
know that this is through the PAM support (more specifically,
&lt;code&gt;pam_unix &lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;While updating the SELinux policy for the Courier IMAP daemon, I noticed
that it (well, the authdaemon that is part of Courier) wanted to access
&lt;code&gt;/etc/shadow&lt;/code&gt;, which is of course a big no-no. It doesn't take long to
know that this is through the PAM support (more specifically,
&lt;code&gt;pam_unix.so&lt;/code&gt;). But why? After all, &lt;code&gt;pam_unix.so&lt;/code&gt; should try to execute
&lt;code&gt;unix_chkpwd&lt;/code&gt; to verify a password and not read in the shadow file
directly (which would require all PAM-aware applications to be granted
access to the shadow file).&lt;/p&gt;
&lt;p&gt;So I dived into the PAM-Linux sources (yay free software).&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;pam_unix_passwd.c&lt;/code&gt;, the &lt;em&gt;_unix_run_verify_binary()&lt;/em&gt; method is
called but only if the &lt;em&gt;get_account_info()&lt;/em&gt; method returns
&lt;code&gt;PAM_UNIX_RUN_HELPER&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;static int _unix_verify_shadow(pam_handle_t *pamh, const char *user, unsigned int ctrl)
{
...
        retval = get_account_info(pamh, user, &amp;amp;pwent, &amp;amp;spent);
...
        if (retval == PAM_UNIX_RUN_HELPER) {
                retval = _unix_run_verify_binary(pamh, ctrl, user, &amp;amp;daysleft);
                if (retval == PAM_AUTH_ERR || retval == PAM_USER_UNKNOWN)
                        return retval;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In &lt;code&gt;passverify.c&lt;/code&gt; this method will check the password entry file and, if
the entry is a shadow file, will return &lt;code&gt;PAM_UNIX_RUN_HELPER&lt;/code&gt; if the
current user id is not root, or if SELinux is enabled:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;PAMH_ARG_DECL(int get_account_info,
        const char *name, struct passwd **pwd, struct spwd **spwdent)
{
        /* UNIX passwords area */
        *pwd = pam_modutil_getpwnam(pamh, name);        /* Get password file entry... */
        *spwdent = NULL;

        if (*pwd != NULL) {
...
                } else if (is_pwd_shadowed(*pwd)) {
                        /*
                         * ...and shadow password file entry for this user,
                         * if shadowing is enabled
                         */
#ifndef HELPER_COMPILE
                        if (geteuid() || SELINUX_ENABLED)
                                return PAM_UNIX_RUN_HELPER;
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;SELINUX_ENABLED&lt;/code&gt; is a C macro defined in the same file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#ifdef WITH_SELINUX
#include 
#define SELINUX_ENABLED is_selinux_enabled()&amp;gt;0
#else
#define SELINUX_ENABLED 0
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And this is where my "aha" moment came forth: the Courier authdaemon
runs as root, so its user id is 0. The &lt;em&gt;geteuid()&lt;/em&gt; method will return 0,
so the &lt;code&gt;SELINUX_ENABLED&lt;/code&gt; macro must return non-zero for the proper path
to be followed. A quick check in the audit logs, after disabling
&lt;em&gt;dontaudit&lt;/em&gt; lines, showed that the Courier IMAPd daemon wants to get the
attribute(s) of the &lt;code&gt;security_t&lt;/code&gt; file system (on which the SELinux
information is exposed). As this was denied, the call to
&lt;em&gt;is_selinux_enabled()&lt;/em&gt; returns -1 (error) which, through the macro,
becomes 0.&lt;/p&gt;
&lt;p&gt;So granting &lt;em&gt;selinux_getattr_fs(courier_authdaemon_t)&lt;/em&gt; was enough to
get it to use the &lt;code&gt;unix_chkpwd&lt;/code&gt; binary again.&lt;/p&gt;
&lt;p&gt;To fix this properly, we need to grant this to all PAM using
applications. There is an interface called &lt;em&gt;auth_use_pam()&lt;/em&gt; in the
policies, but that isn't used by the Courier policy. Until now, that is
;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="chkpwd"></category><category term="pam"></category><category term="selinux"></category><category term="shadow"></category><category term="unix_chkpwd"></category></entry><entry><title>Sometimes I forget how important communication is</title><link href="https://blog.siphos.be/2014/12/sometimes-i-forget-how-important-communication-is/" rel="alternate"></link><published>2014-12-10T20:38:00+01:00</published><updated>2014-12-10T20:38:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-12-10:/2014/12/sometimes-i-forget-how-important-communication-is/</id><summary type="html">&lt;p&gt;Free software (and documentation) developers don't always have all the
time they want. Instead, they grab whatever time they have to do what
they believe is the most productive - be it documentation editing,
programming, updating ebuilds, SELinux policy improvements and what not.
But they often don't take the time to &lt;/p&gt;</summary><content type="html">&lt;p&gt;Free software (and documentation) developers don't always have all the
time they want. Instead, they grab whatever time they have to do what
they believe is the most productive - be it documentation editing,
programming, updating ebuilds, SELinux policy improvements and what not.
But they often don't take the time to communicate. And communication is
important.&lt;/p&gt;
&lt;p&gt;For one, communication is needed to reach a larger audience than those
that follow the commit history in whatever repository work is being
done. Yes, there are developers that follow &lt;a href="http://news.gmane.org/gmane.linux.gentoo.cvs"&gt;each
commit&lt;/a&gt;, but development
isn't just done for developers, it is also for end users. And end users
deserve frequent updates and feedback. Be it through blog posts, Google+
posts, tweets or instragrams (well, I'm not sure how to communicate a
software or documentation change through Instagram, but I'm sure people
find lots of creative ways to do so), telling the broader world what has
changed is important.&lt;/p&gt;
&lt;p&gt;Perhaps a (silent or not) user was waiting for this change. Perhaps he
or she is even actually trying to fix things himself/herself but is
struggling with it, and would really benefit (time-wise) from a quick
fix. Without communicating about the change, (s)he does not know that no
further attempts are needed, actually reducing the efficiency in
overall.&lt;/p&gt;
&lt;p&gt;But communication is just one-way. Better is to get feedback as well. In
that sense, communication is just one part of the feedback loop - once
developers receive feedback on what they are doing (or did recently)
they might even improve results faster. With feedback loops, the wisdom
of the crowd (in the positive sense) can be used to improve solutions
beyond what the developer originally intended. And even a simple "cool"
and "I like" is good information for a developer or contributor.&lt;/p&gt;
&lt;p&gt;Still, I often forget to do it - or don't have the time to focus on
communication. And that's bad. So, let me quickly state what things I
forgot to communicate more broadly about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;a href="http://comments.gmane.org/gmane.linux.gentoo.project/4129"&gt;new
    developer&lt;/a&gt;
    joined the Gentoo ranks: Jason Zaman. Now developers join Gentoo
    more often than just once in a while, but Jason is one of
    my "recruits". In a sense, he became a developer because I was tired
    of pulling his changes in and proxy-committing stuff. Of course,
    that's only half the truth; he is also a very active contributor in
    other areas (and was already a maintainer for a few packages through
    the proxy-maintainer project) and is a tremendous help in the Gentoo
    Hardened project. So welcome onboard Jason (or perfinion as he calls
    himself online).&lt;/li&gt;
&lt;li&gt;I've started with &lt;a href="https://wiki.gentoo.org/wiki/Project:Documentation/HandbookDevelopment"&gt;copying the Gentoo handbook to the
    wiki&lt;/a&gt;.
    This is still an on-going project, but was long overdue. There are
    many reasons why the move to the wiki is interesting. For me
    personally, it is to attract a larger audience to update
    the handbook. Although the document will be restricted for editing
    by developers and trusted contributors only (it does contain the
    installation instructions and is a primary entry point for
    many users) that's still a whole lot more than when just a handful
    (one or two actually) developers update the handbook.&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/SELinuxProject/selinux/wiki/Releases"&gt;SELinux
    userspace&lt;/a&gt;
    (2.4 release) is looking more stable; there are no specific
    regressions anymore (upstream is at release candidate 7) although I
    must admit that I have not implemented it on the majority of test
    systems that I maintain. Not due to fears, but mostly because I
    struggle a bit with available time so I can do without testing
    upgrades that are not needed. I do plan on moving towards 2.4 in a
    week or two.&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/TresysTechnology/refpolicy/wiki"&gt;reference
    policy&lt;/a&gt; has
    released a new version of the policy. Gentoo quickly followed
    through (Jason did the honors of creating the ebuilds).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, apologies for not communicating sooner, and I promise I'll try to
uplift the communication frequency.&lt;/p&gt;</content><category term="Gentoo"></category><category term="communication"></category><category term="developer"></category><category term="Gentoo"></category><category term="selinux"></category><category term="time"></category></entry><entry><title>No more DEPENDs for SELinux policy package dependencies</title><link href="https://blog.siphos.be/2014/11/no-more-depends-for-selinux-policy-package-dependencies/" rel="alternate"></link><published>2014-11-02T14:51:00+01:00</published><updated>2014-11-02T14:51:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-11-02:/2014/11/no-more-depends-for-selinux-policy-package-dependencies/</id><summary type="html">&lt;p&gt;I just finished updating 102 packages. The change? Removing the
following from the ebuilds:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;DEPEND=&amp;quot;selinux? ( sec-policy/selinux-${packagename} )&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the past, we needed this construction in both DEPEND and RDEPEND.
Recently however, the SELinux eclass got updated with some logic to
relabel files after the policy package is deployed &lt;/p&gt;</summary><content type="html">&lt;p&gt;I just finished updating 102 packages. The change? Removing the
following from the ebuilds:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;DEPEND=&amp;quot;selinux? ( sec-policy/selinux-${packagename} )&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the past, we needed this construction in both DEPEND and RDEPEND.
Recently however, the SELinux eclass got updated with some logic to
relabel files after the policy package is deployed. As a result, the
DEPEND variable no longer needs to refer to the SELinux policy package.&lt;/p&gt;
&lt;p&gt;This change also means that for those moving from a regular Gentoo
installation to an SELinux installation will have much less packages to
rebuild. In the past, getting &lt;code&gt;USE="selinux"&lt;/code&gt; (through the SELinux
profiles) would rebuild all packages that have a DEPEND dependency to
the SELinux policy package. No more - only packages that depend on the
SELinux libraries (like &lt;code&gt;libselinux&lt;/code&gt;) or utilities rebuild. The rest
will just pull in the proper policy package.&lt;/p&gt;</content><category term="Gentoo"></category><category term="DEPEND"></category><category term="ebuild"></category><category term="Gentoo"></category><category term="RDEPEND"></category><category term="selinux"></category></entry><entry><title>Using multiple priorities with modules</title><link href="https://blog.siphos.be/2014/10/using-multiple-priorities-with-modules/" rel="alternate"></link><published>2014-10-31T18:24:00+01:00</published><updated>2014-10-31T18:24:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-10-31:/2014/10/using-multiple-priorities-with-modules/</id><summary type="html">&lt;p&gt;One of the new features of the 2.4 SELinux userspace is support for
module priorities. The idea is that distributions and administrators can
override a (pre)loaded SELinux policy module with another module without
removing the previous module. This lower-version module will remain in
the store, but will not &lt;/p&gt;</summary><content type="html">&lt;p&gt;One of the new features of the 2.4 SELinux userspace is support for
module priorities. The idea is that distributions and administrators can
override a (pre)loaded SELinux policy module with another module without
removing the previous module. This lower-version module will remain in
the store, but will not be active until the higher-priority module is
disabled or removed again.&lt;/p&gt;
&lt;p&gt;The "old" modules (pre-2.4) are loaded with priority 100. When policy
modules with the 2.4 SELinux userspace series are loaded, they get
loaded with priority 400. As a result, the following message occurs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -i screen.pp
libsemanage.semanage_direct_install_info: Overriding screen module at lower priority 100 with module at priority 400
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So unlike the previous situation, where the older module is substituted
with the new one, we now have two "screen" modules loaded; the last one
gets priority 400 and is active. To see all installed modules and
priorities, use the &lt;code&gt;--list-modules&lt;/code&gt; option:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule --list-modules=all | grep screen
100 screen     pp
400 screen     pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Older versions of modules can be removed by specifying the priority:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semodule -X 100 -r screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category><category term="priorities"></category><category term="priority"></category><category term="selinux"></category><category term="semodule"></category></entry><entry><title>Migrating to SELinux userspace 2.4 (small warning for users)</title><link href="https://blog.siphos.be/2014/10/migrating-to-selinux-userspace-2-4-small-warning-for-users/" rel="alternate"></link><published>2014-10-30T19:44:00+01:00</published><updated>2014-10-30T19:44:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-10-30:/2014/10/migrating-to-selinux-userspace-2-4-small-warning-for-users/</id><summary type="html">&lt;p&gt;In a few moments, SELinux users which have the \~arch KEYWORDS set
(either globally or for the SELinux utilities in particular) will notice
that the SELinux userspace will upgrade to version 2.4 (release
candidate 5 for now). This upgrade comes with a manual step that needs
to be performed &lt;/p&gt;</summary><content type="html">&lt;p&gt;In a few moments, SELinux users which have the \~arch KEYWORDS set
(either globally or for the SELinux utilities in particular) will notice
that the SELinux userspace will upgrade to version 2.4 (release
candidate 5 for now). This upgrade comes with a manual step that needs
to be performed after upgrade. The information is mentioned as
post-installation message of the &lt;code&gt;policycoreutils&lt;/code&gt; package, and
basically sais that you need to execute:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# /usr/libexec/selinux/semanage_migrate_store
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The reason is that the SELinux utilities expect the SELinux policy
module store (and the semanage related files) to be in
&lt;code&gt;/var/lib/selinux&lt;/code&gt; and no longer in &lt;code&gt;/etc/selinux&lt;/code&gt;. Note that this does
not mean that the SELinux policy itself is moved outside of that
location, nor is the basic configuration file (&lt;code&gt;/etc/selinux/config&lt;/code&gt;).
It is what tools such as &lt;strong&gt;semanage&lt;/strong&gt; manage that is moved outside that
location.&lt;/p&gt;
&lt;p&gt;I tried to automate the migration as part of the packages themselves,
but this would require the &lt;code&gt;portage_t&lt;/code&gt; domain to be able to move,
rebuild and load policies, which it can't (and to be honest, shouldn't).
Instead of augmenting the policy or making updates to the migration
script as delivered by the upstream project, we currently decided to
have the migration done manually. It is a one-time migration anyway.&lt;/p&gt;
&lt;p&gt;If for some reason end users forget to do the migration, then that does
not mean that the system breaks or becomes unusable. SELinux still
works, SELinux aware applications still work; the only thing that will
fail are updates on the SELinux configuration through tools like
&lt;strong&gt;semanage&lt;/strong&gt; or &lt;strong&gt;setsebool&lt;/strong&gt; - the latter when you want to persist
boolean changes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage fcontext -l
ValueError: SELinux policy is not managed or store cannot be accessed.

~# setsebool -P allow_ptrace on
Cannot set persistent booleans without managed policy.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you get those errors or warnings, all that is left to do is to do the
migration. Note in the following that there is a warning about 'else'
blocks that are no longer supported: that's okay, as far as I know (and
it was mentioned on the upstream mailinglist as well as not something to
worry about) it does not have any impact.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# /usr/libexec/selinux/semanage_migrate_store
Migrating from /etc/selinux/mcs/modules/active to /var/lib/selinux/mcs/active
Attempting to rebuild policy from /var/lib/selinux
sysnetwork: Warning: &amp;#39;else&amp;#39; blocks in optional statements are unsupported in CIL. Dropping from output.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can also add in &lt;code&gt;-c&lt;/code&gt; so that the old policy module store is cleaned
up. You can also rerun the command multiple times:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# /usr/libexec/selinux/semanage_migrate_store -c
warning: Policy type mcs has already been migrated, but modules still exist in the old store. Skipping store.
Attempting to rebuild policy from /var/lib/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can manually clean up the old policy module store like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# rm -rf /etc/selinux/mcs/modules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So... don't worry - the change is small and does not break stuff. And
for those wondering about CIL I'll talk about it in one of my next
posts.&lt;/p&gt;</content><category term="Gentoo"></category><category term="cil"></category><category term="Gentoo"></category><category term="migrate"></category><category term="selinux"></category><category term="semanage"></category><category term="upgrade"></category><category term="userspace"></category></entry><entry><title>Some changes under the hood</title><link href="https://blog.siphos.be/2014/08/some-changes-under-the-hood/" rel="alternate"></link><published>2014-08-09T21:45:00+02:00</published><updated>2014-08-09T21:45:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-08-09:/2014/08/some-changes-under-the-hood/</id><summary type="html">&lt;p&gt;In between conferences, technical writing jobs and traveling, we did a
few changes under the hood for SELinux in Gentoo.&lt;/p&gt;
&lt;p&gt;First of all, new policies are bumped and also stabilized (2.20130411-r3
is now stable, 2.20130411-r5 is \~arch). These have a few updates
(mergers from upstream), and r5 also &lt;/p&gt;</summary><content type="html">&lt;p&gt;In between conferences, technical writing jobs and traveling, we did a
few changes under the hood for SELinux in Gentoo.&lt;/p&gt;
&lt;p&gt;First of all, new policies are bumped and also stabilized (2.20130411-r3
is now stable, 2.20130411-r5 is \~arch). These have a few updates
(mergers from upstream), and r5 also has preliminary support for
&lt;a href="http://www.freedesktop.org/software/systemd/man/tmpfiles.d.html"&gt;tmpfiles&lt;/a&gt;
(at least the OpenRC implementation of it), which is made part of the
&lt;a href="http://packages.gentoo.org/package/sec-policy/selinux-base-policy"&gt;selinux-base-policy&lt;/a&gt;
package.&lt;/p&gt;
&lt;p&gt;The ebuilds to support new policy releases now are relatively simple
copies of the live ebuilds (which always contain the latest policies) so
that bumping (either by me or other developers) is easy enough. There's
also a release script in our policy repository which tags the right git
commit (the point at which the release is made), creates the necessary
patches, uploads them, etc.&lt;/p&gt;
&lt;p&gt;One of the changes made is to "drop" the &lt;code&gt;BASEPOL&lt;/code&gt; variable. In the
past, &lt;code&gt;BASEPOL&lt;/code&gt; was a variable inside the ebuilds that pointed to the
right patchset (and base policy) as we initially supported policy
modules of different base releases. However, that was a mistake and we
quickly moved to bumping all policies with every releaes, but kept the
&lt;code&gt;BASEPOL&lt;/code&gt; variable in it. Now, &lt;code&gt;BASEPOL&lt;/code&gt; is "just" the &lt;code&gt;${PVR}&lt;/code&gt; value of
the ebuild so no longer needs to be provided. In the future, I'll
probably remove &lt;code&gt;BASEPOL&lt;/code&gt; from the internal eclass and the
&lt;code&gt;selinux-base*&lt;/code&gt; packages as well.&lt;/p&gt;
&lt;p&gt;A more important change to the eclass is support for the
&lt;code&gt;SELINUX_GIT_REPO&lt;/code&gt; and &lt;code&gt;SELINUX_GIT_BRANCH&lt;/code&gt; variables (for live ebuilds,
i.e. those with the 9999 version). If set, then they pull from the
mentioned repository (and branch) instead of the default
&lt;a href="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-refpolicy.git;a=summary"&gt;hardened-refpolicy.git&lt;/a&gt;
repository. This allows for developers to do some testing on a different
branch easily, or for other users to use their own policy repository
while still enjoying the SELinux integration support in Gentoo through
the &lt;code&gt;sec-policy/*&lt;/code&gt; packages.&lt;/p&gt;
&lt;p&gt;Finally, I wrote up a first attempt at our &lt;a href="https://wiki.gentoo.org/wiki/Project:SELinux/CodingStyle"&gt;coding
style&lt;/a&gt;,
heavily based on the coding style from the reference policy of course
(as our policy is still following this upstream project). This should
allow the team to work better together and to decide on namings
autonomously (instead of hours of discussing and settling for something
as silly as an interface or boolean name ;-)&lt;/p&gt;</content><category term="Gentoo"></category><category term="eclass"></category><category term="Gentoo"></category><category term="git"></category><category term="hardened"></category><category term="refpolicy"></category><category term="selinux"></category></entry><entry><title>D-Bus and SELinux</title><link href="https://blog.siphos.be/2014/06/d-bus-and-selinux/" rel="alternate"></link><published>2014-06-30T20:07:00+02:00</published><updated>2014-06-30T20:07:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-06-30:/2014/06/d-bus-and-selinux/</id><summary type="html">&lt;p&gt;After a &lt;a href="http://blog.siphos.be/2014/06/d-bus-quick-recap/"&gt;post about
D-Bus&lt;/a&gt; comes the
inevitable related post about SELinux with D-Bus.&lt;/p&gt;
&lt;p&gt;Some users might not know that D-Bus is an SELinux-aware application.
That means it has SELinux-specific code in it, which has the D-Bus
behavior based on the SELinux policy (and might not necessarily honor
the "permissive &lt;/p&gt;</summary><content type="html">&lt;p&gt;After a &lt;a href="http://blog.siphos.be/2014/06/d-bus-quick-recap/"&gt;post about
D-Bus&lt;/a&gt; comes the
inevitable related post about SELinux with D-Bus.&lt;/p&gt;
&lt;p&gt;Some users might not know that D-Bus is an SELinux-aware application.
That means it has SELinux-specific code in it, which has the D-Bus
behavior based on the SELinux policy (and might not necessarily honor
the "permissive" flag). This code is used as an additional
authentication control within D-Bus.&lt;/p&gt;
&lt;p&gt;Inside the SELinux policy, a &lt;em&gt;dbus&lt;/em&gt; permission class is supported, even
though the Linux kernel doesn't do anything with this class. The class
is purely for D-Bus, and it is D-Bus that checks the permission
(although work is being made to &lt;a href="https://lwn.net/Articles/580194/"&gt;implement D-Bus in kernel
(kdbus)&lt;/a&gt;). The class supports two
permission checks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;acquire_svc&lt;/em&gt; which tells the domain(s) allowed to "own" a service
    (which might, thanks to the SELinux support, be different from the
    domain itself)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;send_msg&lt;/em&gt; which tells which domain(s) can send messages to a
    service domain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inside the D-Bus security configuration (the &lt;code&gt;busconfig&lt;/code&gt; XML file,
remember) a service configuration might tell D-Bus that the service
itself is labeled differently from the process that owned the service.
The default is that the service inherits the label from the domain, so
when &lt;code&gt;dnsmasq_t&lt;/code&gt; registers a service on the system bus, then this
service also inherits the &lt;code&gt;dnsmasq_t&lt;/code&gt; label.&lt;/p&gt;
&lt;p&gt;The necessary permission checks for the &lt;code&gt;sysadm_t&lt;/code&gt; user domain to send
messages to the dnsmasq service, and the dnsmasq service itself to
register it as a service:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow dnsmasq_t self:dbus { acquire_svc send_msg };
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For the &lt;code&gt;sysadm_t&lt;/code&gt; domain, the two rules are needed as we usually not
only want to send a message to a D-Bus service, but also receive a reply
(which is also handled through a &lt;em&gt;send_msg&lt;/em&gt; permission but in the
inverse direction).&lt;/p&gt;
&lt;p&gt;However, with the following XML snippet inside its service configuration
file, owning a certain resource is checked against a different label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;busconfig&amp;gt;
  &amp;lt;selinux&amp;gt;
    &amp;lt;associate
      own=&amp;quot;uk.org.thekelleys.dnsmasq&amp;quot;
      context=&amp;quot;system_u:object_r:dnsmasq_dbus_t:s0&amp;quot; /&amp;gt;
  &amp;lt;/selinux&amp;gt;
&amp;lt;/busconfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this, the rules would become as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow dnsmasq_t dnsmasq_dbus_t:dbus acquire_svc;
allow dnsmasq_t self:dbus send_msg;
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that &lt;em&gt;only&lt;/em&gt; the access for acquiring a service based on a name
(i.e. owning a service) is checked based on the different label. Sending
and receiving messages is still handled by the domains of the processes
(actually the labels of the connections, but these are always the
process domains).&lt;/p&gt;
&lt;p&gt;I am not aware of any policy implementation that uses a different label
for owning services, and the implementation is more suited to "force"
D-Bus to only allow services with a correct label. This ensures that
other domains that might have enough privileges to interact with D-Bus
and own a service cannot own these particular services. After all, other
services don't usually have the privileges (policy-wise) to
&lt;em&gt;acquire_svc&lt;/em&gt; a service with a different label than their own label.&lt;/p&gt;</content><category term="SELinux"></category><category term="busconfig"></category><category term="d-bus"></category><category term="dbus"></category><category term="linux"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Chroots for SELinux enabled applications</title><link href="https://blog.siphos.be/2014/06/chroots-for-selinux-enabled-applications/" rel="alternate"></link><published>2014-06-22T20:16:00+02:00</published><updated>2014-06-22T20:16:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-06-22:/2014/06/chroots-for-selinux-enabled-applications/</id><summary type="html">&lt;p&gt;Today I had to prepare a chroot jail (thank you grsecurity for the neat
additional chroot protection features) for a SELinux-enabled
application. As a result, "just" making a chroot was insufficient: the
application needed access to &lt;code&gt;/sys/fs/selinux&lt;/code&gt;. Of course, granting
access to &lt;code&gt;/sys&lt;/code&gt; is not something I like &lt;/p&gt;</summary><content type="html">&lt;p&gt;Today I had to prepare a chroot jail (thank you grsecurity for the neat
additional chroot protection features) for a SELinux-enabled
application. As a result, "just" making a chroot was insufficient: the
application needed access to &lt;code&gt;/sys/fs/selinux&lt;/code&gt;. Of course, granting
access to &lt;code&gt;/sys&lt;/code&gt; is not something I like to see for a chroot jail.&lt;/p&gt;
&lt;p&gt;Luckily, all other accesses are not needed, so I was able to create a
static &lt;code&gt;/sys/fs/selinux&lt;/code&gt; directory structure in the chroot, and then
just mount the SELinux file system on that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# mount -t selinuxfs none /var/chroot/sys/fs/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In hindsight, I probably could just have created a &lt;code&gt;/selinux&lt;/code&gt; location
as that location, although deprecated, is still checked by the SELinux
libraries.&lt;/p&gt;
&lt;p&gt;Anyway, there was a second requirement: access to &lt;code&gt;/etc/selinux&lt;/code&gt;.
Luckily it was purely for read operations, so I was first contemplating
of copying the data and doing a &lt;strong&gt;chmod -R a-w
/var/chroot/etc/selinux&lt;/strong&gt;, but then considered a bind-mount:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# mount -o bind,ro /etc/selinux /var/chroot/etc/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Alas, bad luck - the read-only flag is ignored during the mount, and the
bind-mount is still read-write. A &lt;a href="http://lwn.net/Articles/281157/"&gt;simple article on
lwn.net&lt;/a&gt; informed me about the
solution: I need to do a remount afterwards to enable the read-only
state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# mount -o remount,ro /var/chroot/etc/selinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Great! And because my brain isn't what it used to be, I just make a
quick blog for future reference ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="bind-mount"></category><category term="bindmount"></category><category term="mount"></category><category term="read-only"></category><category term="ro"></category><category term="selinux"></category></entry><entry><title>Visualizing constraints</title><link href="https://blog.siphos.be/2014/05/visualizing-constraints/" rel="alternate"></link><published>2014-05-31T03:47:00+02:00</published><updated>2014-05-31T03:47:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-05-31:/2014/05/visualizing-constraints/</id><summary type="html">&lt;p&gt;SELinux constraints are an interesting way to implement specific, well,
constraints on what SELinux allows. Most SELinux rules that users come
in contact with are purely type oriented: allow something to do
something against something. In fact, most of the SELinux rules applied
on a system are such &lt;code&gt;allow&lt;/code&gt; rules &lt;/p&gt;</summary><content type="html">&lt;p&gt;SELinux constraints are an interesting way to implement specific, well,
constraints on what SELinux allows. Most SELinux rules that users come
in contact with are purely type oriented: allow something to do
something against something. In fact, most of the SELinux rules applied
on a system are such &lt;code&gt;allow&lt;/code&gt; rules.&lt;/p&gt;
&lt;p&gt;The restriction of such &lt;code&gt;allow&lt;/code&gt; rules is that they only take into
consideration the &lt;em&gt;type&lt;/em&gt; of the contexts that participate. This is the
&lt;a href="https://wiki.gentoo.org/wiki/SELinux/Type_enforcement"&gt;type
enforcement&lt;/a&gt; part
of the SELinux mandatory access control system.&lt;/p&gt;
&lt;p&gt;Constraints on the other hand work on the user, role and type part of a
context. Consider this piece of constraint code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;constrain file all_file_perms (
  u1 == u2
  or u1 == system_u
  or u2 == system_u
  or t1 != ubac_constrained_type
  or t2 != ubac_constrained_type
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This particular constraint definition tells the SELinux subsystem that,
when an operation against a &lt;em&gt;file&lt;/em&gt; class is performed (any operation, as
&lt;em&gt;all_file_perms&lt;/em&gt; is used, but individual, specific permissions can be
listed as well), this is denied if none of the following conditions are
met:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The SELinux user of the subject and object are the same&lt;/li&gt;
&lt;li&gt;The SELinux user of the subject or object is &lt;code&gt;system_u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The SELinux type of the subject does not have the
    &lt;code&gt;ubac_constrained_type&lt;/code&gt; attribute set&lt;/li&gt;
&lt;li&gt;The SELinux type of the object does not have the
    &lt;code&gt;ubac_constrained_type&lt;/code&gt; attribute set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If none of the conditions are met, then the action is denied, regardless
of the &lt;code&gt;allow&lt;/code&gt; rules set otherwise. If at least one condition is met,
then the &lt;code&gt;allow&lt;/code&gt; rules (and other SELinux rules) decide if an action can
be taken or not.&lt;/p&gt;
&lt;p&gt;Constraints are currently difficult to query though. There is &lt;strong&gt;seinfo
--constrain&lt;/strong&gt; which gives all constraints, using the Reverse Polish
Notation - not something easily readable by users:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ seinfo --constrain
constrain { sem } { create destroy getattr setattr read write associate unix_read unix_write  } 
(  u1 u2 ==  u1 system_u ==  ||  u2 system_u ==  ||  t1 { screen_var_run_t gnome_xdg_config_home_t admin_crontab_t 
links_input_xevent_t gpg_pinentry_tmp_t virt_content_t print_spool_t crontab_tmp_t httpd_user_htaccess_t ssh_keysign_t 
remote_input_xevent_t gnome_home_t mozilla_tmpfs_t staff_gkeyringd_t consolekit_input_xevent_t user_mail_tmp_t 
chromium_xdg_config_t mozilla_input_xevent_t chromium_tmp_t httpd_user_script_exec_t gnome_keyring_tmp_t links_tmpfs_t 
skype_tmp_t user_gkeyringd_t svirt_home_t sysadm_su_t virt_home_t skype_home_t wireshark_tmp_t xscreensaver_xproperty_t 
consolekit_xproperty_t user_home_dir_t gpg_pinentry_xproperty_t mplayer_home_t mozilla_plugin_input_xevent_t mozilla_plugin_tmp_t 
mozilla_xproperty_t xdm_input_xevent_t chromium_input_xevent_t java_tmpfs_t googletalk_plugin_xproperty_t sysadm_t gorg_t gpg_t 
java_t links_t staff_dbusd_t httpd_user_ra_content_t httpd_user_rw_content_t googletalk_plugin_tmp_t gpg_agent_tmp_t 
ssh_agent_tmp_t sysadm_ssh_agent_t user_fonts_cache_t user_tmp_t googletalk_plugin_input_xevent_t user_dbusd_t xserver_tmpfs_t 
iceauth_home_t qemu_input_xevent_t xauth_home_t mutt_home_t sysadm_dbusd_t remote_xproperty_t gnome_xdg_config_t screen_home_t 
chromium_xproperty_t chromium_tmpfs_t wireshark_tmpfs_t xdg_videos_home_t pulseaudio_input_xevent_t krb5_home_t 
pulseaudio_xproperty_t xscreensaver_input_xevent_t gpg_pinentry_input_xevent_t httpd_user_script_t gnome_xdg_cache_home_t 
mozilla_plugin_tmpfs_t user_home_t user_sudo_t ssh_input_xevent_t ssh_tmpfs_t xdg_music_home_t gconf_tmp_t flash_home_t 
java_home_t skype_tmpfs_t xdg_pictures_home_t xdg_data_home_t gnome_keyring_home_t wireshark_home_t chromium_renderer_xproperty_t 
gpg_pinentry_t mozilla_t session_dbusd_tmp_t staff_sudo_t xdg_config_home_t user_su_t pan_input_xevent_t user_devpts_t 
mysqld_home_t pan_tmpfs_t root_input_xevent_t links_home_t sysadm_screen_t pulseaudio_tmpfs_t sysadm_gkeyringd_t mail_home_rw_t 
gconf_home_t mozilla_plugin_xproperty_t mutt_tmp_t httpd_user_content_t mozilla_xdg_cache_t mozilla_home_t alsa_home_t 
pulseaudio_t mencoder_t admin_crontab_tmp_t xdg_documents_home_t user_tty_device_t java_tmp_t gnome_xdg_data_home_t wireshark_t 
mozilla_plugin_home_t googletalk_plugin_tmpfs_t user_cron_spool_t mplayer_input_xevent_t skype_input_xevent_t xxe_home_t 
mozilla_tmp_t gconfd_t lpr_t mutt_t pan_t ssh_t staff_t user_t xauth_t skype_xproperty_t mozilla_plugin_config_t 
links_xproperty_t mplayer_xproperty_t xdg_runtime_home_t cert_home_t mplayer_tmpfs_t user_fonts_t user_tmpfs_t mutt_conf_t 
gpg_secret_t gpg_helper_t staff_ssh_agent_t pulseaudio_tmp_t xscreensaver_t googletalk_plugin_xdg_config_t staff_screen_t 
user_fonts_config_t ssh_home_t staff_su_t screen_tmp_t mozilla_plugin_t user_input_xevent_t xserver_tmp_t wireshark_xproperty_t 
user_mail_t pulseaudio_home_t xdg_cache_home_t user_ssh_agent_t xdg_downloads_home_t chromium_renderer_input_xevent_t cronjob_t 
crontab_t pan_home_t session_dbusd_home_t gpg_agent_t xauth_tmp_t xscreensaver_tmpfs_t iceauth_t mplayer_t chromium_xdg_cache_t 
lpr_tmp_t gpg_pinentry_tmpfs_t pan_xproperty_t ssh_xproperty_t xdm_xproperty_t java_xproperty_t sysadm_sudo_t qemu_xproperty_t 
root_xproperty_t user_xproperty_t mail_home_t xserver_t java_input_xevent_t user_screen_t wireshark_input_xevent_t } !=  ||  t2 { 
screen_var_run_t gnome_xdg_config_home_t admin_crontab_t links_input_xevent_t gpg_pinentry_tmp_t virt_content_t print_spool_t 
crontab_tmp_t httpd_user_htaccess_t ssh_keysign_t remote_input_xevent_t gnome_home_t mozilla_tmpfs_t staff_gkeyringd_t 
consolekit_input_xevent_t user_mail_tmp_t chromium_xdg_config_t mozilla_input_xevent_t chromium_tmp_t httpd_user_script_exec_t 
gnome_keyring_tmp_t links_tmpfs_t skype_tmp_t user_gkeyringd_t svirt_home_t sysadm_su_t virt_home_t skype_home_t wireshark_tmp_t 
xscreensaver_xproperty_t consolekit_xproperty_t user_home_dir_t gpg_pinentry_xproperty_t mplayer_home_t 
mozilla_plugin_input_xevent_t mozilla_plugin_tmp_t mozilla_xproperty_t xdm_input_xevent_t chromium_input_xevent_t java_tmpfs_t 
googletalk_plugin_xproperty_t sysadm_t gorg_t gpg_t java_t links_t staff_dbusd_t httpd_user_ra_content_t httpd_user_rw_content_t 
googletalk_plugin_tmp_t gpg_agent_tmp_t ssh_agent_tmp_t sysadm_ssh_agent_t user_fonts_cache_t user_tmp_t 
googletalk_plugin_input_xevent_t user_dbusd_t xserver_tmpfs_t iceauth_home_t qemu_input_xevent_t xauth_home_t mutt_home_t 
sysadm_dbusd_t remote_xproperty_t gnome_xdg_config_t screen_home_t chromium_xproperty_t chromium_tmpfs_t wireshark_tmpfs_t 
xdg_videos_home_t pulseaudio_input_xevent_t krb5_home_t pulseaudio_xproperty_t xscreensaver_input_xevent_t 
gpg_pinentry_input_xevent_t httpd_user_script_t gnome_xdg_cache_home_t mozilla_plugin_tmpfs_t user_home_t user_sudo_t 
ssh_input_xevent_t ssh_tmpfs_t xdg_music_home_t gconf_tmp_t flash_home_t java_home_t skype_tmpfs_t xdg_pictures_home_t 
xdg_data_home_t gnome_keyring_home_t wireshark_home_t chromium_renderer_xproperty_t gpg_pinentry_t mozilla_t session_dbusd_tmp_t 
staff_sudo_t xdg_config_home_t user_su_t pan_input_xevent_t user_devpts_t mysqld_home_t pan_tmpfs_t root_input_xevent_t 
links_home_t sysadm_screen_t pulseaudio_tmpfs_t sysadm_gkeyringd_t mail_home_rw_t gconf_home_t mozilla_plugin_xproperty_t 
mutt_tmp_t httpd_user_content_t mozilla_xdg_cache_t mozilla_home_t alsa_home_t pulseaudio_t mencoder_t admin_crontab_tmp_t 
xdg_documents_home_t user_tty_device_t java_tmp_t gnome_xdg_data_home_t wireshark_t mozilla_plugin_home_t 
googletalk_plugin_tmpfs_t user_cron_spool_t mplayer_input_xevent_t skype_input_xevent_t xxe_home_t mozilla_tmp_t gconfd_t lpr_t 
mutt_t pan_t ssh_t staff_t user_t xauth_t skype_xproperty_t mozilla_plugin_config_t links_xproperty_t mplayer_xproperty_t 
xdg_runtime_home_t cert_home_t mplayer_tmpfs_t user_fonts_t user_tmpfs_t mutt_conf_t gpg_secret_t gpg_helper_t staff_ssh_agent_t 
pulseaudio_tmp_t xscreensaver_t googletalk_plugin_xdg_config_t staff_screen_t user_fonts_config_t ssh_home_t staff_su_t 
screen_tmp_t mozilla_plugin_t user_input_xevent_t xserver_tmp_t wireshark_xproperty_t user_mail_t pulseaudio_home_t 
xdg_cache_home_t user_ssh_agent_t xdg_downloads_home_t chromium_renderer_input_xevent_t cronjob_t crontab_t pan_home_t 
session_dbusd_home_t gpg_agent_t xauth_tmp_t xscreensaver_tmpfs_t iceauth_t mplayer_t chromium_xdg_cache_t lpr_tmp_t 
gpg_pinentry_tmpfs_t pan_xproperty_t ssh_xproperty_t xdm_xproperty_t java_xproperty_t sysadm_sudo_t qemu_xproperty_t 
root_xproperty_t user_xproperty_t mail_home_t xserver_t java_input_xevent_t user_screen_t wireshark_input_xevent_t } !=  ||  t1 
 ==  || );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There RPN notation however isn't the only reason why constraints are
difficult to read. The other reason is that &lt;strong&gt;seinfo&lt;/strong&gt; does not know
(anymore) about the attributes used to generate the constraints. As a
result, we get a huge list of all possible types that match a common
attribute - but we don't know which anymore.&lt;/p&gt;
&lt;p&gt;Not everyone can read the source files in which the constraints are
defined, so I hacked together a script that generates
&lt;a href="http://graphviz.org/"&gt;GraphViz&lt;/a&gt; dot file based on the &lt;strong&gt;seinfo
--constrain&lt;/strong&gt; output for a given &lt;em&gt;class&lt;/em&gt; and &lt;em&gt;permission&lt;/em&gt; and,
optionally, limiting the huge list of types to a set that the user (err,
that is me ;-) is interested in.&lt;/p&gt;
&lt;p&gt;For instance, to generate a graph of the constraints related to file
reads, limited to the &lt;code&gt;user_t&lt;/code&gt; and &lt;code&gt;staff_t&lt;/code&gt; types if huge lists would
otherwise be shown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ seshowconstraint file read &amp;quot;user_t staff_t&amp;quot; &amp;gt; constraint-file.dot
~$ dot -Tsvg -O constraint-file.dot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This generates the following graph:&lt;/p&gt;
&lt;p&gt;!SELinux constraint flow&lt;a href="http://dev.gentoo.org/~swift/blog/201405/constraint-flow.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you're interested in the (ugly) script that does this, you can find
it on my
&lt;a href="https://github.com/sjvermeu/small.coding/blob/master/se_scripts/seshowconstraint"&gt;github&lt;/a&gt;
location.&lt;/p&gt;
&lt;p&gt;There are some patches laying around to support naming constraints and
taking the name up in the policy, so that denials based on constraints
can at least give feedback to the user which constraint is holding an
access back (rather than just a denial that the user doesn't know why).
Hopefully such patches can be made available in the kernel and user
space utilities soon.&lt;/p&gt;</content><category term="SELinux"></category><category term="constrain"></category><category term="constraints"></category><category term="dot"></category><category term="graphviz"></category><category term="seinfo"></category><category term="selinux"></category></entry><entry><title>Revamped our SELinux documentation</title><link href="https://blog.siphos.be/2014/05/revamped-our-selinux-documentation/" rel="alternate"></link><published>2014-05-12T22:15:00+02:00</published><updated>2014-05-12T22:15:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-05-12:/2014/05/revamped-our-selinux-documentation/</id><summary type="html">&lt;p&gt;In the move to the &lt;a href="https://wiki.gentoo.org"&gt;Gentoo wiki&lt;/a&gt;, I have
updated and revamped most of our SELinux documentation. The end result
can be seen through the &lt;a href="https://wiki.gentoo.org/wiki/SELinux"&gt;main SELinux
page&lt;/a&gt;. Most of the content is
below this page (as subpages).&lt;/p&gt;
&lt;p&gt;We start with a new &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Quick_introduction"&gt;introduction to
SELinux&lt;/a&gt;
article which goes over &lt;/p&gt;</summary><content type="html">&lt;p&gt;In the move to the &lt;a href="https://wiki.gentoo.org"&gt;Gentoo wiki&lt;/a&gt;, I have
updated and revamped most of our SELinux documentation. The end result
can be seen through the &lt;a href="https://wiki.gentoo.org/wiki/SELinux"&gt;main SELinux
page&lt;/a&gt;. Most of the content is
below this page (as subpages).&lt;/p&gt;
&lt;p&gt;We start with a new &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Quick_introduction"&gt;introduction to
SELinux&lt;/a&gt;
article which goes over a large set of SELinux' features and concepts.
Next, we cover the various concepts within SELinux. This is mostly
SELinux features but explained more in-depth. Then we go on to the user
guides. We start of course with the &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Installation"&gt;installation of SELinux on
Gentoo&lt;/a&gt; and then
cover the remainder of administrative topics within SELinux (user
management, handling AVC denials, label management, booleans, etc.)&lt;/p&gt;
&lt;p&gt;The above is most likely sufficient for the majority of SELinux users. A
few more expert-specific documents are provided as well (some of them
still work in progress, but I didn't want to wait to get some feedback)
and there is also a section specific for (Gentoo) developers.&lt;/p&gt;
&lt;p&gt;Give it a review and tell me what you think.&lt;/p&gt;</content><category term="Gentoo"></category><category term="documentation"></category><category term="Gentoo"></category><category term="selinux"></category><category term="wiki"></category></entry><entry><title>Dropping sesandbox support</title><link href="https://blog.siphos.be/2014/05/dropping-sesandbox-support/" rel="alternate"></link><published>2014-05-09T21:03:00+02:00</published><updated>2014-05-09T21:03:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-05-09:/2014/05/dropping-sesandbox-support/</id><summary type="html">&lt;p&gt;A &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3215"&gt;vulnerability in
seunshare&lt;/a&gt;,
part of &lt;code&gt;policycoreutils&lt;/code&gt;, came to light recently (through &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=509896"&gt;bug
509896&lt;/a&gt;). The issue is
within &lt;code&gt;libcap-ng&lt;/code&gt; actually, but the specific situation in which the
vulnerability can be exploited is only available in &lt;code&gt;seunshare&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, &lt;code&gt;seunshare&lt;/code&gt; is not built by default on Gentoo. You need to define
&lt;code&gt;USE &lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;A &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3215"&gt;vulnerability in
seunshare&lt;/a&gt;,
part of &lt;code&gt;policycoreutils&lt;/code&gt;, came to light recently (through &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=509896"&gt;bug
509896&lt;/a&gt;). The issue is
within &lt;code&gt;libcap-ng&lt;/code&gt; actually, but the specific situation in which the
vulnerability can be exploited is only available in &lt;code&gt;seunshare&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, &lt;code&gt;seunshare&lt;/code&gt; is not built by default on Gentoo. You need to define
&lt;code&gt;USE="sesandbox"&lt;/code&gt;, which I implemented as an optional build because I
see no need for the &lt;code&gt;seunshare&lt;/code&gt; command and the &lt;em&gt;SELinux sandbox
(sesandbox)&lt;/em&gt; support. Upstream (Fedora/RedHat) calls it &lt;em&gt;sandbox&lt;/em&gt;, which
Gentoo translates to &lt;em&gt;sesandbox&lt;/em&gt; as it collides with the Gentoo sandbox
support otherwise. But I digress.&lt;/p&gt;
&lt;p&gt;The build of the SELinux sandbox support is optional, mostly because we
do not have a direct reason to support it. There are no Gentoo users
that I'm aware of that use it. It is used to start an application in a
chroot-like environment, based on Linux namespaces and a specific
SELinux policy called &lt;code&gt;sandbox_t&lt;/code&gt;. The idea isn't that bad, but I rather
focus on proper application confinement and full system enforcement
support (rather than specific services). The SELinux sandbox makes a bit
more sense when the system supports unconfined domains (and users are in
the &lt;code&gt;unconfined_t&lt;/code&gt; domain), but Gentoo focuses on strict policy support.&lt;/p&gt;
&lt;p&gt;Anyway, this isn't the first vulnerability in &lt;code&gt;seunshare&lt;/code&gt;. In 2011,
another privilege escalation vulnerability was found in the application
(see &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=374897"&gt;bug 374897&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;But having a vulnerability in the application (or its interaction with
&lt;code&gt;libcap-ng&lt;/code&gt;) doesn't mean an exploitable vulnerability. Most users will
not even have &lt;code&gt;seunshare&lt;/code&gt;, and those that do have it will not be able to
call it if you are running with SELinux in &lt;em&gt;strict&lt;/em&gt; or have
&lt;code&gt;USE="-unconfined"&lt;/code&gt; set for the other policies. If &lt;code&gt;USE="unconfined"&lt;/code&gt; is
set and you run &lt;em&gt;mcs&lt;/em&gt;, &lt;em&gt;targeted&lt;/em&gt; or &lt;em&gt;mls&lt;/em&gt; (which isn't default either,
the default is &lt;em&gt;strict&lt;/em&gt;) then if your users are still mapped to the
regular user domains (&lt;code&gt;user_t&lt;/code&gt;, &lt;code&gt;staff_t&lt;/code&gt; or even &lt;code&gt;sysadm_t&lt;/code&gt;) then
&lt;code&gt;seunshare&lt;/code&gt; doesn't work as the SELinux policy prevents its behavior
before the vulnerability is triggered.&lt;/p&gt;
&lt;p&gt;Assuming you &lt;em&gt;do&lt;/em&gt; have a &lt;em&gt;targeted&lt;/em&gt; policy with users mapped to
&lt;code&gt;unconfined_t&lt;/code&gt; and you have built &lt;code&gt;policycoreutils&lt;/code&gt; with
&lt;code&gt;USE="sesandbox"&lt;/code&gt; or you run in SELinux in permissive mode, then please
tell me if you can trigger the exploit. On my systems, &lt;code&gt;seunshare&lt;/code&gt; fails
with the message that it can't drop its privileges and thus exits
(instead of executing the exploit code as it suggested by the reports).&lt;/p&gt;
&lt;p&gt;Since I mentioned that most user don't use SELinux sandbox, and because
I can't even get it to work (regardless of the vulnerability), I decided
to drop support for it from the builds. That also allows me to more
quickly introduce the new userspace utilities as I don't need to
refactor the code to switch from &lt;code&gt;sandbox&lt;/code&gt; to &lt;code&gt;sesandbox&lt;/code&gt; anymore.&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;policycoreutils-2.2.5-r4&lt;/code&gt; and &lt;code&gt;policycoreutils-2.3_rc1-r1&lt;/code&gt; are now
available which do not build &lt;code&gt;seunshare&lt;/code&gt; anymore. And now I can focus on
providing the full &lt;em&gt;2.3&lt;/em&gt; userspace that has been announced today.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="hardened"></category><category term="policycoreutils"></category><category term="selinux"></category><category term="seunshare"></category><category term="vulnerability"></category></entry><entry><title>If things are weird, check for policy.29</title><link href="https://blog.siphos.be/2014/04/if-things-are-weird-check-for-policy-29/" rel="alternate"></link><published>2014-04-17T21:01:00+02:00</published><updated>2014-04-17T21:01:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-04-17:/2014/04/if-things-are-weird-check-for-policy-29/</id><summary type="html">&lt;p&gt;Today we analyzed a weird issue one of our SELinux users had with their
system. He had a denial when calling &lt;strong&gt;audit2allow&lt;/strong&gt;, informing us that
&lt;code&gt;sysadm_t&lt;/code&gt; had no rights to read the SELinux policy. This is a known
issue that has been resolved in our current SELinux policy repository
but &lt;/p&gt;</summary><content type="html">&lt;p&gt;Today we analyzed a weird issue one of our SELinux users had with their
system. He had a denial when calling &lt;strong&gt;audit2allow&lt;/strong&gt;, informing us that
&lt;code&gt;sysadm_t&lt;/code&gt; had no rights to read the SELinux policy. This is a known
issue that has been resolved in our current SELinux policy repository
but which needs to be pushed to the tree (which is my job, sorry about
that). The problem however is when he added the policy - it didn't work.&lt;/p&gt;
&lt;p&gt;Even worse, &lt;strong&gt;sesearch&lt;/strong&gt; told us that the policy has been modified
correctly - but it still doesn't work. Check your policy with
&lt;strong&gt;sestatus&lt;/strong&gt; and &lt;strong&gt;seinfo&lt;/strong&gt; and they're all saying things are working
well. And yet ... things don't. Apparently, all policy changes are
ignored.&lt;/p&gt;
&lt;p&gt;The reason? There was a &lt;code&gt;policy.29&lt;/code&gt; file in &lt;code&gt;/etc/selinux/mcs/policy&lt;/code&gt;
which was always loaded, even though the user already edited
&lt;code&gt;/etc/selinux/semanage.conf&lt;/code&gt; to have &lt;code&gt;policy-version&lt;/code&gt; set to 28.&lt;/p&gt;
&lt;p&gt;It is already a problem that we need to tell users to edit
&lt;code&gt;semanage.conf&lt;/code&gt; to a fixed version (because binary version 29 is not
supported by most Linux kernels as it has been very recently introduced)
but having &lt;strong&gt;load_policy&lt;/strong&gt; (which is called by &lt;strong&gt;semodule&lt;/strong&gt; when a
policy needs to be loaded) loading a stale &lt;code&gt;policy.29&lt;/code&gt; file is just...
disappointing.&lt;/p&gt;
&lt;p&gt;Anyway - if you see weird behavior, check both the &lt;code&gt;semanage.conf&lt;/code&gt; file
(and set &lt;code&gt;policy-version = 28&lt;/code&gt;) as well as the contents of your
&lt;code&gt;/etc/selinux/*/policy&lt;/code&gt; directory. If you see any &lt;code&gt;policy.*&lt;/code&gt; that isn't
version 28, delete them.&lt;/p&gt;</content><category term="SELinux"></category><category term="load_policy"></category><category term="policy"></category><category term="selinux"></category><category term="semanage"></category></entry><entry><title>Proof of concept for USE enabled policies</title><link href="https://blog.siphos.be/2014/03/proof-of-concept-for-use-enabled-policies/" rel="alternate"></link><published>2014-03-31T18:33:00+02:00</published><updated>2014-03-31T18:33:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-31:/2014/03/proof-of-concept-for-use-enabled-policies/</id><summary type="html">&lt;p&gt;&lt;em&gt;tl;dr:&lt;/em&gt; Some (&lt;code&gt;-9999&lt;/code&gt;) policy ebuilds now have &lt;code&gt;USE&lt;/code&gt; support for
building in (or leaving out) SELinux policy statements.&lt;/p&gt;
&lt;p&gt;One of the "problems" I have been facing since I took on the maintenance
of SELinux policies within Gentoo Hardened is the (seeming) inability to
make a "least privilege" policy that &lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;tl;dr:&lt;/em&gt; Some (&lt;code&gt;-9999&lt;/code&gt;) policy ebuilds now have &lt;code&gt;USE&lt;/code&gt; support for
building in (or leaving out) SELinux policy statements.&lt;/p&gt;
&lt;p&gt;One of the "problems" I have been facing since I took on the maintenance
of SELinux policies within Gentoo Hardened is the (seeming) inability to
make a "least privilege" policy that suits the flexibility that Gentoo
offers. As a quick recap: SELinux policies describe the "acceptable
behavior" of an application (well, domain to be exact), often known as
the "normalized behavior" in the security world. When an application
(which runs within a SELinux domain) wants to perform some action which
is not part of the policy, then this action is denied.&lt;/p&gt;
&lt;p&gt;Some applications can have very broad acceptable behavior. A web server
for instance might need to connect to a database, but that is not the
case if the web server only serves static information, or dynamic
information that doesn't need a database. To support this, SELinux has
&lt;em&gt;booleans&lt;/em&gt; through which optional policy statements can be enabled or
disabled. So far so good.&lt;/p&gt;
&lt;p&gt;Let's look at a second example: ALSA. When ALSA enabled applications
want to access the sound devices, they use IPC resources to
"collaborate" around the sound subsystem (semaphores and shared memory
to be exact). Semaphores inherit the type of the domain that first
created the semaphore (so if &lt;strong&gt;mplayer&lt;/strong&gt; creates it, then the semaphore
has the &lt;code&gt;mplayer_t&lt;/code&gt; context) whereas shared memory usually gets the
tmpfs-related type (&lt;code&gt;mplayer_tmpfs_t&lt;/code&gt;). When a second application wants
to access the sound device as well, it needs access to the semaphore and
shared memory. Assuming this second application is the browser, then
&lt;code&gt;mozilla_t&lt;/code&gt; needs access to semaphores by &lt;code&gt;mplayer_t&lt;/code&gt;. And the same for
&lt;code&gt;chromium_t&lt;/code&gt;. Or &lt;code&gt;java_t&lt;/code&gt; applications that are ALSA-enabled. And
&lt;code&gt;alsa_t&lt;/code&gt;. And all other applications that are ALSA enabled.&lt;/p&gt;
&lt;p&gt;In Gentoo, ALSA support can be made optional through &lt;code&gt;USE="alsa"&lt;/code&gt;. If a
user decides not to use ALSA, then it doesn't make sense to allow all
those domains access to each others' semaphores and shared memory. And
although SELinux booleans can help, this would mean that for each
application domain, something like the following policy would need to
be, optionally, allowed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# For the mplayer_t domain:
optional_policy(`
  tunable_policy(`use_alsa&amp;#39;,`
    mozilla_rw_semaphores(mplayer_t)
    mozilla_rw_shm(mplayer_t)
    mozilla_tmpfs_rw_files(mplayer_t)
  &amp;#39;)
&amp;#39;)

optional_policy(`
  tunable_policy(`use_alsa&amp;#39;,`
    chromium_rw_semaphores(mplayer_t)
    chromium_rw_shm(mplayer_t)
    chromium_tmpfs_rw_files(mplayer_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And this for all domains that are ALSA-enabled. Every time a new
application is added that knows ALSA, the same code needs to be added to
all policies. And this only uses a single SELinux boolean (whereas
Gentoo supports &lt;code&gt;USE="alsa"&lt;/code&gt; on per-package level), although we can
create separate booleans for each domain if we want to. Not that that
will make it more manageable.&lt;/p&gt;
&lt;p&gt;One way of dealing with this would be to use attributes. Say we have a
policy like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;attribute alsadomain;
attribute alsatmpfsfile;

allow alsadomain alsadomain:sem rw_sem_perms;
allow alsadomain alsadomain:shm rw_shm_perms;
allow alsadomain alsatmpfsfile:file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By assigning the attribute to the proper domains whenever ALSA support
is needed, we can toggle this more easily:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# In alsa.if
interface(`alsa_domain&amp;#39;,`
  gen_require(`
    attribute alsadomain;
    attribute alsatmpfsfile;
  &amp;#39;)
  typeattribute $1 alsadomain;
  typeattribute $2 alsatmpfsfile;
&amp;#39;)


# In mplayer.te
optional_policy(`
  tunable_policy(`use_alsa&amp;#39;,`
    alsa_domain(mplayer_t, mplayer_tmpfs_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That would solve the problem of needlessly adding more calls in a policy
for every ALSA application. And hey, we can probably live with either a
global boolean (&lt;code&gt;use_alsa&lt;/code&gt;) or per-domain one (&lt;code&gt;mplayer_use_alsa&lt;/code&gt;) and
toggle this according to our needs.&lt;/p&gt;
&lt;p&gt;Sadly, the above is not possible: one cannot define &lt;code&gt;typeattribute&lt;/code&gt;
assignments inside a &lt;code&gt;tunable_policy&lt;/code&gt; code: attributes are part of the
non-conditional part of a SELinux policy. The solution would be to
create build-time conditionals (rather than run-time):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ifdef(`use_alsa&amp;#39;,`
  optional_policy(`
    alsa_domain(mplayer_t, mplayer_tmpfs_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This does mean that &lt;code&gt;use_alsa&lt;/code&gt; has to be known when the policy is built.
For Gentoo, that's not that bad, as policies are part of separate
packages, like &lt;code&gt;sec-policy/selinux-mplayer&lt;/code&gt;. So what I now added was
USE-enabled build-time decisions that trigger this code. The
&lt;code&gt;selinux-mplayer&lt;/code&gt; package has &lt;code&gt;IUSE="alsa"&lt;/code&gt; which will enable, if set,
the &lt;code&gt;use_alsa&lt;/code&gt; build-time conditional.&lt;/p&gt;
&lt;p&gt;As a result, we now support a better, fine-grained privilege setting
inside the SELinux policy which is triggered through the proper USE
flags.&lt;/p&gt;
&lt;p&gt;Is this a perfect solution? No, but it is manageable and known to Gentoo
users. It isn't perfect, because it listens to the USE flag setting for
the &lt;code&gt;selinux-mplayer&lt;/code&gt; package (and of course globally set USE flags) but
doesn't "detect" that the firefox application (for which the policy is
meant) is or isn't built with &lt;code&gt;USE="alsa"&lt;/code&gt;. So users/administrators will
need to keep this in mind when using package-local USE flag definitions.&lt;/p&gt;
&lt;p&gt;Also, this will make it a bit more troublesome for myself to manage the
SELinux policy for Gentoo (as upstream will not use this setup, and as
such patches from upstream might need a few manual corrections before
they apply to our tree). However, I gladly take that up if it means my
system will have somewhat better confinement.&lt;/p&gt;</content><category term="Gentoo"></category><category term="alsa"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Decoding the hex-coded path information in AVC denials</title><link href="https://blog.siphos.be/2014/03/decoding-the-hex-coded-path-information-in-avc-denials/" rel="alternate"></link><published>2014-03-30T16:37:00+02:00</published><updated>2014-03-30T16:37:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-30:/2014/03/decoding-the-hex-coded-path-information-in-avc-denials/</id><summary type="html">&lt;p&gt;When investigating AVC denials, some denials show a path that isn't
human readable, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1396189189.734:1913): avc:  denied  { execute } for  pid=17955 comm=&amp;quot;emerge&amp;quot; path=2F7661722F666669737A69596157202864656C6574656429 dev=&amp;quot;dm-3&amp;quot; ino=1838 scontext=staff_u:sysadm_r:portage_t tcontext=staff_u:object_r:var_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To know what this &lt;/p&gt;</summary><content type="html">&lt;p&gt;When investigating AVC denials, some denials show a path that isn't
human readable, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1396189189.734:1913): avc:  denied  { execute } for  pid=17955 comm=&amp;quot;emerge&amp;quot; path=2F7661722F666669737A69596157202864656C6574656429 dev=&amp;quot;dm-3&amp;quot; ino=1838 scontext=staff_u:sysadm_r:portage_t tcontext=staff_u:object_r:var_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To know what this file is (or actually was, because such encoded paths
mean that the file ~~wasn't accessible anymore at the time that the
denial was shown~~ contains a space), you need to hex-decode the value.
For instance, with python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ python -c &amp;quot;import base64; print(base64.b16decode(\&amp;quot;2F7661722F666669737A69596157202864656C6574656429\&amp;quot;));&amp;quot;;
b&amp;#39;/var/ffisziYaW (deleted)&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above example, &lt;code&gt;/var/ffisziYaW&lt;/code&gt; was the path of the file (note
that, as it starts with ffi, it is caused by libffi which I've blogged
about before). The reason that the file was deleted at the time the
denial was generated is because what libffi does is create a file, get
the file descriptor and unlink the file (so it is deleted and only the
(open) file handle allows for accessing it) before it wants to execute
it. As a result, the execution (which is denied) triggers a denial for
the file whose path is no longer valid (as it is now appended with
"&lt;code&gt;(deleted)&lt;/code&gt;").&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit 1:&lt;/em&gt; Thanks to IooNag who pointed me to the truth that it is due to
a space in the file name, not because it was deleted. Having the file
deleted makes the patch be appended with "&lt;code&gt;(deleted)&lt;/code&gt;" which contains a
space.&lt;/p&gt;</content><category term="SELinux"></category><category term="avc"></category><category term="decode"></category><category term="path"></category><category term="selinux"></category></entry><entry><title>Querying SELinux policy for boolean information</title><link href="https://blog.siphos.be/2014/03/querying-selinux-policy-for-boolean-information/" rel="alternate"></link><published>2014-03-28T23:38:00+01:00</published><updated>2014-03-28T23:38:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-28:/2014/03/querying-selinux-policy-for-boolean-information/</id><summary type="html">&lt;p&gt;Within an SELinux policy, certain access vectors (permissions) can be
conditionally granted based on the value of a &lt;em&gt;SELinux boolean&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To find the list of SELinux booleans that are available on your system,
you can use the &lt;strong&gt;getsebool -a&lt;/strong&gt; method, or &lt;strong&gt;semanage boolean -l&lt;/strong&gt;. The
latter also displays the description &lt;/p&gt;</summary><content type="html">&lt;p&gt;Within an SELinux policy, certain access vectors (permissions) can be
conditionally granted based on the value of a &lt;em&gt;SELinux boolean&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To find the list of SELinux booleans that are available on your system,
you can use the &lt;strong&gt;getsebool -a&lt;/strong&gt; method, or &lt;strong&gt;semanage boolean -l&lt;/strong&gt;. The
latter also displays the description of the boolean:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage boolean -l | grep user_ping
user_ping                      (on   ,   on)  Control users use of ping and traceroute
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can easily query the SELinux policy to see what this boolean
triggers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# sesearch -b user_ping -A -C
Found 22 semantic av rules:
ET allow ping_t staff_t : process sigchld ; [ user_ping ]
ET allow ping_t staff_t : fd use ; [ user_ping ]
ET allow ping_t staff_t : fifo_file { ioctl read write getattr lock append open } ; [ user_ping ]
ET allow ping_t user_t : process sigchld ; [ user_ping ]
ET allow ping_t user_t : fd use ; [ user_ping ]
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, often you want to know if a particular access is allowed and,
if it is conditionally allowed, which boolean enables it. In the case of
user ping, we want to know if (and when) a user domain (&lt;code&gt;user_t&lt;/code&gt;) is
allowed to transition to the ping domain (&lt;code&gt;ping_t&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# sesearch -s user_t -t ping_t -c process -p transition -ACTS
Found 1 semantic av rules:
ET allow user_t ping_t : process transition ; [ user_ping ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So there you go - it is allowed if the &lt;code&gt;user_ping&lt;/code&gt; SELinux boolean is
enabled.&lt;/p&gt;</content><category term="SELinux"></category><category term="boolean"></category><category term="query"></category><category term="selinux"></category><category term="sesearch"></category></entry><entry><title>Talk about SELinux on GSE Linux/Security</title><link href="https://blog.siphos.be/2014/03/talk-about-selinux-on-gse-linuxsecurity/" rel="alternate"></link><published>2014-03-25T23:11:00+01:00</published><updated>2014-03-25T23:11:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-25:/2014/03/talk-about-selinux-on-gse-linuxsecurity/</id><summary type="html">&lt;p&gt;On today's &lt;a href="http://www.gsebelux.com"&gt;GSE Linux / GSE Security&lt;/a&gt; meeting
(in cooperation with
&lt;a href="http://www.imug.be/events_be/IMUG_LinuxSecurity_Event.asp"&gt;IMUG&lt;/a&gt;) I
gave a small (30 minutes) presentation about what SELinux is. The
&lt;a href="http://dev.gentoo.org/~swift/blog/201403/20140325_GSE_SELinux.pdf"&gt;slides are
online&lt;/a&gt;
and cover two aspects of SELinux: some of its design principles, and
then a set of features provided by SELinux. The talk is directed &lt;/p&gt;</summary><content type="html">&lt;p&gt;On today's &lt;a href="http://www.gsebelux.com"&gt;GSE Linux / GSE Security&lt;/a&gt; meeting
(in cooperation with
&lt;a href="http://www.imug.be/events_be/IMUG_LinuxSecurity_Event.asp"&gt;IMUG&lt;/a&gt;) I
gave a small (30 minutes) presentation about what SELinux is. The
&lt;a href="http://dev.gentoo.org/~swift/blog/201403/20140325_GSE_SELinux.pdf"&gt;slides are
online&lt;/a&gt;
and cover two aspects of SELinux: some of its design principles, and
then a set of features provided by SELinux. The talk is directed towards
less technical folks - still IT of course, but not immediately involved
in daily operations - so no commands and example/output.&lt;/p&gt;
&lt;p&gt;SELinux came across the board a few times during the entire day. In the
talks about &lt;em&gt;Open Source Security&lt;/em&gt; and &lt;em&gt;Security Guidelines for z/VM and
Linux on System z&lt;/em&gt; SELinux came (of course) up as the technology of
choice for providing in-operating system mandatory access control (on
the zEnterprise' Z/VM level - the hypervisor - this is handled through
RACF Mandatory Access Control) and the &lt;em&gt;Security Enablement on Virtual
Machines&lt;/em&gt; had SELinux in the front line for the sVirt security
protection measures (which focuses on the segregation through MLS
categories).&lt;/p&gt;
&lt;p&gt;And during the talk about &lt;em&gt;A customer story about logging and audit&lt;/em&gt;,
well, you can guess which technology is also one of the many sources of
logging. Right. SELinux ;-)&lt;/p&gt;
&lt;p&gt;Anyway, if your company is interested in such GSE events, make sure to
follow the &lt;a href="http://www.gsebelux.com"&gt;gsebelux.com&lt;/a&gt; site for updates.
It's a great way for networking as well as sharing experiences.&lt;/p&gt;</content><category term="Security"></category><category term="gse"></category><category term="mainframe"></category><category term="s390x"></category><category term="security"></category><category term="selinux"></category><category term="zenterprise"></category></entry><entry><title>Hidden symbols and dynamic linking</title><link href="https://blog.siphos.be/2014/03/hidden-symbols-and-dynamic-linking/" rel="alternate"></link><published>2014-03-24T21:14:00+01:00</published><updated>2014-03-24T21:14:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-24:/2014/03/hidden-symbols-and-dynamic-linking/</id><summary type="html">&lt;p&gt;A few weeks ago, we introduced an error in the (\~arch) &lt;code&gt;libselinux&lt;/code&gt;
ebuild which caused the following stacktrace to occur every time the
&lt;strong&gt;semanage&lt;/strong&gt; command was invoked:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~ # semanage
Traceback (most recent call last):
  File &amp;quot;/usr/lib/python-exec/python2.7/semanage&amp;quot;, line 27, in 
    import seobject
  File &amp;quot;/usr/lib64/python2.7 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;A few weeks ago, we introduced an error in the (\~arch) &lt;code&gt;libselinux&lt;/code&gt;
ebuild which caused the following stacktrace to occur every time the
&lt;strong&gt;semanage&lt;/strong&gt; command was invoked:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~ # semanage
Traceback (most recent call last):
  File &amp;quot;/usr/lib/python-exec/python2.7/semanage&amp;quot;, line 27, in 
    import seobject
  File &amp;quot;/usr/lib64/python2.7/site-packages/seobject.py&amp;quot;, line 27, in 
    import sepolicy
  File &amp;quot;/usr/lib64/python2.7/site-packages/sepolicy/__init__.py&amp;quot;, line 11, in 
    import sepolgen.interfaces as interfaces
  File &amp;quot;/usr/lib64/python2.7/site-packages/sepolgen/interfaces.py&amp;quot;, line 24, in 
    import access
  File &amp;quot;/usr/lib64/python2.7/site-packages/sepolgen/access.py&amp;quot;, line 35, in 
    from selinux import audit2why
ImportError: /usr/lib64/python2.7/site-packages/selinux/audit2why.so: undefined symbol: sepol_set_policydb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Usually this error means that a needed library (a &lt;code&gt;.so&lt;/code&gt; file) is
missing, or is not part of the &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; list of directories to
scan. And when SELinux is enabled, you might want to check the
permissions of that file as well (who knows). But that wasn't the case
here. After trying to figure things out (which includes switching Python
versions, grepping for &lt;em&gt;sepol_set_policydb&lt;/em&gt; in &lt;code&gt;libsepol.so&lt;/code&gt; and more)
I looked at the &lt;code&gt;audit2why.c&lt;/code&gt; code and see if/where
&lt;em&gt;sepol_set_policydb&lt;/em&gt; is needed, as well as at the &lt;code&gt;libsepol&lt;/code&gt; sources
to see where it is defined. And yes, the call is (of course) needed, but
the definition made me wonder if this wasn't a bug:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int hidden sepol_set_policydb(policydb_t * p)
{
        policydb = p;
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Hidden? But, that means that the function symbol is not available for
dynamic linking... So if that is the case, shouldn't &lt;code&gt;audit2why.c&lt;/code&gt; not
call it? Turns out, this was due to a fix we introduced earlier on,
where &lt;code&gt;libsepol&lt;/code&gt; got linked dynamically instead of statically (i.e.
using &lt;code&gt;libsepol.a&lt;/code&gt;). Static linking of libraries still allows for the
(hidden) symbols to be used, whereas dynamic linking doesn't.&lt;/p&gt;
&lt;p&gt;So that part of the fix got reverted (and should fix the bug we
introduced), and I learned a bit more about symbols (and the &lt;em&gt;hidden&lt;/em&gt;
statement).&lt;/p&gt;
&lt;p&gt;Bonus: if you need to check what symbols are available in a binary /
shared library, use &lt;strong&gt;nm&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ nm -D /path/to/binary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="Gentoo"></category><category term="elf"></category><category term="hidden"></category><category term="selinux"></category><category term="symbols"></category></entry><entry><title>Switching context depending on user code-wise</title><link href="https://blog.siphos.be/2014/01/switching-context-depending-on-user-code-wise/" rel="alternate"></link><published>2014-01-12T22:43:00+01:00</published><updated>2014-01-12T22:43:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-12:/2014/01/switching-context-depending-on-user-code-wise/</id><summary type="html">&lt;p&gt;I blogged about how SELinux decides what the context should be for a
particular Linux user; how it checks the default context(s) and tells
the SELinux-aware application on what the new context should be. Let's
look into the C code that does so, and how an application should behave &lt;/p&gt;</summary><content type="html">&lt;p&gt;I blogged about how SELinux decides what the context should be for a
particular Linux user; how it checks the default context(s) and tells
the SELinux-aware application on what the new context should be. Let's
look into the C code that does so, and how an application should behave
depending on the enforcing/permissive mode...&lt;/p&gt;
&lt;p&gt;I use the following, extremely simple C that fork()'s and executes
&lt;code&gt;id -Z&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;

#define DEBUG  7
#define INFO   6
#define NOTICE 5
#define WARN   4
#define ERR    3
#define CRIT   2
#define ALERT  1
#define EMERG  0

#ifndef LOGLEVEL
#define LOGLEVEL 4
#endif

/* out - Simple output */
void out(int level, char * msg, ...) {
  if (level &amp;lt;= LOGLEVEL) {
    va_list ap;
    printf(&amp;quot;%d - &amp;quot;, level);

    va_start(ap, msg);
    vprintf(msg, ap);
    va_end(ap);
  };
};
int main(int argc, char * argv[]) {
  int rc = 0;
  pid_t child;

  child = fork();
  if (child &amp;lt; 0) {
    out(WARN, &amp;quot;fork() failed\n&amp;quot;, NULL);
  };

  if (child == 0) {
    int pidrc;
    pidrc = execl(&amp;quot;/usr/bin/id&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;-Z&amp;quot;, NULL);
    if (pidrc != 0) {
      out(WARN, &amp;quot;Command failed with return code %d\n&amp;quot;, pidrc);
    };
    return(0);
  } else {
    int status;
    out(DEBUG, &amp;quot;Child is %d\n&amp;quot;, child);
    wait(&amp;amp;status);
    out(DEBUG, &amp;quot;Child exited with %d\n&amp;quot;, status);
  };
  return 0;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code is ran as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ test myusername
staff_u:staff_r:staff_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, it shows the output of the &lt;code&gt;id -Z&lt;/code&gt; command. Let's
enhance this code with some SELinux specific functions. The purpose of
the application now is to ask SELinux what the context should be that
the command should run in, and switch to that context for the &lt;code&gt;id -Z&lt;/code&gt;
invocation.&lt;/p&gt;
&lt;p&gt;We will include the necessary SELinux code with &lt;code&gt;#ifdef SELINUX&lt;/code&gt;,
allowing the application to be build without SELinux code if wanted.&lt;/p&gt;
&lt;p&gt;First, add in the proper &lt;code&gt;#include&lt;/code&gt; directives.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#ifdef SELINUX
#include &amp;lt;selinux/selinux.h&amp;gt;
#include &amp;lt;selinux/flask.h&amp;gt;
#include &amp;lt;selinux/av_permissions.h&amp;gt;
#include &amp;lt;selinux/get_context_list.h&amp;gt;
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, we create a function called &lt;em&gt;selinux_prepare_fork()&lt;/em&gt; which takes
one input variable: the Linux user name for which we are going to
transition (and thus run &lt;code&gt;id -Z&lt;/code&gt; for). This function can always be
called, even if SELinux is not built in. If that happens, we return 0
immediately.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/* selinux_prepare_fork - Initialize context switching
 *
 * Returns
 *  - 0 if everything is OK, 
 *  - +1 if the code should continue, even if SELinux wouldn&amp;#39;t allow
 *       (for instance due to permissive mode)
 *  - -1 if the code should not continue
 */
int selinux_prepare_fork(char * name) {
#ifndef SELINUX
  return 0;
#else
  // ... this is where the remainder goes
#endif
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We include this call in the application above, and take into account the
return codes passed on. As can be seen from the comment, if the
returncode is 0 (zero) then everything can go on as expected. A positive
return code means that there are some issues, but the application should
continue with its logic as SELinux is either in permissive, or the
domain in which the application runs is permissive - in either case, the
code will succeed. A returncode of -1 means that the code will most
likely fail and thus the application should log an error and exit or
break.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  pid_t child;

  rc = selinux_prepare_fork(argv[1]);
  if (rc &amp;lt; 0) {
    out(WARN, &amp;quot;The necessary context change will fail.\n&amp;quot;);
    // Continuing here would mean that the newly started process
    // runs in the wrong context (current context) which might
    // be either too privileged, or not privileged enough.
    return -1;
  } else if (rc &amp;gt; 0) {
    out(WARN, &amp;quot;The necessary context change will fail, but permissive mode is active.\n&amp;quot;);
  };

  child = fork();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now all we need to do is fill in the logic in &lt;em&gt;selinux_prepare_fork&lt;/em&gt;.
Let's start with the variable declarations (boring stuff):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#ifndef SELINUX
  return 0;
#else
  security_context_t newcon = 0;
  security_context_t curcon = 0;
  struct av_decision avd;
  int rc;
  int permissive = 0;
  int dom_permissive = 0;

  char * sename = 0;
  char * selevel = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that out of the way, let's take our first step: we want to see if
SELinux is enabled or not. Applications that are SELinux-aware should
always check if SELinux itself is enabled and, if not, just continue
with the (application) logic.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * See if SELinux is enabled.
   * If not, then we can immediately tell the code
   * that everything is OK.
   */
  rc = is_selinux_enabled();
  if (rc == 0) {
    out(DEBUG, &amp;quot;SELinux is not enabled.\n&amp;quot;);
    return 0;
  } else if (rc == -1) {
    out(WARN, &amp;quot;Could not check SELinux state (is_selinux_enabled() failed)\n&amp;quot;);
    return 1;
  };
  out(DEBUG, &amp;quot;SELinux is enabled.\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see, we use &lt;em&gt;is_selinux_enabled&lt;/em&gt; here to do just that. If
it returns 0, then it is not enabled. A returncode of 1 means it is
enabled, and -1 means something wicked happened. I recommend that
applications who are SELinux-aware enable info on these matters in
debugging output. Nothing is more annoying than having to debug
permission issues that might be SELinux-related, but are not enforced
through SELinux (and as such do not show up in any logs).&lt;/p&gt;
&lt;p&gt;Next, see if SELinux is in permissive mode and register this (as we need
this later for deciding to continue or not).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * See if SELinux is in enforcing mode
   * or permissive mode
   */
  rc = security_getenforce();
  if (rc == 0) {
    permissive = 1;
  } else if (rc == 1) {
    permissive = 0;
  } else {
    out(WARN, &amp;quot;Could not check SELinux mode (security_getenforce() failed)\n&amp;quot;);
  }
  out(DEBUG, &amp;quot;SELinux mode is %s\n&amp;quot;, permissive ? &amp;quot;permissive&amp;quot; : &amp;quot;enforcing&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;security_getenforce&lt;/em&gt; method will check the current SELinux mode
(enforcing or permissive). If SELinux is in permissive mode, then the
application logic should always go through - even if that means contexts
will go wrong and such. The end user marked the system in permissive
mode, meaning he does not want to have SELinux (or SELinux-aware
applications) to block things purely due to SELinux decisions, but log
when things are going wrong (for instance for policy development).&lt;/p&gt;
&lt;p&gt;Now, let's look up what the current context is (the context that the
process is running in). This will be used later for logging by the
SELinux-aware application in debugging mode. Often, applications that
fail run too short to find out if their context is correct or not, and
having it logged definitely helps. This step is not mandatory per se (as
you will see from the code later).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Get the current SELinux context of the process.
   * Always interesting to log this for end users
   * trying to debug a possible issue.
   */
  rc = getcon(&amp;amp;curcon);
  if (rc) {
    out(WARN, &amp;quot;Could not get current SELinux context (getcon() failed)\n&amp;quot;);
    if (permissive)
      return +1;
    else
      return -1;
  };
  out(DEBUG, &amp;quot;Currently in SELinux context \&amp;quot;%s\&amp;quot;\n&amp;quot;, (char *) curcon);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;getcon()&lt;/em&gt; method places the current context in the &lt;em&gt;curcon&lt;/em&gt;
variable. Note that from this point onwards, we should always
&lt;em&gt;freecon()&lt;/em&gt; the context before exiting the &lt;em&gt;selinux_prepare_fork()&lt;/em&gt;
method.&lt;/p&gt;
&lt;p&gt;A second important note is that, if we have a failure, we now check the
permissive state and return a positive error (SELinux is in permissive
mode, so log but continue) or negative error (SELinux is in enforcing
mode). The negative error is needed so that the code itself does not go
run the &lt;em&gt;fork()&lt;/em&gt; as it will fail anyway (or, it might succeed, but run
in the parent context which is not what the application should do).&lt;/p&gt;
&lt;p&gt;Next, we try to find out what the SELinux user is for the given Linux
account name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Get the SELinux user given the Linux user
   * name passed on to this function.
   */
  rc = getseuserbyname(name, &amp;amp;sename, &amp;amp;selevel);
  if (rc) {
    out(WARN, &amp;quot;Could not find SELinux user for Linux user \&amp;quot;%s\&amp;quot; (getseuserbyname() failed)\n&amp;quot;, name);
    freecon(curcon);
    if (permissive)
      return +1;
    else
      return -1;
  };
  out(DEBUG, &amp;quot;SELinux user for Linux user \&amp;quot;%s\&amp;quot; is \&amp;quot;%s\&amp;quot;\n&amp;quot;, name, sename);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;getseuserbyname()&lt;/em&gt; method returns the SELinux name for the given
Linux user. It also returns the MLS level (but we're not going to use
that in the remainder of the code). Again, if it fails, we check the
permissive state to see how to bail out.&lt;/p&gt;
&lt;p&gt;Now get the context to which we should transition when calling &lt;code&gt;id -Z&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Find out what the context is that this process should transition
   * to.
   */
  rc = get_default_context(sename, NULL, &amp;amp;newcon);
  if (rc) {
    out(WARN, &amp;quot;Could not deduce default context for SELinux user \&amp;quot;%s\&amp;quot; given our current context (\&amp;quot;%s\&amp;quot;)\n&amp;quot;, sename, (char *) curcon);
    freecon(curcon);
    if (permissive)
      return +1;
    else
      return -1;
  };
  out(DEBUG, &amp;quot;SELinux context to transition to is \&amp;quot;%s\&amp;quot;\n&amp;quot;, (char *) newcon);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;get_default_context()&lt;/em&gt; will do what I blogged about earlier.
It'll check what the contexts are in the user-specific context files or
the &lt;code&gt;default_contexts&lt;/code&gt; file, given the current context. You might notice
I don't pass on this context - the &lt;code&gt;NULL&lt;/code&gt; second argument means "use the
current context". This is why the &lt;em&gt;getcon()&lt;/em&gt; method earlier is not
strictly needed. But again, for logging (and thus debugging) this is
very much recommended.&lt;/p&gt;
&lt;p&gt;From this point onward, we also need to &lt;em&gt;freecon()&lt;/em&gt; the &lt;code&gt;newcon&lt;/code&gt;
variable before exiting the function.&lt;/p&gt;
&lt;p&gt;Now let's see if we are allowed to transition. We will query the SELinux
policy and see if a transition from the current context to the new
context is allowed (class &lt;code&gt;process&lt;/code&gt;, privilege &lt;code&gt;transition&lt;/code&gt;). I know, to
truly see if a transition is allowed, more steps should be checked, but
let's stick with this one permission.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Now let&amp;#39;s look if we are allowed to transition to the new context.
   * We currently only check the transition access for the process class. However,
   * transitioning is a bit more complex (execute rights on target context, 
   * entrypoint of that context for the new domain, no constraints like target
   * domain not being a valid one, MLS constraints, etc.).
   */
  rc = security_compute_av_flags(curcon, newcon, SECCLASS_PROCESS, PROCESS__TRANSITION, &amp;amp;avd);
  if (rc) {
    out(WARN, &amp;quot;Could not deduce rights for transitioning \&amp;quot;%s\&amp;quot; -&amp;gt; \&amp;quot;%s\&amp;quot; (security_compute_av_flags() failed)\n&amp;quot;, (char *) curcon, (char *) newcon);
    freecon(curcon);
    freecon(newcon);
    if (permissive)
      return +1;
    else
      return -1;
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above code, I didn't yet check the result. This is done in two
steps.&lt;/p&gt;
&lt;p&gt;In the first step, I want to know if the current context is a permissive
domain. Since a few years, SELinux supports permissive domains, so that
a single domain is permissive even though the rest of the system is in
enforcing mode. Currently, we only know if the system is in permissive
mode or not.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /* Validate the response 
   *
   * We are interested in two things:
   * - Is the transition allowed, but also
   * - Is the permissive flag set
   *
   * If the permissive flag is set, then we
   * know the current domain is permissive
   * (even if the rest of the system is in
   * enforcing mode).
   */
  if (avd.flags &amp;amp; SELINUX_AVD_FLAGS_PERMISSIVE) {
    out(DEBUG, &amp;quot;The SELINUX_AVD_FLAGS_PERMISSIVE flag is set, so domain is permissive.\n&amp;quot;);
    dom_permissive = 1;
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We check the flags provided to us by the SELinux subsystem and check if
&lt;code&gt;SELINUX_AVD_FLAGS_PERMISSIVE&lt;/code&gt; is set. If it is, then the current domain
is permissive, and we register this (in the &lt;code&gt;dom_permissive&lt;/code&gt; variable).
From this point onwards, &lt;code&gt;permissive=1&lt;/code&gt; or &lt;code&gt;dom_permissive=1&lt;/code&gt; is enough
to tell the real application logic to continue (even if things would
fail SELinux-wise) - the actions are executed by a permissive domain (or
system) and thus should continue.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  if (!(avd.allowed &amp;amp; PROCESS__TRANSITION)) {
    // The transition is denied
    if (permissive) {
      out(DEBUG, &amp;quot;Transition is not allowed by SELinux, but permissive mode is enabled. Continuing.\n&amp;quot;);
    };
    if (dom_permissive) {
      out(DEBUG, &amp;quot;Transition is not allowed by SELinux, but domain is in permissive mode. Continuing.\n&amp;quot;);
    };
    if ((permissive == 0) &amp;amp;&amp;amp; (dom_permissive == 0)) {
      out(WARN, &amp;quot;The domain transition is not allowed and we are not in permissive mode.\n&amp;quot;);
      freecon(curcon);
      freecon(newcon);
      return -1;
    };
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the second step, we checked if the requested operation (transition)
is allowed or not. If denied, we log it, but do not break out of the
function if either &lt;code&gt;permissive&lt;/code&gt; (SELinux permissive mode) or
&lt;code&gt;dom_permissive&lt;/code&gt; (domain is permissive) is set.&lt;/p&gt;
&lt;p&gt;Finally, we set the (new) context, telling the SELinux subsystem that
the next &lt;em&gt;exec()&lt;/em&gt; done by the application should also switch the domain
of the process to the new context (i.e. a domain transition):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  /*
   * Set the context for the fork (process execution).
   */
  rc = setexeccon(newcon);
  if (rc) {
    out(WARN, &amp;quot;Could not set execution context (setexeccon() failed)\n&amp;quot;);
    freecon(curcon);
    freecon(newcon);
    if ((permissive) || (dom_permissive))
      return +1;
    else
      return -1;
  };

  freecon(newcon);
  freecon(curcon);

  return 0;
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it - we free'd all our variables and can now have the application
continue (taking into account the return code of this function). As
mentioned before, a positive return code (0 or higher) means the logic
should continue; a strictly negative return code means that the
application should gracefully fail.&lt;/p&gt;</content><category term="SELinux"></category><category term="default_context"></category><category term="domain"></category><category term="libselinux"></category><category term="selinux"></category><category term="selinux-aware"></category><category term="transition"></category></entry><entry><title>How does foo_t get this privilege?</title><link href="https://blog.siphos.be/2014/01/how-does-foo_t-get-this-privilege/" rel="alternate"></link><published>2014-01-05T04:14:00+01:00</published><updated>2014-01-05T04:14:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-05:/2014/01/how-does-foo_t-get-this-privilege/</id><summary type="html">&lt;p&gt;Today a question was raised how the unprivileged user domain &lt;code&gt;user_t&lt;/code&gt;
was allowed to write to &lt;code&gt;cgroup_t&lt;/code&gt; files. There is nothing obvious about
that in the &lt;code&gt;roles/unprivuser.te&lt;/code&gt; file, so what gives?&lt;/p&gt;
&lt;p&gt;I used a simple script (which I've been using for a while already)
called &lt;strong&gt;seshowtree&lt;/strong&gt; which presents &lt;/p&gt;</summary><content type="html">&lt;p&gt;Today a question was raised how the unprivileged user domain &lt;code&gt;user_t&lt;/code&gt;
was allowed to write to &lt;code&gt;cgroup_t&lt;/code&gt; files. There is nothing obvious about
that in the &lt;code&gt;roles/unprivuser.te&lt;/code&gt; file, so what gives?&lt;/p&gt;
&lt;p&gt;I used a simple script (which I've been using for a while already)
called &lt;strong&gt;seshowtree&lt;/strong&gt; which presents the SELinux rules for a particular
domain in a tree-like structure, expanding the interfaces as it finds
them. The script is far from perfect, but does enough to help me answer
such questions. If you're interested, the script is also available on my
&lt;a href="https://github.com/sjvermeu/small.coding/blob/master/se_scripts/seshowtree"&gt;github
small.coding&lt;/a&gt;
project.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# seshowtree user roles/unprivuser.te &amp;gt; output.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the resulting output, I search for the &lt;code&gt;cgroup_t&lt;/code&gt; and work my way up,
which gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userdom_unpriv_user_template(user)
. userdom_common_user_template($1)
. . fs_rw_cgroup_files($1_t)
. . . rw_files_pattern($1, cgroup_t, cgroup_t)
. . . . allow $1 $3:file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So in this case, the user forgot to look into
&lt;code&gt;userdom_common_user_template&lt;/code&gt;, which is called by
&lt;code&gt;userdom_unpriv_user_template&lt;/code&gt; to find the path to this privilege. Of
course, that still doesn't explain why the privileges are assigned in
the first place. As the policy file itself does not contain the
necessary comments to deduce this, I had to ask the git repository for
more information:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~$ git annotate userdomain.if
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the end, it was a commit from 2010, informing me that "Common users
can read and write cgroup files (access governed by dac)". So the
privilege is by design, referring to the regular DAC permissions to
properly govern access to the files.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="selinux"></category><category term="seshowtree"></category></entry><entry><title>Oh it is cron again...</title><link href="https://blog.siphos.be/2014/01/oh-it-is-cron-again/" rel="alternate"></link><published>2014-01-03T21:05:00+01:00</published><updated>2014-01-03T21:05:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-03:/2014/01/oh-it-is-cron-again/</id><summary type="html">&lt;p&gt;Today I was pointed to the following error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test fcron[6722]: fcron[6722] 3.1.2 started
test fcron[6722]: Cannot bind socket to &amp;#39;/var/run/fcron.fifo&amp;#39;: Permission denied
test fcron[6722]:  &amp;quot;at&amp;quot; reboot jobs will only be run at computer&amp;#39;s startup.
test fcron[6722]: updating configuration from &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Today I was pointed to the following error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test fcron[6722]: fcron[6722] 3.1.2 started
test fcron[6722]: Cannot bind socket to &amp;#39;/var/run/fcron.fifo&amp;#39;: Permission denied
test fcron[6722]:  &amp;quot;at&amp;quot; reboot jobs will only be run at computer&amp;#39;s startup.
test fcron[6722]: updating configuration from /var/spool/fcron
test fcron[6722]: adding file systab Jan  3 17:51:19 test fcron[6722]: adding new file user
test fcron[6722]: NO CONTEXT for user &amp;quot;(null)&amp;quot;: Invalid argument
test fcron[6722]: ENTRYPOINT FAILED for user &amp;quot;user&amp;quot; (CONTEXT (null)) for file CONTEXT user_u:object_r:user_cron_spool_t:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;First of all, the moment I notice that it is cron, I know I'm up for a
few hours at it. Cron has been notoriously difficult to integrate with
SELinux, because it doesn't use the simpler "fork-execute" method (where
we can put in transitions). Instead, it often has to call
SELinux-specific methods to get the job done. Same was true here.&lt;/p&gt;
&lt;p&gt;Anyway, on to the issues. First of all, the &lt;em&gt;Cannot bind socket&lt;/em&gt; is a
simple SELinux policy thingie that one can easily ignore for now (I'll
patch and upstream that in a minute). The problem is the &lt;em&gt;NO CONTEXT&lt;/em&gt;
stuff.&lt;/p&gt;
&lt;p&gt;The code looks as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#ifdef SYSFCRONTAB
    if(!strcmp(cf-&amp;gt;cf_user, SYSFCRONTAB))
        user_name = &amp;quot;system_u&amp;quot;;
    else
#endif /* def SYSFCRONTAB */
        user_name = cf-&amp;gt;cf_user;
    if(flask_enabled)
    {
        if(get_default_context(user_name, NULL, &amp;amp;cf-&amp;gt;cf_user_context))
            error_e(&amp;quot;NO CONTEXT for user \&amp;quot;%s\&amp;quot;&amp;quot;, cf-&amp;gt;cf_user_context);
        retval = security_compute_av(cf-&amp;gt;cf_user_context, cf-&amp;gt;cf_file_context
                , SECCLASS_FILE, FILE__ENTRYPOINT, &amp;amp;avd);

        if(retval || ((FILE__ENTRYPOINT &amp;amp; avd.allowed) != FILE__ENTRYPOINT))
        {
            syslog(LOG_ERR, &amp;quot;ENTRYPOINT FAILED for user \&amp;quot;%s\&amp;quot; &amp;quot;
                   &amp;quot;(CONTEXT %s) for file CONTEXT %s&amp;quot;
                   , cf-&amp;gt;cf_user, cf-&amp;gt;cf_user_context, cf-&amp;gt;cf_file_context);
            goto err;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It wasn't obvious to me either, but from a quick look through the
&lt;a href="http://userspace.selinuxproject.org/trac/browser/libselinux/include/selinux/selinux.h"&gt;selinux.h&lt;/a&gt;
code I found out that &lt;em&gt;get_default_context()&lt;/em&gt; requires the SELinux
user rather than Linux user.&lt;/p&gt;
&lt;p&gt;The purpose of the &lt;em&gt;get_default_context()&lt;/em&gt; method is to return the
SELinux context in which newly started tasks, originating from the
current context (if second argument is &lt;em&gt;NULL&lt;/em&gt;) or given context (second
argument), owned by the given user (first argument) should start in. In
case of cron, the code is asking SELinux what the context should be for
the cronjob itself, considering that it has to be executed for a given
user.&lt;/p&gt;
&lt;p&gt;Now the code currently passes on the owner (Linux user) of the crontab
file. As this owner usually is not a SELinux user (only when there is a
SELinux user named after the Linux user will this succeed), the method
returns &lt;em&gt;NULL&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The right call here would be to first look up the correct SELinux user
for the given Linux user, and then call the &lt;em&gt;get_default_context()&lt;/em&gt;
method. This will return a context to transition to.&lt;/p&gt;
&lt;p&gt;Now, cron systems usually do a second check - they see if the file in
which the cronjobs are mentioned is an &lt;em&gt;entrypoint&lt;/em&gt; for the context that
it should transition to. Even though the file itself will not be
directly executed, by checking if the &lt;em&gt;entrypoint&lt;/em&gt; permission is set
cron can be reasonably certain that it should proceed. So for cron, this
is like saying "Yes, the file with context &lt;code&gt;cron_spool_t&lt;/code&gt; is allowed to
contain job definitions for cron to execute".&lt;/p&gt;
&lt;p&gt;I've sent the
&lt;a href="http://thread.gmane.org/gmane.comp.sysutils.fcron.devel/89"&gt;patch&lt;/a&gt; for
this upstream and hopefully it gets added in - if I'm correct in the
deduction, that is.&lt;/p&gt;
&lt;p&gt;So when you get issues with cron, do the following checks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Is the cron daemon running in the right domain? It should run in a
    &lt;code&gt;crond_t&lt;/code&gt; domain, otherwise it will not be able to get a proper
    default context.&lt;/li&gt;
&lt;li&gt;Assuming that cron uses the right arguments, make sure that a
    default context is set for the given SELinux user (check the
    &lt;code&gt;contexts/default_contexts&lt;/code&gt; and &lt;code&gt;contexts/users/*&lt;/code&gt; files) and that
    this context is valid&lt;/li&gt;
&lt;li&gt;Check the context of the file in which the definitions are stored
    and make sure it is mentioned as an entrypoint for the job domain&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Or, in some code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# ps -efZ | grep fcron | awk &amp;#39;{print $1}&amp;#39;
system_u:system_r:crond_t
# getseuser swift system_u:system_r:crond_t
seuser: user_u
Context 0     user_u:user_r:cronjob_t
# ls -lZ /var/spool/fcron/new.user
... user_u:object_r:user_cron_spool_t
# sesearch -s cronjob_t -t user_cron_spool_t -c file -p entrypoint -A
Found 1 semantic av rules:
  allow cronjob_t user_cron_spool_t : file entrypoint ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category><category term="cron"></category><category term="selinux"></category></entry><entry><title>Private key handling and SELinux protection</title><link href="https://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/" rel="alternate"></link><published>2014-01-02T04:00:00+01:00</published><updated>2014-01-02T04:00:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-02:/2014/01/private-key-handling-and-selinux-protection/</id><summary type="html">&lt;p&gt;In this post I'll give some insight in a &lt;em&gt;possible&lt;/em&gt; SELinux policy for a
script I wrote.&lt;/p&gt;
&lt;p&gt;The script is a certificate authority handling script, in which I can
generate a private key (and certificate assigned to it), sign the
certificate either by itself (for the root CA key) or &lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I'll give some insight in a &lt;em&gt;possible&lt;/em&gt; SELinux policy for a
script I wrote.&lt;/p&gt;
&lt;p&gt;The script is a certificate authority handling script, in which I can
generate a private key (and certificate assigned to it), sign the
certificate either by itself (for the root CA key) or by another
previously created key (for subkeys), create certificates (such as user
certificates or device certificates) and sign them, sign certificate
requests, and revoke certificates.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;export KEYLOC=&amp;quot;/var/db/ca&amp;quot;
# Create a root CA key for &amp;quot;genfic&amp;quot;
# (openssl questions and other output not shown)
certcli.sh -r genfic
# Create a subkey, signed by the &amp;quot;genfic&amp;quot; key, for users
certcli.sh -p genfic -c genfic-user
# Create a user certificate
certcli.sh -p genfic-user -R /var/db/ca/myUserId
# Sign a certificate
certcli.sh -p genfic-user -s /var/db/ca/requests/someUser.csr
# Revoke a certificate
certcli.sh -p genfic-user -x myuser@genfic.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From a security point of view, I currently focus on two types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ca_private_key_t&lt;/code&gt; is for the private key and should not be
    accessible by anyone, anywhere, anytime, except through the
    management script itself (which will run as &lt;code&gt;ca_cli_t&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ca_misc_t&lt;/code&gt; is for the other related files, such as certificates,
    revocation lists, serial information, etc. If this would be "for
    real" I'd probably make a bit more types for this depending on the
    accesses, but for this post this suffices.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to provide the necessary support policy-wise, the following
types also are declared:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ca_cli_exec_t&lt;/code&gt; as the entrypoint for the script&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ca_misc_tmp_t&lt;/code&gt; as the temporary file type used by OpenSSL when
    handling certificates (it is not used for the private key afaics,
    but it should still be sufficiently - and perhaps even equally
    well - protected like the private key&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So let's start with this.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(ca, 1.0.0)

# CA management script and domain
type ca_cli_t;
type ca_cli_exec_t;
domain_base_type(ca_cli_t)
fs_associate(ca_cli_exec_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Above, I declared the two types &lt;code&gt;ca_cli_t&lt;/code&gt; and &lt;code&gt;ca_cli_exec_t&lt;/code&gt;. Then,
two non-standard approaches were followed.&lt;/p&gt;
&lt;p&gt;Normally, application domains are granted through &lt;code&gt;application_type()&lt;/code&gt;,
&lt;code&gt;application_domain()&lt;/code&gt; or even &lt;code&gt;userdom_user_application_domain()&lt;/code&gt;.
Which interface you use depends on the privileges you want to grant on
the domain, but also which existing privileges should also be applicable
to the domain. Make sure you review the interfaces. For instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seshowif application_domain
interface(`application_type&amp;#39;,`
        gen_require(`
                attribute application_domain_type;
        &amp;#39;)

        typeattribute $1 application_domain_type;

        # start with basic domain
        domain_type($1)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This means that the assigned domain (&lt;code&gt;ca_cli_t&lt;/code&gt; in our example) would be
assigned the &lt;code&gt;application_domain_type&lt;/code&gt; attribute, as well as the
&lt;code&gt;domain&lt;/code&gt; attribute and other privileges. If we really want to prevent
any access to the &lt;code&gt;ca_cli_t&lt;/code&gt; domain for handling the certificates, we
need to make sure that the lowest possible privileges are assigned.&lt;/p&gt;
&lt;p&gt;The same is true for the file type &lt;code&gt;ca_cli_exec_t&lt;/code&gt;. Making it through
&lt;code&gt;files_type()&lt;/code&gt; interface would assign the &lt;code&gt;file_type&lt;/code&gt; attribute to it,
and other domains might have access to &lt;code&gt;file_type&lt;/code&gt;. So all I do here is
to allow the type &lt;code&gt;ca_cli_exec_t&lt;/code&gt; to be associated on a file system.&lt;/p&gt;
&lt;p&gt;Similarly, I define the remainder of file types:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type ca_private_key_t;
fs_associate(ca_private_key_t)

type ca_misc_tmp_t;
fs_associate(ca_misc_tmp_t)
fs_associate_tmpfs(ca_misc_tmp_t)

type ca_misc_t;
fs_associate(ca_misc_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, grant the CA handling script (which will run as &lt;code&gt;ca_cli_t&lt;/code&gt;) the
proper access to these types.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow ca_cli_t ca_misc_t:dir create_dir_perms;
manage_files_pattern(ca_cli_t, ca_misc_t, ca_misc_t)

allow ca_cli_t ca_private_key_t:dir create_dir_perms;
manage_files_pattern(ca_cli_t, ca_private_key_t, ca_private_key_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This of course heavily depends on the script itself. Mine creates a
directory "private", so needs the proper rights on the
&lt;code&gt;ca_private_key_t&lt;/code&gt; type for directories as well. The "private" directory
is created in a generic directory (which is labeled as &lt;code&gt;ca_misc_t&lt;/code&gt;) so I
can also create a file transition. This means that the SELinux policy
will automatically assign the &lt;code&gt;ca_private_key_t&lt;/code&gt; type to a directory,
created in a directory with label &lt;code&gt;ca_misc_t&lt;/code&gt;, if created by the
&lt;code&gt;ca_cli_t&lt;/code&gt; domain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;filetrans_pattern(ca_cli_t, ca_misc_t, ca_private_key_t, dir, &amp;quot;private&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, &lt;code&gt;ca_cli_t&lt;/code&gt; is a domain used for a shell script, which in my case
also requires the following permissions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Handling pipes between commands
allow ca_cli_t self:fifo_file rw_fifo_file_perms;
# Shell script...
corecmd_exec_shell(ca_cli_t)
# ...which invokes regular binaries
corecmd_exec_bin(ca_cli_t)
# Allow output on the screen
getty_use_fds(ca_cli_t)
userdom_use_user_terminals(ca_cli_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now I still need to mark &lt;code&gt;ca_cli_exec_t&lt;/code&gt; as an entrypoint for
&lt;code&gt;ca_cli_t&lt;/code&gt;, meaning that the &lt;code&gt;ca_cli_t&lt;/code&gt; domain can only be accessed
(transitioned to) through the execution of a file with label
&lt;code&gt;ca_cli_exec_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow ca_cli_t ca_cli_exec_t:file entrypoint;
allow ca_cli_t ca_cli_exec_t:file { mmap_file_perms ioctl lock };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Normally, the above is granted through the invocation of the
&lt;code&gt;application_domain(ca_cli_t, ca_cli_exec_t)&lt;/code&gt; but as mentioned before,
this would also assign attributes that I explicitly want to prevent in
this example.&lt;/p&gt;
&lt;p&gt;Next, the &lt;code&gt;openssl&lt;/code&gt; application, which the script uses extensively, also
requires additional permissions. As the &lt;code&gt;openssl&lt;/code&gt; command just runs in
the &lt;code&gt;ca_cli_t&lt;/code&gt; domain, I extend the privileges for this domain more:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Read access on /proc files
kernel_read_system_state(ca_cli_t)
# Access to random devices
dev_read_rand(ca_cli_t)
dev_read_urand(ca_cli_t)
# Regular files
files_read_etc_files(ca_cli_t)
miscfiles_read_localization(ca_cli_t)
# /tmp access
fs_getattr_tmpfs(ca_cli_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Also, the following file transition is created: when OpenSSL creates a
temporary file in &lt;code&gt;/tmp&lt;/code&gt;, this file should immediately be assigned the
&lt;code&gt;ca_misc_tmp_t&lt;/code&gt; type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# File transition in /tmp to ca_misc_tmp_t
files_tmp_filetrans(ca_cli_t, ca_misc_tmp_t, file)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this in place, the application works just fine - all I need to do
is have an initial location marked as &lt;code&gt;ca_misc_t&lt;/code&gt;. For now, none of the
users have the rights to do so, so I create three additional interfaces
to be used against other user domains.&lt;/p&gt;
&lt;p&gt;The first one is to allow user domains to use the CA script. This is
handled by the &lt;code&gt;ca_role()&lt;/code&gt; interface. In order to support such an
interface, let's first create the &lt;code&gt;ca_roles&lt;/code&gt; role attribute in the &lt;code&gt;.te&lt;/code&gt;
file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;attribute_role ca_roles;
role ca_roles types ca_cli_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now I can define the &lt;code&gt;ca_role()&lt;/code&gt; interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`ca_role&amp;#39;,`
  gen_require(`
    attribute_role ca_roles;
    type ca_cli_t, ca_cli_exec_t;
    type ca_misc_t;
  &amp;#39;)

  # Allow the user role (like sysadm_r) the types granted to ca_roles
  roleattribute $1 ca_roles;

  # Read the non-private key files and directories
  allow $2 ca_misc_t:dir list_dir_perms;
  allow $2 ca_misc_t:file read_file_perms;

  # Allow to transition to ca_cli_t by executing a ca_cli_exec_t file
  domtrans_pattern($2, ca_cli_exec_t, ca_cli_t)

  # Look at the process info
  ps_process_pattern($2, ca_cli_t)

  # Output (and redirect) handling
  allow ca_cli_t $2:fd use;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This role allows to run the command, but we still don't have the rights
to create a &lt;code&gt;ca_misc_t&lt;/code&gt; directory. So another interface is created,
which is granted to &lt;em&gt;regular&lt;/em&gt; system administrators (as the &lt;code&gt;ca_role()&lt;/code&gt;
might be granted to non-admins as well, who can invoke the script
through &lt;code&gt;sudo&lt;/code&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`ca_sysadmin&amp;#39;,`
  gen_require(`
    type ca_misc_t;
    type ca_private_key_t;
  &amp;#39;)

  # Allow the user relabel rights on ca_misc_t
  allow $1 ca_misc_t:dir relabel_dir_perms;
  allow $1 ca_misc_t:file relabel_file_perms;

  # Allow the user to label /to/ ca_private_key_t (but not vice versa)
  allow $1 ca_private_key_t:dir relabelto_dir_perms;
  allow $1 ca_private_key_t:file relabelto_file_perms;

  # Look at regular file/dir info
  allow $1 ca_misc_t:dir list_dir_perms;
  allow $1 ca_misc_t:file read_file_perms;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;ca_sysadmin()&lt;/code&gt; interface can also be assigned to the &lt;code&gt;setfiles_t&lt;/code&gt;
command so that relabel operations (and file system relabeling) works
correctly.&lt;/p&gt;
&lt;p&gt;Finally, a real administrative interface is created that also has
relabel &lt;em&gt;from&lt;/em&gt; rights (so any domain granted this interface will be able
- if Linux allows it and the type the operation goes to/from is allowed
- to change the type of private keys to a regular file). This one should
&lt;em&gt;only&lt;/em&gt; be assigned to a rescue user (if any). Also, this interface is
allowed to label CA management scripts.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`ca_admin&amp;#39;,`
  gen_require(`
    type ca_misc_t, ca_private_key_t;
    type ca_cli_exec_t;
  &amp;#39;)

  allow $1 { ca_misc_t ca_private_key_t }:dir relabel_dir_perms;
  allow $1 { ca_misc_t ca_private_key_t }:file relabel_file_perms;

  allow $1 ca_cli_exec_t:file relabel_file_perms;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So regular system administrators would be assigned the &lt;code&gt;ca_sysadmin()&lt;/code&gt;
interface as well as the &lt;code&gt;setfiles_t&lt;/code&gt; domain; CA handling roles would be
granted the &lt;code&gt;ca_role()&lt;/code&gt; interface. The &lt;code&gt;ca_admin()&lt;/code&gt; interface would only
be granted on the rescue (or super-admin).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Regular system administrators
ca_sysadmin(sysadm_t)
ca_sysadmin(setfiles_t)
# Certificate administrator
ca_role(certadmin_r, certadmin_t)
# Security administrator
ca_admin(secadm_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="SELinux"></category><category term="ca"></category><category term="certcli"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Limiting file access with SELinux alone?</title><link href="https://blog.siphos.be/2013/12/limiting-file-access-with-selinux-alone/" rel="alternate"></link><published>2013-12-31T21:18:00+01:00</published><updated>2013-12-31T21:18:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-12-31:/2013/12/limiting-file-access-with-selinux-alone/</id><summary type="html">&lt;p&gt;While writing a small script to handle simple certificate authority
activities using OpenSSL, I considered how to properly protect the files
that OpenSSL uses for these activities. As you are probably aware, a
system that hosts the necessary files for CA activities (like signing
certificate requests) should be very secure &lt;/p&gt;</summary><content type="html">&lt;p&gt;While writing a small script to handle simple certificate authority
activities using OpenSSL, I considered how to properly protect the files
that OpenSSL uses for these activities. As you are probably aware, a
system that hosts the necessary files for CA activities (like signing
certificate requests) should be very secure, and the private key used to
sign (and the private subkeys) should be very well protected.&lt;/p&gt;
&lt;p&gt;Without the help of an &lt;a href="https://en.wikipedia.org/wiki/Hardware_security_module"&gt;Hardware Security Module
(HSM)&lt;/a&gt; these
private keys are just plain text files on the file system. Access to
this file system should therefor be very well audited and protected.&lt;/p&gt;
&lt;p&gt;It of course starts with proper Discretionary Access Control (DAC)
protections on Linux. The private key should only be accessible by the
(technical) user used to operate the CA activities. Next, access to this
user should also be properly protected - if the CA activities are not
done through the root account, make sure that all users who can get root
access on the system and to the (technical) user used to perform the CA
activities are trusted.&lt;/p&gt;
&lt;p&gt;Sometimes however this isn't sufficient, or you want to protect it even
more. With SELinux, we can implement a Mandatory Access Control (MAC)
policy to further restrict access to the private key. The idea is to
only allow the application (in my case the script) that performs the CA
activities access to the private key, and nothing more. Even users who
can get root access, but do not have the privileges SELinux-wise to
execute the CA management script (with the proper domain transition)
should not have any access to the private key.&lt;/p&gt;
&lt;p&gt;I'll discuss a sample policy for that later, but for now I want to focus
on what that would mean - not allowing other users access.&lt;/p&gt;
&lt;p&gt;When users log on on a SELinux-enabled system, they (well, the process
that starts the user session) get assigned a security context. This
security context defines what the user is allowed to do on the system.
And although it is "easy" to disallow a domain read access to a
particular file, we must consider all other activities that the user can
perform.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;First risk: direct file access&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Assume that a user is logged on with the &lt;code&gt;unconfined_t&lt;/code&gt; domain (an
entire context is more than just the domain, but let's stick to this for
now). The &lt;code&gt;unconfined_t&lt;/code&gt; domain is an extremely powerful domain -
basically, SELinux will not prevent much. That doesn't mean that SELinux
is disabled, but rather that the &lt;code&gt;unconfined_t&lt;/code&gt; domain is granted many
privileges. So if a user is in the &lt;code&gt;unconfined_t&lt;/code&gt; domain &lt;em&gt;and&lt;/em&gt; is not
prevented by the standard Linux access controls (for instance because he
is root), he can do basically everything.&lt;/p&gt;
&lt;p&gt;SELinux-wise, we can still create a new type that &lt;code&gt;unconfined_t&lt;/code&gt; has no
immediate access to. By creating a new type (say &lt;code&gt;ca_private_key_t&lt;/code&gt;) and
not assign it any attributes that the &lt;code&gt;unconfined_t&lt;/code&gt; domain has
privileges towards, the user would still not be able to access the file
directly. The same is true for the &lt;code&gt;sysadm_t&lt;/code&gt; domain (a still
privileged, yet slightly more restricted user domain designed for system
administrators). However, such users could still access the file
indirectly.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Second risk: indirect access through new SELinux policies&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;An important privilege that these users have is that they can load a new
SELinux policy, or disable SELinux (actually switch it to permissive
mode) if the Linux kernel has this enabled. By allowing users to load a
new policy, they can basically create a SELinux policy module that
grants them the necessary accesses towards the file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow sysadm_t ca_misc_file_t:file manage_file_perms;
allow sysadm_t ca_misc_file_t:dir manage_dir_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So in order to prevent this, we have to make sure that these users can
either not manipulate the SELinux policy - or make sure users on the
system do not get access to these domains to begin with. Preventing
loading new policies can be handled by the Linux kernel itself
(&lt;code&gt;CONFIG_SECURITY_SELINUX_DEVELOP&lt;/code&gt; should not be set then) and through
SELinux booleans (&lt;code&gt;secure_mode_policyload&lt;/code&gt; should be set to &lt;code&gt;on&lt;/code&gt; and
toggling the boolean off again should be prohibited). Still, it makes
more sense to restrict people with access to these roles - something
I'll definitely come back to at a later point.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Third risk: indirect access through attributes&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Another privilege that needs to be watched for is the ability to change
the context of a file. If the &lt;code&gt;ca_private_key_t&lt;/code&gt; type would not be
declared properly, then the type might be assigned an attribute that
domains have privileges against. Consider the &lt;code&gt;file_type&lt;/code&gt; attribute,
granted to file types (at least the name makes sense ;-)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seinfo -tca_private_key_t -x
  ca_private_key_t
    file_type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The moment a domain has been granted read access to the &lt;code&gt;file_type&lt;/code&gt;
files, then it has read access to the &lt;code&gt;ca_private_key_t&lt;/code&gt; type. In other
words, while designing the policy, make sure that all granted
permissions are accounted for.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fourth risk: "raw" file system (or memory) access&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So if SELinux itself would not allow access to the file(s) anymore, are
we done yet? Of course not. In the end, the keys are stored on the file
system, which is located on partitions or disks, accessible by
privileged users. Someone with direct read access to the block devices
can still obtain the file directly, so even that should be properly
governed.&lt;/p&gt;
&lt;p&gt;This even extends towards memory access, because the private key might
be cached in buffers (by the kernel) or even mapped in memory (even for
a short while) and made accessible through direct memory access.&lt;/p&gt;
&lt;p&gt;Such accesses might not be available to many users, but don't forget
that on the system other applications are running as well. Some daemons
might have the necessary privileges to access file systems directly, or
the memory. Some users might have the rights to execute commands that
have direct file system access (or memory). Making sure that &lt;em&gt;all&lt;/em&gt;
domains that have these accesses are properly audited (including the
access to those domains) will already be quite a challenge.&lt;/p&gt;
&lt;p&gt;For a system that acts as a certificate handling system, it makes sense
to limit exposure to a bare minimum as that makes the above auditing a
bit less daunting.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
Ok ok, let's assume the security administrator has thought of all those
things and SELinux policy-wise properly prevents any access. That's
enough, right?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fifth risk: authentication and authorization access&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Of course not. Some processes or users might have access to the
authentication files on the system (and I'm not only talking about the
&lt;code&gt;/etc/shadow&lt;/code&gt; and &lt;code&gt;/etc/passwd&lt;/code&gt; files, but also the &lt;code&gt;/etc/pam.d/*&lt;/code&gt;
files, or the libraries used by the PAM modules in &lt;code&gt;/lib/security&lt;/code&gt;, or
modify rights on binaries likely executed by administrators who do have
rights we want - there might always be a "recovery user" enabled just in
case things really go wrong, but such "recovery users" imply that rights
are still granted somewhere.&lt;/p&gt;
&lt;p&gt;When modify access is granted to any of the authentication or
authorization services, then users can grant them privileges you don't
want to give them. So not only should access to &lt;code&gt;ca_private_key_t&lt;/code&gt;,
&lt;code&gt;memory_device_t&lt;/code&gt;, &lt;code&gt;device_node&lt;/code&gt; and &lt;code&gt;fixed_disk_device_t&lt;/code&gt; be properly
governed - also &lt;code&gt;etc_t&lt;/code&gt; (as this is the default for PAM files - this
really should be worked on) and &lt;code&gt;lib_t&lt;/code&gt; are important types, and these
are very, very open (many domains have write access to those by
default).&lt;/p&gt;
&lt;p&gt;Fine. Let's "hypothetically" consider that the security engineer has
thought about all SELinux accesses and made a perfect policy. Happy now?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Sixth risk: system boot privileges&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Actually no... first of all, some users might be able to reboot the
system with updated boot parameters, or even with a different kernel.
With this at hand, they can disable SELinux and still access the file.
So make sure that rebooting the system still happens securely (you can
use secure boot, signed kernels, ... or at least focus on boot loader
password protection and console access). The
&lt;a href="https://wiki.gentoo.org/wiki/Project:Integrity"&gt;Integrity&lt;/a&gt; subproject
of the &lt;a href="https://wiki.gentoo.org/wiki/Project:Hardened"&gt;Gentoo Hardened&lt;/a&gt;
project will focus on these matters more (just waiting for an
EFI-enabled system to properly start documenting things). In the mean
time, make sure that the Linux system itself is properly secured.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Seventh risk: direct system access&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Yet having a secured boot also doesn't protect us completely. If there
is access to the system physically, users can still mount the disk on
their system and access the files. So one might want to consider
encrypting the partition on which the keys are stored. But the
encryption key for the partition should still be available somewhere,
because regular administration might need to reboot the system.&lt;/p&gt;
&lt;p&gt;A reasonably secure system would keep the encryption key in a HSM device
(which we don't have - see beginning of this post) or only have it
decrypted in a secure environment (like a TPM chip on more modern
systems). Handling TPM and securing keys is definitely also something to
focus on further in the Integrity subproject.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Eighth risk: backups&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;And if you take backups (which we of course all do) then those backups
should be properly protected as well. We might want to create encrypted
backups (meaning that the CA script should allow for encrypting and
decrypting the private key) and &lt;em&gt;not store the encryption key with the
backup&lt;/em&gt;. And before asking me why I've emphasized this - I've seen it
before, and I'll probably see it again in the future. Don't laugh.&lt;/p&gt;
&lt;p&gt;Almost starts sounding like a nightmare, right? There might even be more
risks that I haven't covered here (and I haven't even discussed
potential vulnerabilities in the CA management script itself, or even in
OpenSSL or other tools like the &lt;a href="http://it.slashdot.org/story/13/12/18/2122226/scientists-extract-rsa-key-from-gnupg-using-sound-of-cpu"&gt;let's hear the encryption
key&lt;/a&gt;
attack). Welcome to the world of security ;-)&lt;/p&gt;
&lt;p&gt;In any case, in the next post I'll focus on the SELinux policy I wrote
up for the simple script I created. But all the above is just to show
that SELinux is not the answer - it is merely a part in an entire
security architecture. A flexible, powerful part... but still a part.&lt;/p&gt;</content><category term="SELinux"></category><category term="access"></category><category term="acl"></category><category term="file access"></category><category term="Gentoo"></category><category term="selinux"></category></entry><entry><title>Gentoo SELinux policy release script</title><link href="https://blog.siphos.be/2013/12/gentoo-selinux-policy-release-script/" rel="alternate"></link><published>2013-12-11T18:37:00+01:00</published><updated>2013-12-11T18:37:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-12-11:/2013/12/gentoo-selinux-policy-release-script/</id><summary type="html">&lt;p&gt;A few months ago, I wrote a small script that aids in the creation of
new SELinux policy packages. The script is on the
&lt;a href="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-refpolicy.git;a=summary"&gt;repository&lt;/a&gt;
itself, in the &lt;code&gt;gentoo/&lt;/code&gt; subdirectory, and is called
&lt;code&gt;release-prepare.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reason for the script is that there are a number of steps to
perform &lt;/p&gt;</summary><content type="html">&lt;p&gt;A few months ago, I wrote a small script that aids in the creation of
new SELinux policy packages. The script is on the
&lt;a href="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-refpolicy.git;a=summary"&gt;repository&lt;/a&gt;
itself, in the &lt;code&gt;gentoo/&lt;/code&gt; subdirectory, and is called
&lt;code&gt;release-prepare.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reason for the script is that there are a number of steps to
perform, one of which (tagging the release) I forgot to do too often. So
today I made a new release of the policy packages (2.20130424-r4) with
the script, and decided to blog about it as other developers in the
hardened team might one day be asked to make a release when I'm not
available.&lt;/p&gt;
&lt;p&gt;When the script is called, it spits out the usual help information.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sh release-prepare.sh -h
Usage: release-prepare.sh

Example: release-prepare.sh 2.20130424-r2 2.20130424-r3

The script will copy the ebuilds of the  towards the
 and update the string occurrences of that version
(mostly for the BASEPOL variable).

The following environment variables must be declared correctly for the script
to function properly:
  - GENTOOX86 should point to the gentoo-x86 checkout
    E.g. export GENTOOX86=&amp;quot;/home/user/dev/gentoo-x86&amp;quot;
  - HARDENEDREFPOL should point to the hardened-refpolicy.git checkout
    E.g. export HARDENEDREFPOL=&amp;quot;/home/user/dev/hardened-refpolicy&amp;quot;
  - REFPOLRELEASE should point to the current latest /release/ of the reference
    policy (so NOT to a checkout), extracted somewhere on the file system.
    E.g. export REFPOLRELEASE=&amp;quot;/home/user/local/refpolicy-20130424&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So first, we need to export three environment variables needed by the
script:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GENTOOX86&lt;/code&gt; points to the CVS checkout of the Portage tree. It is
    used to create new ebuilds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HARDENEDREFPOL&lt;/code&gt; is the git checkout of the policy repository. This
    one is used to read the changes from to generate a patch.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REFPOLRELEASE&lt;/code&gt; is an extracted &lt;code&gt;refpolicy-20130424.tar.gz&lt;/code&gt; (the
    upstream release of the reference policy). This extracted location
    is needed to generate the patch (the difference between our
    repository and the upstream release).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After setting the variables, the script does its magic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sh release-prepare.sh 2.20130424-r3 2.20130424-r4
Creating patch 0001-full-patch-against-stable-release.patch... done
Creating patch bundle for 2.20130424-r4... done
Copying patch bundle into /usr/portage/distfiles and dev.g.o... done
Removing old patchbundle references in Manifest (in case of rebuild)... done
Creating new ebuilds based on old version... done
Marking ebuilds as ~arch... done
Creating tag 2.20130424-r4 in our repository... done
The release has now been prepared.

Please go do the following to finish up:
- In /home/swift/dev/gentoo-x86/sec-policy go &amp;quot;cvs add&amp;quot; all the new ebuilds
- In /home/swift/dev/gentoo-x86/sec-policy run &amp;quot;repoman manifest&amp;quot; and &amp;quot;repoman full&amp;quot;

Then, before finally committing - do a run yourself, ensuring that the right
version is deployed of course:
- &amp;quot;emerge -1 sec-policy/selinux-aide
sec-policy/selinux-alsa
...
Only then do a &amp;#39;repoman commit -m &amp;#39;Release of 2.20130424-r4&amp;#39;&amp;#39;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The script performs the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It creates the patch with the difference between the main refpolicy
    release and our repository. Our repository closely follows the
    upstream release, but still contains quite a few changes that have
    not been upstreamed yet (due to history loss of the changes, or the
    changes are very gentoo-specific, or the changes still need to
    be improved). In the past, we maintained all the patches separately,
    but this meant that the deployment of the policy ebuilds took too
    long (around 100 patches being applied takes a while, and took more
    than 80% of the total deployment time on a regular server system).
    By using a single patch file, the deployment time is
    reduced drastically.&lt;/li&gt;
&lt;li&gt;It then compresses this patch file and stores it in
    &lt;code&gt;/usr/portage/distfiles&lt;/code&gt; (so that later &lt;code&gt;repoman manifest&lt;/code&gt; can take
    the file into account) as well as on my dev.gentoo.org location
    (where it is referenced). If other developers create a release, they
    will need to change this location (and the pointer in the ebuilds).&lt;/li&gt;
&lt;li&gt;Previous file references in the &lt;code&gt;Manifest&lt;/code&gt; files are removed, so
    that &lt;code&gt;repoman&lt;/code&gt; does not think the digest can be skipped.&lt;/li&gt;
&lt;li&gt;New ebuilds are created, copied from the previous version. In these
    ebuilds, the &lt;code&gt;KEYWORDS&lt;/code&gt; variable is updated to only contain
    &lt;code&gt;~arch&lt;/code&gt; keywords.&lt;/li&gt;
&lt;li&gt;A release tag is created in the git repository.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then the script tells the user to add the new files to the repository,
run &lt;code&gt;repoman manifest&lt;/code&gt; and &lt;code&gt;repoman full&lt;/code&gt; to verify the quality of the
ebuilds and generate the necessary digests. Then, and also after
testing, the created ebuilds can be committed to the repository.&lt;/p&gt;
&lt;p&gt;The last few steps have explicitly not been automated so the developer
has the chance to update the ebuilds (in case more than just the policy
contents has changed between releases) or do dry runs without affecting
the &lt;code&gt;gentoo-x86&lt;/code&gt; repository.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="hardened"></category><category term="policy"></category><category term="release"></category><category term="selinux"></category></entry><entry><title>The mix of libffi with other changes</title><link href="https://blog.siphos.be/2013/11/the-mix-of-libffi-with-other-changes/" rel="alternate"></link><published>2013-11-03T10:27:00+01:00</published><updated>2013-11-03T10:27:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-11-03:/2013/11/the-mix-of-libffi-with-other-changes/</id><summary type="html">&lt;p&gt;I &lt;a href="http://blog.siphos.be/2013/04/securely-handling-libffi/"&gt;once again&lt;/a&gt;
came across libffi. Not only does the libffi approach fight with SELinux
alone, it also triggers the TPE (Trusted Path Execution) protections in
grSecurity. And when I tried to reinstall Portage, Portage seemed to
create some sort of runtime environment in a temporary directory as
well, and &lt;/p&gt;</summary><content type="html">&lt;p&gt;I &lt;a href="http://blog.siphos.be/2013/04/securely-handling-libffi/"&gt;once again&lt;/a&gt;
came across libffi. Not only does the libffi approach fight with SELinux
alone, it also triggers the TPE (Trusted Path Execution) protections in
grSecurity. And when I tried to reinstall Portage, Portage seemed to
create some sort of runtime environment in a temporary directory as
well, and SELinux wasn't up to allowing that either.&lt;/p&gt;
&lt;p&gt;Let's first talk about a quick workaround for the libffi-with-TPE issue.
Because libffi wants to create executable files in a world-writable
directory and then execute that file (try finding the potential security
issue here) TPE is prohibiting the execution. The easiest workaround is
to add the &lt;code&gt;portage&lt;/code&gt; Linux user, as well as the Linux accounts that you
use to run emerge with (even just things like &lt;strong&gt;emerge --info&lt;/strong&gt;) in the
&lt;code&gt;wheel&lt;/code&gt; group. This group is exempt from TPE protections (unless you
configured a different group in your kernel for this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# zgrep CONFIG_GRKERNSEC_TPE_TRUSTED_GID /proc/config.gz
CONFIG_GRKERNSEC_TPE_TRUSTED_GID=10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next we also need to allow the &lt;code&gt;portage_t&lt;/code&gt; domain to execute files
labeled with &lt;code&gt;portage_tmpfs_t&lt;/code&gt;. You can do this by creating your own
SELinux policy module with the following content (or use selocal):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;can_exec(portage_t, portage_tmpfs_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This works around the libffi issue for now. A better solution still has
to be implemented (as discussed in the previous post).&lt;/p&gt;
&lt;p&gt;With regards to the portage installation failing, you'll notice this
quickly when you get an error like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# emerge -1 portage
Calculating dependencies  ... done!
Traceback (most recent call last):
  File &amp;quot;/usr/bin/emerge&amp;quot;, line 50, in &amp;lt;module&amp;gt;
    retval = emerge_main()
  File &amp;quot;/usr/lib64/portage/pym/_emerge/main.py&amp;quot;, line 1031, in emerge_main
    return run_action(emerge_config)
  File &amp;quot;/usr/lib64/portage/pym/_emerge/actions.py&amp;quot;, line 4062, in run_action
    emerge_config.args, spinner)
  File &amp;quot;/usr/lib64/portage/pym/_emerge/actions.py&amp;quot;, line 453, in action_build
    retval = mergetask.merge()
  File &amp;quot;/usr/lib64/portage/pym/_emerge/Scheduler.py&amp;quot;, line 946, in merge
    rval = self._handle_self_update()
  File &amp;quot;/usr/lib64/portage/pym/_emerge/Scheduler.py&amp;quot;, line 316, in _handle_self_update
    _prepare_self_update(self.settings)
  File &amp;quot;/usr/lib64/portage/pym/portage/package/ebuild/doebuild.py&amp;quot;, line 2326, in _prepare_self_update
    shutil.copytree(orig_bin_path, portage._bin_path, symlinks=True)
  File &amp;quot;/usr/lib64/portage/pym/portage/__init__.py&amp;quot;, line 259, in __call__
    rval = self._func(*wrapped_args, **wrapped_kwargs)
  File &amp;quot;/usr/lib64/python3.3/shutil.py&amp;quot;, line 343, in copytree
    raise Error(errors)
shutil.Error: [(b&amp;#39;/usr/lib64/portage/bin/ebuild-helpers/prepalldocs&amp;#39;, 
b&amp;#39;/var/tmp/portage/._portage_reinstall_.osj370/bin/ebuild-helpers/prepalldocs&amp;#39;, 
&amp;quot;[Errno 13] Permission denied: &amp;#39;/var/tmp/portage/._portage_reinstall_.osj370/bin/ebuild-helpers/prepalldocs&amp;#39;&amp;quot;), 
(b&amp;#39;/usr/lib64/portage/bin/ebuild-helpers/prepinfo&amp;#39;, 
b&amp;#39;/var/tmp/portage/._portage_reinstall_.osj370/bin/ebuild-helpers/prepinfo&amp;#39;, 
&amp;quot;[Errno 13] Permission denied: &amp;#39;/var/tmp/portage/._portage_reinstall_.osj370/bin/ebuild-helpers/prepinfo&amp;#39;&amp;quot;), 
(b&amp;#39;/usr/lib64/portage/bin/ebuild-helpers/newlib.so&amp;#39;, 
b&amp;#39;/var/tmp/portage/._portage_reinstall_.osj370/bin/ebuild-helpers/newlib.so&amp;#39;, 
&amp;quot;[Errno 13] Permission denied: &amp;#39;/var/tmp/portage/._portage_reinstall_.osj370/bin/ebuild-helpers/newlib.so&amp;#39;&amp;quot;), 
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the errors go on and on and on.&lt;/p&gt;
&lt;p&gt;I've been able to get it working again by allowing the following SELinux
permissions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow portage_t portage_tmp_t:dir relabel_dir_perms;
allow portage_t portage_tmp_t:lnk_file relabel_lnk_file_perms;
allow portage_t bin_t:dir relabel_dir_perms;
allow portage_t bin_t:file relabel_file_perms;
allow portage_t bin_t:lnk_file relabel_lnk_file_perms;
allow portage_t portage_exec_t:file relabel_file_perms;
allow portage_t portage_fetch_exec_t:file relabel_file_perms;
allow portage_t lib_t:dir relabel_dir_perms;
allow portage_t lib_t:file relabel_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can somewhat shorten this by combining types (but this doesn't work
with selocal for now):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow portage_t { portage_tmp_t bin_t lib_t}:dir relabel_dir_perms;
allow portage_t { portage_tmp_t bin_t }:lnk_file relabel_lnk_file_perms;
allow portage_t { bin_t portage_exec_t portage_fetch_exec_t lib_t}:file relabel_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At the end of the emerge process (when the new portage is installed) you
might want to reset the labels of all files provided by the portage
package:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# rlpkg portage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;These changes have not been passed into the policy yet as I first need
to find out why exactly they are needed, and as you can see from &lt;a href="http://dev.gentoo.org/devaway/"&gt;the
gentoo devaway&lt;/a&gt; page, time is not on my
side to do this. I'll try to free up some time in the next few days to
handle this as well as the &lt;a href="http://userspace.selinuxproject.org/trac/wiki/Releases"&gt;SELinux userspace
release&lt;/a&gt; but no
promises here.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit:&lt;/em&gt; I found why - it is the &lt;code&gt;_prepare_self_update&lt;/code&gt; in the
&lt;code&gt;doebuild.py&lt;/code&gt; script. It creates temporary copies of the Portage
binaries and Portage python libraries, which is why we need to support
relabel operations on the files. Support for this is now in the policy
repository.&lt;/p&gt;
&lt;/p&gt;</content><category term="Security"></category><category term="Gentoo"></category><category term="hardened"></category><category term="libffi"></category><category term="portage"></category><category term="selinux"></category></entry><entry><title>It has finally arrived: SELinux System Administration</title><link href="https://blog.siphos.be/2013/09/it-has-finally-arrived-selinux-system-administration/" rel="alternate"></link><published>2013-09-27T15:10:00+02:00</published><updated>2013-09-27T15:10:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-09-27:/2013/09/it-has-finally-arrived-selinux-system-administration/</id><summary type="html">&lt;p&gt;Almost everyone has it - either physical or in their heads: a list of
things you want to do or achieve before you... well, stop existing. Mine
still has numerous things on it (I should get on it, I know) but one of
the items on that list has recently been &lt;/p&gt;</summary><content type="html">&lt;p&gt;Almost everyone has it - either physical or in their heads: a list of
things you want to do or achieve before you... well, stop existing. Mine
still has numerous things on it (I should get on it, I know) but one of
the items on that list has recently been removed: write and have a book
published. And the result is a book called &lt;a href="http://www.packtpub.com/selinux-system-administration/book"&gt;SELinux System
Administration&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Somewhere in the second quarter of this year, &lt;a href="http://www.packtpub.com/"&gt;Packt
Publishing&lt;/a&gt; contacted me to see if I am
interested in authoring a book about SELinux, focusing on the usage of
SELinux (you know - handling booleans, dealing with file contexts, etc.)
in a short technical book (the aim was 100 pages). Considering that I'm
almost always busy with documentation and editing (for instance, I
&lt;a href="http://www.gentoo.org/news/en/gwn/20031110-newsletter.xml#doc_chap2"&gt;joined
Gentoo&lt;/a&gt;
as documentation translator and editor beginning of 2003 if I remember
correctly) and am busy keeping SELinux support within Gentoo on a good
level, I of course said yes to the request.&lt;/p&gt;
&lt;p&gt;Now, 100 pages is not a lot for a topic as complex and diverse as
SELinux so was really challenging, but I do think I managed to get
everything in it while keeping it practical. The book first starts with
the fundamentals of SELinux - concepts you really need to grasp before
diving into SELinux. Then, it goes on about switching SELinux state
(disabling, permissive, granular permissive, etc.), logging, managing
SELinux users and roles, handling process domains, etc. Just take a look
at the table of contents and you'll see what I mean ;-)&lt;/p&gt;
&lt;p&gt;Inside the book, examples are given based on Fedora (and thus also
RedHat Enterprise Linux) and Gentoo Hardened while ensuring that there
are few distribution specific sections in it, making it usable for Linux
administrators of systems with a different Linux distribution installed
to it. Take a look at the &lt;a href="http://www.packtpub.com/sites/default/files/9781783283170_Chapter-03.pdf?utm_source=packtpub&amp;amp;utm_medium=free&amp;amp;utm_campaign=pdf"&gt;sample
chapter&lt;/a&gt;
and, if you like it, put it on your wish list and let everyone know ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="administration"></category><category term="book"></category><category term="fedora"></category><category term="Gentoo"></category><category term="packt"></category><category term="packtpub"></category><category term="selinux"></category><category term="system"></category></entry><entry><title>Why our policies don't like emerge --config</title><link href="https://blog.siphos.be/2013/08/why-our-policies-dont-like-emerge-config/" rel="alternate"></link><published>2013-08-23T11:53:00+02:00</published><updated>2013-08-23T11:53:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-23:/2013/08/why-our-policies-dont-like-emerge-config/</id><summary type="html">&lt;p&gt;One of the features that Portage provides is to have post-processing
done on request of the administrator for certain packages. For instance,
for the &lt;code&gt;dev-db/postgresql-server&lt;/code&gt; package we can call its
&lt;code&gt;pkg_config()&lt;/code&gt; phase to create the PostgreSQL instance and configure it
so that the configuration of the database is stored &lt;/p&gt;</summary><content type="html">&lt;p&gt;One of the features that Portage provides is to have post-processing
done on request of the administrator for certain packages. For instance,
for the &lt;code&gt;dev-db/postgresql-server&lt;/code&gt; package we can call its
&lt;code&gt;pkg_config()&lt;/code&gt; phase to create the PostgreSQL instance and configure it
so that the configuration of the database is stored in
&lt;code&gt;/etc/postgresql-9.2&lt;/code&gt; rather than together with the data files.&lt;/p&gt;
&lt;p&gt;When you run Gentoo with SELinux however, you might already have noticed
that this doesn't work. The reason is that, whenever an administrator
calls &lt;strong&gt;emerge&lt;/strong&gt;, the process (and by default its child processes) will
run in a confined domain called &lt;code&gt;portage_t&lt;/code&gt;. The domain is still quite
privileged, but not as privileged as the administrator domain
&lt;code&gt;sysadm_t&lt;/code&gt;. It holds the rights to build software and install files,
directories and other things on the file system. But it does not support
switching users for instance, which is what the PostgreSQL
&lt;code&gt;pkg_config()&lt;/code&gt; does: it wants to run a certain command as the &lt;code&gt;postgres&lt;/code&gt;
user, which is prohibited by SELinux.&lt;/p&gt;
&lt;p&gt;I'm not sure yet how to tackle this properly. One thing is that I might
update Portage to run in the user domain by default, and transition
dynamically towards the proper domains according to the task(s) it is
executing. We already do this for building software (where we transition
to a &lt;code&gt;portage_sandbox_t&lt;/code&gt; confined domain), perhaps it can be expanded to
support transitioning to &lt;code&gt;portage_t&lt;/code&gt; when it isn't running the
&lt;code&gt;pkg_config()&lt;/code&gt; phase. But that means injecting (more) SELinux-specific
code in Portage, something I'd rather not do (introduces additional
complexity and maintenance).&lt;/p&gt;
&lt;p&gt;Another possibility would be to have administrators explicitly state
that no transition should occur, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# runcon -t sysadm_t emerge --config =dev-db/postgresql-server-9.2.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With a minor addition to the policy, this gave me a good hope... until I
noticed that &lt;strong&gt;emerge&lt;/strong&gt; underlyingly calls &lt;strong&gt;ebuild&lt;/strong&gt; and &lt;strong&gt;ebuild.sh&lt;/strong&gt;,
both labeled as &lt;code&gt;portage_exec_t&lt;/code&gt;, so these calls transition to
&lt;code&gt;portage_t&lt;/code&gt; again.&lt;/p&gt;
&lt;p&gt;I'm going to look further into this - there are quite a few options
still open.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="pkg_config"></category><category term="portage"></category><category term="selinux"></category></entry><entry><title>Network routing based on SELinux?</title><link href="https://blog.siphos.be/2013/08/network-routing-based-on-selinux/" rel="alternate"></link><published>2013-08-21T19:43:00+02:00</published><updated>2013-08-21T19:43:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-21:/2013/08/network-routing-based-on-selinux/</id><summary type="html">&lt;p&gt;Today we had a question on #selinux if it was possible to route traffic
of a specific process using SELinux. The answer to this is "no",
although it has to be explained a bit in more detail.&lt;/p&gt;
&lt;p&gt;SELinux does not route traffic. SELinux is a local mandatory access
control system &lt;/p&gt;</summary><content type="html">&lt;p&gt;Today we had a question on #selinux if it was possible to route traffic
of a specific process using SELinux. The answer to this is "no",
although it has to be explained a bit in more detail.&lt;/p&gt;
&lt;p&gt;SELinux does not route traffic. SELinux is a local mandatory access
control system; its purpose is to allow or deny certain actions, not
route traffic. However, Linux' NetFilter does support security markings
(SECMARK). I've &lt;a href="http://blog.siphos.be/2013/05/secmark-and-selinux/"&gt;blogged about
it&lt;/a&gt; in the past, and
there are good tutorials elsewhere on the Internet, such as Dan Walsh'
&lt;a href="http://www.linux.com/learn/tutorials/421152-using-selinux-and-iptables-together"&gt;Using SELinux and iptables
together&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Linux support for security marking does allow for routing decisions -
but it does not "use" SELinux in this regard. To mark traffic with a
certain label, the administrator has to put in the rules himself using
&lt;strong&gt;iptables&lt;/strong&gt; or &lt;strong&gt;ip6tables&lt;/strong&gt; commands. And if you have to do that, then
you are already working with the routing commands so why not just route
immediately? Of course, the advantage of labeling the traffic is that
you can then use SELinux to allow or deny processes to send or receive
those packets - but SELinux is not involved with routing.&lt;/p&gt;
&lt;p&gt;Another possibility is to use labeled networking, such as Labeled IPSec
or NetLabel/CIPSO support.&lt;/p&gt;
&lt;p&gt;With labeled networking, all hosts that participate in the network need
to support the labeled networking technology. If that is the case, then
SELinux policy can be used to deny traffic from one host or another -
but again, not to route traffic. You can use SELinux to deny one process
to send out data to one set of hosts and allow it to send data to
another, but that is not routing. The advantage of Labeled IPSec is that
contexts are retained across the network - decisions that SELinux has to
take on one system can be made based on the context of the process on
the other system.&lt;/p&gt;
&lt;p&gt;So no, SELinux cannot be used to route traffic, but it plays very nicely
with various networking controls to make proper decisions on its access
control enforcement.&lt;/p&gt;</content><category term="SELinux"></category><category term="ipsec"></category><category term="netlabel"></category><category term="networking"></category><category term="secmark"></category><category term="selinux"></category></entry><entry><title>Using CUSTOM_BUILDOPT in refpolicy for USE flag-alike functionality?</title><link href="https://blog.siphos.be/2013/08/using-custom_buildopt-in-refpolicy-for-use-flag-alike-functionality/" rel="alternate"></link><published>2013-08-16T09:17:00+02:00</published><updated>2013-08-16T09:17:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-16:/2013/08/using-custom_buildopt-in-refpolicy-for-use-flag-alike-functionality/</id><summary type="html">&lt;p&gt;As you are probably aware, Gentoo uses the &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;reference
policy&lt;/a&gt; as its base for
SELinux policies. Yes, we do customize it and not everything is already
pushed upstream (for instance, our approach to use &lt;code&gt;xdg_*_home_t&lt;/code&gt;
customizable types to further restrict user application access has been
sent up for comments &lt;/p&gt;</summary><content type="html">&lt;p&gt;As you are probably aware, Gentoo uses the &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;reference
policy&lt;/a&gt; as its base for
SELinux policies. Yes, we do customize it and not everything is already
pushed upstream (for instance, our approach to use &lt;code&gt;xdg_*_home_t&lt;/code&gt;
customizable types to further restrict user application access has been
sent up for comments a few times but we still need to iron it out
further) but all in all, we're pretty close to the upstream releases.
This is also visible when there are changes upstream as we very easily
integrate them back in our repository.&lt;/p&gt;
&lt;p&gt;But there are still a few things that I want to implement further, and
one of these things is perhaps too specific for Gentoo but would benefit
us (security-wise) in great detail: enabling domain privileges based on
USE flags. Allow me to quickly use an example to make this more
tangible.&lt;/p&gt;
&lt;p&gt;Consider the MPlayer application. As a media application, it of course
offers support for ALSA and PulseAudio (amongst other things). In the
SELinux policy, support for (and thus privileges related to) ALSA and
PulseAudio is handled through &lt;em&gt;optional_policy&lt;/em&gt; statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;optional_policy(`
  pulseaudio_tmpfs_content(mplayer_tmpfs_t)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This means that the rules defined in &lt;em&gt;pulseaudio_tmpfs_content&lt;/em&gt; are
executed if the dependencies match:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`pulseaudio_tmpfs_content&amp;#39;,`
        gen_require(`
                attribute pulseaudio_tmpfsfile;
        &amp;#39;)

        typeattribute $1 pulseaudio_tmpfsfile;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the &lt;code&gt;pulseaudio_tmpfsfile&lt;/code&gt; attribute exists, then the
&lt;code&gt;mplayer_tmpfs_t&lt;/code&gt; type gets the &lt;code&gt;pulseaudio_tmpfsfile&lt;/code&gt; attribute
assigned to it.&lt;/p&gt;
&lt;p&gt;This is flexible, because if the server/workstation does not use
PulseAudio, then in Gentoo, no pulseaudio SELinux module will be loaded
and thus the attribute will not exist. However, Gentoo tries to be a bit
more flexible in this - it is very well possible to have PulseAudio
installed, but disable PulseAudio support in MPlayer (build mplayer with
USE="-pulseaudio"). The current definitions in the policy do not support
this flexibility: if the pulseaudio module is loaded, then the
privileges become active.&lt;/p&gt;
&lt;p&gt;One way SELinux supports a more flexible approach is to use conditionals
in the policy. One could create booleans that administrators can toggle
to enable / disable SELinux rules. For instance, in the mplayer policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tunable_policy(`allow_mplayer_execstack&amp;#39;,`
        allow mencoder_t self:process { execmem execstack };
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If an administrator toggles the &lt;code&gt;allow_mplayer_execstack&lt;/code&gt; boolean to
"on", then the mentioned &lt;code&gt;allow&lt;/code&gt; rule becomes active.&lt;/p&gt;
&lt;p&gt;Sadly, this approach is not fully usable for USE driven decisions. Not
all rules can be enclosed in &lt;code&gt;tunable_policy&lt;/code&gt; statements, and &lt;a href="http://oss.tresys.com/pipermail/refpolicy/2013-July/006452.html"&gt;assigning
attributes to a
type&lt;/a&gt;
is one of them (cfr our pulseaudio example). A recent discussion on the
reference policy mailinglist gave me two ideas to investigate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;See if we can support CIL (a new language for SELinux
    policy definitions) where such an approach would be easier&lt;/li&gt;
&lt;li&gt;Use build-time decisions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this post, I want to go through the &lt;em&gt;build-time decisions&lt;/em&gt; idea. The
reference policy supports build-time options using &lt;em&gt;ifdef&lt;/em&gt; constructs.
These look at parameters provided by the build system (M4/Makefile
based) to see if rules need to be activated or not. For type attribute
declarations, this is a valid approach. So one idea would be to
transform USE flags, if they are set, into &lt;code&gt;use_${USEFLAG}&lt;/code&gt;, and make
decisions based on this in the policy code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ifdef(`use_pulseaudio&amp;#39;,`
  optional_policy(`
    pulseaudio_tmpfs_content(mplayer_tmpfs_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can add in the USE flags, if set, through the &lt;code&gt;CUSTOM_BUILDOPT&lt;/code&gt;
parameter that the reference policy provides. So introducing this is not
that difficult. The only thing I'm currently a bit weary about is the
impact on the policy files themselves (which is why I haven't done this
already) and the fact that USE flags on the "real" package are not know
to policy packages. In other words, if a user explicitly marks
&lt;code&gt;USE="-pulseaudio"&lt;/code&gt; on mplayer, but has &lt;code&gt;USE="pulseaudio"&lt;/code&gt; set as
general value, then the &lt;code&gt;selinux-mplayer&lt;/code&gt; package will still have
pulseaudio enabled.&lt;/p&gt;
&lt;p&gt;Still, I do like the idea. It would make it more consistent with what
Gentoo aims to do: if you do not want a certain support/feature in the
code, then why would the policy still have to allow it? With the proper
documentation towards administrators, I think this would be a good
approach.&lt;/p&gt;</content><category term="Gentoo"></category><category term="boolean"></category><category term="Gentoo"></category><category term="policy"></category><category term="selinux"></category><category term="use"></category><category term="useflag"></category></entry><entry><title>Some things sound more scary than they are</title><link href="https://blog.siphos.be/2013/08/some-things-sound-more-scary-than-they-are/" rel="alternate"></link><published>2013-08-15T10:02:00+02:00</published><updated>2013-08-15T10:02:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-15:/2013/08/some-things-sound-more-scary-than-they-are/</id><summary type="html">&lt;p&gt;A few days ago I finally got to the next thing on my &lt;em&gt;Want to do this
year&lt;/em&gt; list: put a new android
(&lt;a href="http://www.cyanogenmod.org/"&gt;Cyanogenmod&lt;/a&gt;) on my tablet, which was
still running the stock Android - but hasn't seen any updates in more
than a year. Considering the (in)security of Android &lt;/p&gt;</summary><content type="html">&lt;p&gt;A few days ago I finally got to the next thing on my &lt;em&gt;Want to do this
year&lt;/em&gt; list: put a new android
(&lt;a href="http://www.cyanogenmod.org/"&gt;Cyanogenmod&lt;/a&gt;) on my tablet, which was
still running the stock Android - but hasn't seen any updates in more
than a year. Considering the (in)security of Android this was long
overdue for me. But the fear of getting an unbootable tablet ("bricked"
as it is often called) was keeping me from doing so.&lt;/p&gt;
&lt;p&gt;So when I finally got the nerves, I first had to run around screaming
for hours because the first step in the instructions didn't work. The
next day I read that it might have to do with the cable - and indeed,
tried with a different cable and the instructions just went along just
fine. So today I'm happily running with a more up-to-date Android again
on my tablet.&lt;/p&gt;
&lt;p&gt;Because my systems run Gentoo Hardened with SELinux, I did had to do
some small magic tricks to get the
&lt;a href="http://www.clockworkmod.com/"&gt;Clockworkmod&lt;/a&gt; recovery on the tablet: the
&lt;strong&gt;wheelie&lt;/strong&gt; binary (yes, I couldn't find the sources - if they are even
available) that I had to run required me to disable size overflow
detection in the kernel (a PaX countermeasure), allowed executable
memory (both through &lt;strong&gt;paxctl-ng&lt;/strong&gt; as well as in SELinux using the
&lt;code&gt;allow_execmem&lt;/code&gt; boolean) and had to temporarily add in the
&lt;code&gt;dev_rw_generic_usb_dev&lt;/code&gt; right (refpolicy macro) to my user.&lt;/p&gt;
&lt;p&gt;Also &lt;strong&gt;adb&lt;/strong&gt; had to be pax-marked, although I now know I don't need
&lt;strong&gt;adb&lt;/strong&gt; at all - I can just download the latest Android ZIP file from
the phone itself and refer to it from the recovery manager.&lt;/p&gt;
&lt;p&gt;All in all nothing to worry about - everything worked like a charm.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit:&lt;/em&gt; (so I remember next time), if the system is stuck in CMR
(recovery), reboot with VolDown+Pwr, but don't select recovery. After 5
seconds, it will ask if you want a cold boot. Select it, and things work
again ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="android"></category><category term="grsecurity"></category><category term="pax"></category><category term="selinux"></category><category term="tablet"></category></entry><entry><title>And now, 31 days later...</title><link href="https://blog.siphos.be/2013/08/and-now-31-days-later/" rel="alternate"></link><published>2013-08-01T22:43:00+02:00</published><updated>2013-08-01T22:43:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-01:/2013/08/and-now-31-days-later/</id><summary type="html">&lt;p&gt;... the &lt;a href="http://www.gentoo.org/proj/en/hardened"&gt;Gentoo Hardened&lt;/a&gt; team
had its monthly online meeting again ;-)&lt;/p&gt;
&lt;p&gt;On the agenda were the usual suspects, such as the &lt;em&gt;toolchain&lt;/em&gt;. In this
category, Zorry mentioned that he has a fix for GCC 4.8.1 for the
&lt;code&gt;hardenedno*&lt;/code&gt; and vanilla &lt;code&gt;gcc-config&lt;/code&gt; options which will be added to
the tree &lt;/p&gt;</summary><content type="html">&lt;p&gt;... the &lt;a href="http://www.gentoo.org/proj/en/hardened"&gt;Gentoo Hardened&lt;/a&gt; team
had its monthly online meeting again ;-)&lt;/p&gt;
&lt;p&gt;On the agenda were the usual suspects, such as the &lt;em&gt;toolchain&lt;/em&gt;. In this
category, Zorry mentioned that he has a fix for GCC 4.8.1 for the
&lt;code&gt;hardenedno*&lt;/code&gt; and vanilla &lt;code&gt;gcc-config&lt;/code&gt; options which will be added to
the tree after some more testing. The problem is that with GCC 4.8,
certain settings need to be set sooner than before (in the code path),
which is what the fix focuses on. The ASAN issue is still unresolved,
but otherwise GCC 4.8 is working fine.&lt;/p&gt;
&lt;p&gt;On &lt;em&gt;SELinux&lt;/em&gt;, the policycoreutils package has been bumped to include
support for &lt;code&gt;mcstrans&lt;/code&gt;, a translation daemon that visualizes humanly
readable strings instead of the standard sensitivity/category sets in
case of MCS/MLS policies.&lt;/p&gt;
&lt;p&gt;Regarding documentation, the wiki team (most notably a3li) is working
hard to support project pages on the &lt;a href="https://wiki.gentoo.org"&gt;Gentoo
Wiki&lt;/a&gt;. Once we can, we will be moving our
project page with all related documentation to the wiki, allowing for
easier documentation development and a more modern look. To support
this, an XML-to-wiki stylesheet is available that translates ProjectXML
and GuideXML to the wiki language.&lt;/p&gt;
&lt;p&gt;During the meeting, we also mentioned the stabilization policy (or at
least, no-longer-stabilization) of the vanilla sources (plain kernel.org
Linux kernel sources). This doesn't immediately effect the hardened
project, but is important to know nonetheless, especially for users of
hardened technologies that are in the main kernel already (like SELinux
or IMA/EVM) as they have to be aware to either use the latest
(regardless of the keywords in use) or switch to gentoo-sources or
(preferably) hardened-sources.&lt;/p&gt;
&lt;p&gt;For uclibc support, the stages will be provided every 2 months rather
than every month as this is a resource-intensive process that isn't
fully automated yet (except for amd64 and x86 which are automated).&lt;/p&gt;
&lt;p&gt;Finally, on PaX and grSecurity support, the XATTR patch for tmpfs is now
in the kernel, and the problem about loosing PaX markings during
installation is fixed as Portage (2.1.12.9 and higher) now preserves the
flags during installation (a wrapper on &lt;code&gt;install&lt;/code&gt; is used that preserves
&lt;code&gt;usr.pax.flags&lt;/code&gt;).&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="grsecurity"></category><category term="hardened"></category><category term="irc"></category><category term="irl"></category><category term="meeting"></category><category term="minutes"></category><category term="pax"></category><category term="project"></category><category term="selinux"></category><category term="toolchain"></category></entry><entry><title>Rebuilding SELinux contexts with sefcontext_compile</title><link href="https://blog.siphos.be/2013/07/rebuilding-selinux-contexts-with-sefcontext_compile/" rel="alternate"></link><published>2013-07-08T20:55:00+02:00</published><updated>2013-07-08T20:55:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-07-08:/2013/07/rebuilding-selinux-contexts-with-sefcontext_compile/</id><summary type="html">&lt;p&gt;A recent update of &lt;em&gt;libpcre&lt;/em&gt; caused the binary precompiled regular
expression files of SELinux to become outdated (and even blatantly
wrong). The details are in bug &lt;a href="https://bugs.gentoo.org/471718"&gt;471718&lt;/a&gt;
but that doesn't help the users that are already facing the problem, nor
have we found a good place to put the fix &lt;/p&gt;</summary><content type="html">&lt;p&gt;A recent update of &lt;em&gt;libpcre&lt;/em&gt; caused the binary precompiled regular
expression files of SELinux to become outdated (and even blatantly
wrong). The details are in bug &lt;a href="https://bugs.gentoo.org/471718"&gt;471718&lt;/a&gt;
but that doesn't help the users that are already facing the problem, nor
have we found a good place to put the fix in.&lt;/p&gt;
&lt;p&gt;Anyway, if you are facing issues with SELinux labeling (having files
being labeled as &lt;em&gt;portage_tmp_t&lt;/em&gt; instead of the proper label), check
with &lt;strong&gt;matchpathcon&lt;/strong&gt; if the label is correct. If &lt;strong&gt;matchpathcon&lt;/strong&gt; sais
that the label should be &lt;code&gt;&amp;lt;&amp;lt;none&amp;gt;&amp;gt;&lt;/code&gt; then you need to rebuild the SELinux
context files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# cd /etc/selinux/strict/contexts/files
# for n in *.bin; do sefcontext_compile ${n%%.bin}; done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;sefcontext_compile&lt;/strong&gt; command will rebuild the SELinux context
files. When that has been done, &lt;strong&gt;matchpathcon&lt;/strong&gt; should show the right
context again, and Portage will relabel files correctly. Until then, you
will need to relabel the packages that have been built since (and
including) the &lt;em&gt;libpcre&lt;/em&gt; build.&lt;/p&gt;
&lt;p&gt;If someone has a good suggestion where to put these rebuilds in, please
do drop a note in the bug. Although the proper one might be &lt;em&gt;libpcre&lt;/em&gt;
itself, I'd rather not put too much SELinux logic in the ebuild unless
it is pretty safeguarded...&lt;/p&gt;
&lt;p&gt;In any case, it has also been documented in the &lt;a href="https://wiki.gentoo.org/wiki/SELinux/FAQ#File_labels_do_not_seem_to_be_set_anymore.2C_and_matchpathcon_sais_.3C.3Cnone.3E.3E"&gt;Gentoo SELinux
FAQ&lt;/a&gt;
on the Gentoo wiki.&lt;/p&gt;</content><category term="SELinux"></category><category term="hardened"></category><category term="pcre"></category><category term="selinux"></category></entry><entry><title>Adding mcstrans to Gentoo</title><link href="https://blog.siphos.be/2013/07/adding-mcstrans-to-gentoo/" rel="alternate"></link><published>2013-07-07T20:38:00+02:00</published><updated>2013-07-07T20:38:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-07-07:/2013/07/adding-mcstrans-to-gentoo/</id><summary type="html">&lt;p&gt;If you use SELinux, you might be using an MLS-enabled policy. These are
policies that support sensitivity labels on resources and domains. In
Gentoo, these are supported in the &lt;code&gt;mcs&lt;/code&gt; and &lt;code&gt;mls&lt;/code&gt; policy stores. Now
sensitivity ranges are fun to work with, but the moment you have several
sensitivity levels &lt;/p&gt;</summary><content type="html">&lt;p&gt;If you use SELinux, you might be using an MLS-enabled policy. These are
policies that support sensitivity labels on resources and domains. In
Gentoo, these are supported in the &lt;code&gt;mcs&lt;/code&gt; and &lt;code&gt;mls&lt;/code&gt; policy stores. Now
sensitivity ranges are fun to work with, but the moment you have several
sensitivity levels, or you have several dozen categories (sets or tags
that can be used in conjunction with pure sensitivity levels) these can
become a burden to maintain.&lt;/p&gt;
&lt;p&gt;The SELinux developers have had the same issue, so they wrote a tool
called &lt;em&gt;mcstransd&lt;/em&gt;, a translation daemon that reads the sensitivity
labels from the SELinux context (such as &lt;code&gt;s0-s0:c0.c1023&lt;/code&gt; or &lt;code&gt;s0:c12&lt;/code&gt;)
and displays a more human readable string for this (such as
&lt;code&gt;SystemLow-SystemHigh&lt;/code&gt; or &lt;code&gt;SalesTeam&lt;/code&gt;). The daemon is not a super
intelligent one - we just configure it by creating a mapping file in
&lt;code&gt;/etc/selinux/mcs&lt;/code&gt; called &lt;code&gt;setrans.conf&lt;/code&gt; which contains the mappings:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;## setrans.conf ## s0-s0:c0.c1023=SystemLow-SystemHigh s0:c12=SalesTeam&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The SELinux libraries (libselinux and libsemanage) use a socket to
communicate with the daemon to see if "translated" values need to be
displayed. If not (because the daemon is missing) the libraries keep the
SELinux syntax displayed. If it is, then the translated labels are
displayed.&lt;/p&gt;
&lt;p&gt;Support for categories and sensitivity labels is handled through the
&lt;strong&gt;chcat&lt;/strong&gt; tool, so you can list the current categories (and their
translated values) as well as assign them to files (or even logins).&lt;/p&gt;
&lt;p&gt;Although we supported categories for a while already, a recent update on
the &lt;code&gt;policycoreutils&lt;/code&gt; package now includes the mcstrans daemon as well.
Documentation is available, currently in the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml?part=2&amp;amp;chap=7#doc_chap3"&gt;pending changes
section&lt;/a&gt;
of the SELinux handbook (as this is not in the stable package yet) and
it will be moved to the main document when the package has stabilized.&lt;/p&gt;</content><category term="Gentoo"></category><category term="categories"></category><category term="mcs"></category><category term="mcstrans"></category><category term="mls"></category><category term="selinux"></category><category term="sensitivity"></category></entry><entry><title>A SELinux policy for incron: finishing up</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-finishing-up/" rel="alternate"></link><published>2013-05-31T03:50:00+02:00</published><updated>2013-05-31T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-31:/2013/05/a-selinux-policy-for-incron-finishing-up/</id><summary type="html">&lt;p&gt;After 9 posts, it's time to wrap things up. You can review the final
results online
(&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.te.txt"&gt;incron.te&lt;/a&gt;,
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.if.txt"&gt;incron.if&lt;/a&gt; and
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.fc.txt"&gt;incron.fc&lt;/a&gt;) and
adapt to your own needs if you want. But we should also review what we
have accomplished so far...&lt;/p&gt;
&lt;p&gt;We built the start of an entire &lt;/p&gt;</summary><content type="html">&lt;p&gt;After 9 posts, it's time to wrap things up. You can review the final
results online
(&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.te.txt"&gt;incron.te&lt;/a&gt;,
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.if.txt"&gt;incron.if&lt;/a&gt; and
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.fc.txt"&gt;incron.fc&lt;/a&gt;) and
adapt to your own needs if you want. But we should also review what we
have accomplished so far...&lt;/p&gt;
&lt;p&gt;We built the start of an entire policy for a daemon (the inotify cron
daemon) for two main types: the daemon itself, and its management
application &lt;strong&gt;incrontab&lt;/strong&gt;. We defined new types and contexts, we used
attributes, declared a boolean and worked with interfaces. That's a lot
to digest, and yet it is only a part of the various capabilities that
SELinux offers.&lt;/p&gt;
&lt;p&gt;The policy isn't complete though. We defined a type called
&lt;code&gt;incron_initrc_exec_t&lt;/code&gt; but don't really use it further. In practice, we
would need to define an additional interface (probably named
&lt;em&gt;incron_admin&lt;/em&gt;) that allows users and roles to manage &lt;em&gt;incron&lt;/em&gt; without
needing to grant this user/role &lt;code&gt;sysadm_r&lt;/code&gt; privileges. I leave that up
to you as an exercise for now, but I'll post more about admin interfaces
and how to work with them on a system in the near future.&lt;/p&gt;
&lt;p&gt;We also made a few assumptions and decisions while building the policy
that might not be how you yourself would want to build the policy.
SELinux is a MAC system, but the policy language is very flexible. You
can use an entirely different approach in policies if you want. For
instance, &lt;em&gt;incron&lt;/em&gt; supports launching the &lt;strong&gt;incrond&lt;/strong&gt; as a command-line,
foreground process. This could help users run &lt;strong&gt;incrond&lt;/strong&gt; under their
privileges for their own files - we did not consider this case in our
design. Although most policies try to capture all use cases of an
application, there will be cases when a policy developer did either not
consider the use case or found that it infringed with his own principles
on policy development (and allowed activities on a system).&lt;/p&gt;
&lt;p&gt;In Gentoo Hardened, I try to write down the principles and policies that
we follow in a &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-policy.xml"&gt;Gentoo Hardened SELinux Development
Policy&lt;/a&gt;
document. As decisions need to be taken, such a document might help find
common consensus on how to approach SELinux policy development further,
and I seriously recommend that you consider writing up a similar
document yourself, especially if you are going to develop policies for a
larger organization.&lt;/p&gt;
&lt;p&gt;One of the deficiencies of the current policy is that it worked with the
unmodified &lt;em&gt;incron&lt;/em&gt; version. If we would patch &lt;em&gt;incron&lt;/em&gt; so that it could
change context on executing the incrontab files of a user, then we can
start making use of the default context approach (and perhaps even
enhance with PAM services). In that case, user incrontabs could be
launched entirely from the users' context (like &lt;code&gt;user_u:user_r:user_t&lt;/code&gt;)
instead of the &lt;code&gt;system_u:system_r:incrond_t&lt;/code&gt; or transitioned
&lt;code&gt;system_u:system_r:whatever_t&lt;/code&gt; contexts. Having user provided commands
executed in the system context is a security risk, so in our policy we
would &lt;em&gt;not&lt;/em&gt; grant the &lt;em&gt;incron_role&lt;/em&gt; to untrusted users - probably only
to &lt;code&gt;sysadm_t&lt;/code&gt; and even then he probably would be better with using the
&lt;code&gt;/etc/incron.d&lt;/code&gt; anyway.&lt;/p&gt;
&lt;p&gt;The downside of patching code however is that this is only viable if
upstream wants to support this - otherwise we would need to maintain the
patches ourselves for a long time, creating delays in releases (upstream
released a new version and we still need to reapply and refactor
patches) and removing precious (human) resources from other, Gentoo
Hardened/SELinux specific tasks (like bugfixing and documentation
writing ;-)&lt;/p&gt;
&lt;p&gt;Still, the policy returned a fairly good view on how policies &lt;em&gt;can&lt;/em&gt; be
developed. And as I said, there are still other things that weren't
discussed, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build-time decisions, which can change policies based on build
    options of the policy. In the reference policy, this is most often
    used for distribution-specific choices: if Gentoo would use one
    approach and Redhat another, then the differences would be separated
    through &lt;code&gt;ifdef(`distro_gentoo',`...')&lt;/code&gt; and
    &lt;code&gt;ifdef(`distro_redhat',`...')&lt;/code&gt; calls.&lt;/li&gt;
&lt;li&gt;Some calls might only be needed if another policy is loaded. I think
    all calls made currently are part of base modules, so can be
    expected to be available at all times. But if we would need
    something like &lt;em&gt;icecast_signal(incrond_t)&lt;/em&gt;, then we would need to
    put that call inside a &lt;code&gt;optional_policy(`...')&lt;/code&gt; statement.
    Otherwise, our policy would fail to load because the &lt;em&gt;icecast&lt;/em&gt;
    SELinux policy isn't loaded.&lt;/li&gt;
&lt;li&gt;We could even introduce specific statements like &lt;em&gt;dontaudit&lt;/em&gt; or
    &lt;em&gt;neverallow&lt;/em&gt; to fine-tune the policy. Note though that &lt;em&gt;neverallow&lt;/em&gt;
    is a compile-time statement: it is not a way to negate &lt;em&gt;allow&lt;/em&gt;
    rules: if there is one &lt;em&gt;allow&lt;/em&gt; that would violate the &lt;em&gt;neverallow&lt;/em&gt;,
    then that module just refuses to build.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Furthermore, if you want to create policies to be pushed upstream to the
reference policy project, you will need to look into the
&lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide"&gt;StyleGuide&lt;/a&gt;
and
&lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming"&gt;InterfaceNaming&lt;/a&gt;
documents as those define the order that rules should be placed and the
name syntax for interfaces. I have been contributing a lot to the
reference policy and I still miss a few of these, so for me they are not
that obvious. But using a common style is important as it allows for
simple patching, code comparison and even allows us to easily read
through complex policies.&lt;/p&gt;
&lt;p&gt;If you don't want to contribute it, but still use it on your Gentoo
system, you can use a simple ebuild to install the files. Create an
ebuild (for instance &lt;code&gt;selinux-incron&lt;/code&gt;), put the three files in the
&lt;code&gt;files/&lt;/code&gt; subdirectory, and use the following ebuild code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Copyright 1999-2013 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header$
EAPI=&amp;quot;4&amp;quot;

IUSE=&amp;quot;&amp;quot;
MODS=&amp;quot;incron&amp;quot;
BASEPOL=&amp;quot;2.20130424-r1&amp;quot;
POLICY_FILES=&amp;quot;incron.te incron.fc incron.if&amp;quot;

inherit selinux-policy-2

DESCRIPTION=&amp;quot;SELinux policy for incron, the inotify cron daemon&amp;quot;

KEYWORDS=&amp;quot;~amd64 ~x86&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When installed, the interface files will be published as well and can
then be used by other modules (something we couldn't do in the past few
posts) or by the &lt;strong&gt;selocal&lt;/strong&gt; tool.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: using booleans</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-using-booleans/" rel="alternate"></link><published>2013-05-30T03:50:00+02:00</published><updated>2013-05-30T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-30:/2013/05/a-selinux-policy-for-incron-using-booleans/</id><summary type="html">&lt;p&gt;After using a default set of directories to watch, and &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/"&gt;allowing admins
to mark other
types&lt;/a&gt;
as such as well, let's consider another approach for making the policy
more flexible: booleans. The idea now is that a boolean called
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; enables &lt;strong&gt;incrond&lt;/strong&gt; to be
notified on changes on all possible &lt;/p&gt;</summary><content type="html">&lt;p&gt;After using a default set of directories to watch, and &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/"&gt;allowing admins
to mark other
types&lt;/a&gt;
as such as well, let's consider another approach for making the policy
more flexible: booleans. The idea now is that a boolean called
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; enables &lt;strong&gt;incrond&lt;/strong&gt; to be
notified on changes on all possible non-security related files (the
latter is merely an approach, you can define other sets as well if you
want, including all possible files).&lt;/p&gt;
&lt;p&gt;Booleans in SELinux policy can be generated in the &lt;code&gt;incron.te&lt;/code&gt; file as
follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## &amp;lt;desc&amp;gt;
## &amp;lt;p&amp;gt;
##      Determine whether incron can watch all non-security
##      file types
## &amp;lt;/p&amp;gt;
## &amp;lt;/desc&amp;gt;
gen_tunable(incron_notify_non_security_files, false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this boolean in place, the policy can be enhanced with code like
the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tunable_policy(`incron_notify_non_security_files&amp;#39;,`
        files_read_non_security_files(incrond_t)
        files_read_all_dirs_except(incrond_t)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This code tells SELinux that, &lt;em&gt;if&lt;/em&gt; the
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; boolean is set (which by default
is not the case), then &lt;code&gt;incrond_t&lt;/code&gt; is able to read non security files.&lt;/p&gt;
&lt;p&gt;Let's try to watch for changes in the AIDE log directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail audit.log
type=AVC msg=audit(1368777675.597:28611): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;log&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=13 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_log_t tclass=dir
type=AVC msg=audit(1368777675.597:28612): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;log&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=13 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_log_t tclass=dir

# tail cron.log
May 17 10:01:15 test incrond[11704]: access denied on /var/log/aide - events will be discarded silently

# getsebool incron_notify_non_security_files
incron_notify_non_security_files --&amp;gt; off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's enable the boolean and try again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# setsebool incron_notify_non_security_files on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Reloading the incrontab tables now works, and the notifications work as
well.&lt;/p&gt;
&lt;p&gt;As you can see, once a policy is somewhat working, policy developers are
considering the various "use cases" of an application, trying to write
down policies that can be used by the majority of users, without
granting too many rights automatically.&lt;/p&gt;</content><category term="SELinux"></category><category term="boolean"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: marking types eligible for watching</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/" rel="alternate"></link><published>2013-05-29T03:50:00+02:00</published><updated>2013-05-29T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-29:/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/</id><summary type="html">&lt;p&gt;In the
&lt;a herf="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/"&gt;previous
post&lt;/a&gt; we made &lt;strong&gt;incrond&lt;/strong&gt; able to watch &lt;code&gt;public_content_t&lt;/code&gt; and
&lt;code&gt;public_content_rw_t&lt;/code&gt; types. However, this is not scalable, so we might
want to be able to update the policy more dynamically with additional
types. To accomplish this, we will make types eligible for watching
through an attribute.&lt;/p&gt;
&lt;p&gt;So how &lt;/p&gt;</summary><content type="html">&lt;p&gt;In the
&lt;a herf="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/"&gt;previous
post&lt;/a&gt; we made &lt;strong&gt;incrond&lt;/strong&gt; able to watch &lt;code&gt;public_content_t&lt;/code&gt; and
&lt;code&gt;public_content_rw_t&lt;/code&gt; types. However, this is not scalable, so we might
want to be able to update the policy more dynamically with additional
types. To accomplish this, we will make types eligible for watching
through an attribute.&lt;/p&gt;
&lt;p&gt;So how does this work? First, we create an attribute called
&lt;code&gt;incron_notify_type&lt;/code&gt; (we can choose the name we want of course) and
grant &lt;code&gt;incrond_t&lt;/code&gt; the proper rights on all types that have been assigned
the &lt;code&gt;incron_notify_type&lt;/code&gt; attribute. Then, we create an interface that
other modules (or admins) can use to mark specific types eligible for
watching, called &lt;em&gt;incron_notify_file&lt;/em&gt;. This interface will assign the
&lt;code&gt;incron_notify_type&lt;/code&gt; attribute to the provided type.&lt;/p&gt;
&lt;p&gt;First, the attribute and its associated privileges:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;attribute incron_notify_type;
...
allow incrond_t incron_notify_type:dir list_dir_perms;
allow incrond_t incron_notify_type:file read_file_perms;
allow incrond_t incron_notify_type:lnk_file read_lnk_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it. For now, this won't do much as there are no types associated
with the &lt;code&gt;incron_notify_type&lt;/code&gt; attribute, so let's change that by
introducing the interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;########################################
## &amp;lt;summary&amp;gt;
##      Make the specified type a file or directory
##      that incrond can watch on.
## &amp;lt;/summary&amp;gt;
## &amp;lt;param name=&amp;quot;file_type&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      Type of the file to be allowed to watch
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
#
interface(`incron_notify_file&amp;#39;,`
        gen_require(`
                attribute incron_notify_type;
        &amp;#39;)

        typeattribute $1 incron_notify_type;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it! If you want &lt;strong&gt;incrond&lt;/strong&gt; to watch user content, one can now do
something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;incron_notify_file(home_root_t)
incron_notify_file(user_home_dir_t)
incron_notify_file(user_home_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Moreover, we can now also easily check what additional types have been
marked as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seinfo -aincron_notify_type -x
   incron_notify_type
      user_home_dir_t
      user_home_t
      home_root_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This attribute approach is commonly used for such setups and is becoming
more and more a "standard" approach.&lt;/p&gt;
&lt;p&gt;In the next post, we'll cover a boolean-triggered approach where
&lt;strong&gt;incrond&lt;/strong&gt; will be eligible for watching all (non-security) content.&lt;/p&gt;</content><category term="SELinux"></category><category term="attribute"></category><category term="incrond"></category><category term="selinux"></category><category term="watch"></category></entry><entry><title>A SELinux policy for incron: default set</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/" rel="alternate"></link><published>2013-05-28T03:50:00+02:00</published><updated>2013-05-28T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-28:/2013/05/a-selinux-policy-for-incron-default-set/</id><summary type="html">&lt;p&gt;I finished the last post a bit with a
&lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/"&gt;cliffhanger&lt;/a&gt;
as &lt;strong&gt;incrond&lt;/strong&gt; is still not working properly, and we got a few denials
that needed to be resolved; here they are again for your convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I finished the last post a bit with a
&lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/"&gt;cliffhanger&lt;/a&gt;
as &lt;strong&gt;incrond&lt;/strong&gt; is still not working properly, and we got a few denials
that needed to be resolved; here they are again for your convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/home/user/test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
type=AVC msg=audit(1368734110.913:28354): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The permission we are looking for here is
&lt;em&gt;userdom_list_user_home_content&lt;/em&gt;, but this is only for when we want
to watch a user home directory. What if we want to watch a server upload
directory? Or a cache directory? We might need to have &lt;strong&gt;incrond&lt;/strong&gt; have
the proper accesses on all directories. But then again, &lt;em&gt;all&lt;/em&gt; does sound
a bit... much, doesn't it? So let's split it up in three waves:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;incrond_t&lt;/code&gt; domain will support a minimal set of types that it
    can watch, based on common approaches&lt;/li&gt;
&lt;li&gt;I will introduce an interface that allows other modules to mark
    specific types as being "watch-worthy"&lt;/li&gt;
&lt;li&gt;A boolean will be set to allow &lt;code&gt;incrond_t&lt;/code&gt; to watch a very large set
    of types (just in case the admin trusts it sufficiently)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's first consider a decent minimal set. Within most SELinux policies,
two types are often used for public access (or for uploading of data).
These types are &lt;code&gt;public_content_t&lt;/code&gt; and &lt;code&gt;public_content_rw_t&lt;/code&gt;, and is
used for instance for FTP definitions (upload folders), HTTP servers and
such. So we introduce the proper rights to watch that data. There is an
interface available called &lt;em&gt;miscfiles_read_public_files&lt;/em&gt; but let's
first see if that interface isn't too broad (after all, watching might
not be the same as reading).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# This is only to temporarily check if the rights of the interface are too broad or not
# You can set this using &amp;quot;selocal&amp;quot; or in a module (in which case you&amp;#39;ll need to &amp;#39;require&amp;#39;
# the two types)
allow incrond_t public_content_t:dir { read getattr };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After editing the incrontab to watch a directory labeled with
&lt;code&gt;public_content_t&lt;/code&gt;, we now get the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 08:46:12 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 08:46:12 test incrond[11281]: cannot exec process: Operation not permitted
May 17 08:46:12 test incrond[9716]: cannot send SIGCHLD token to notification pipe

# tail audit.log
type=AVC msg=audit(1368773172.313:28386): avc:  denied  { setgid } for  pid=11281 comm=&amp;quot;incrond&amp;quot; capability=6  scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=capability
type=AVC msg=audit(1368773172.314:28387): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;pipe:[14027]&amp;quot; dev=&amp;quot;pipefs&amp;quot; ino=14027 scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=fifo_file
type=AVC msg=audit(1368773172.315:28388): avc:  denied  { write } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;pipe:[14027]&amp;quot; dev=&amp;quot;pipefs&amp;quot; ino=14027 scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=fifo_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As the incrontab is a user incrontab, we can expect &lt;code&gt;incrond_t&lt;/code&gt; to
require setuid and setgid privileges. Also, the &lt;em&gt;fifo_file&lt;/em&gt; access is
after forking (notice the difference in PID values) and most likely to
communicate to the master process. So let's allow those:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t self:capability { setuid setgid };
allow incrond_t self:fifo_file { read write };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that set, we get the following upon triggering a file write:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 08:52:46 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 08:52:46 test incrond[11338]: cannot exec process: Permission denied

# tail audit.log
type=AVC msg=audit(1368773566.606:28394): avc:  denied  { read } for  pid=11338 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;ngroups_max&amp;quot; dev=&amp;quot;proc&amp;quot; ino=5711 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:sysctl_kernel_t tclass=file
type=AVC msg=audit(1368773566.607:28395): avc:  denied  { search } for  pid=11338 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;bin&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=1048578 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:bin_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;ngroups_max&lt;/code&gt; pseudo-file (in &lt;code&gt;/proc/sys/kernel&lt;/code&gt;) returns the
maximum number of supplementary group IDs per process, and is consulted
through the &lt;em&gt;initgroups()&lt;/em&gt; method provided by a system library, so it
&lt;em&gt;might&lt;/em&gt; make sense to allow it. For now though, I will not enable it (as
reading &lt;code&gt;sysctl_kernel_t&lt;/code&gt; exposes a lot of other system information) but
I might be forced to do so later if things don't work out well. The
&lt;em&gt;search&lt;/em&gt; privilege on &lt;code&gt;bin_t&lt;/code&gt; is needed to find the script that I have
prepared (&lt;code&gt;/usr/local/bin/test&lt;/code&gt;) to be executed, so I add in a
&lt;em&gt;corecmd_search_bin&lt;/em&gt; and retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 09:02:55 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 09:02:55 test incrond[11427]: cannot exec process: Permission denied

# tail audit.log
type=AVC msg=audit(1368774175.646:28441): avc:  denied  { read } for  pid=11427 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;sh&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=131454 scontext=system_u:system_r:incrond_t tcontext=root:object_r:bin_t tclass=lnk_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Still not there yet apparently. The &lt;strong&gt;incrond&lt;/strong&gt; forked process wants to
execute the script, but to do so it has to follow a symbolic link
labeled &lt;code&gt;bin_t&lt;/code&gt;. This is because the script points to &lt;code&gt;#!/bin/sh&lt;/code&gt; which
is a symlink to the system shell. We need to follow this link before the
execution can occur; only after execution will the transition from
&lt;code&gt;incrond_t&lt;/code&gt; to &lt;code&gt;system_cronjob_t&lt;/code&gt; be done.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corecmd_read_bin_symlinks(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that set in the policy, the watch works, &lt;strong&gt;incrond&lt;/strong&gt; properly
launches the command and the command properly transitions into
&lt;code&gt;system_cronjob_t&lt;/code&gt; as we defined earlier (I check this by echo'ing the
output of &lt;strong&gt;id -Z&lt;/strong&gt; into a temporary file).&lt;/p&gt;
&lt;p&gt;So we are left with the (temporary) rights we granted on
&lt;code&gt;public_content_t&lt;/code&gt;. Consider the rules we had versus the rules applied
with &lt;em&gt;miscfiles_read_public_files&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t public_content_t:dir { read getattr };

# miscfiles_read_public_files
allow $1 { public_content_t public_content_rw_t }:dir list_dir_perms;
read_files_pattern($1, { public_content_t public_content_rw_t }, { public_content_t public_content_rw_t })
read_lnk_files_pattern($1, { public_content_t public_content_rw_t }, { public_content_t public_content_rw_t })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The rights here seem to bemore than what we need. Playing around a bit
with the directories reveals that &lt;strong&gt;incrond&lt;/strong&gt; requires a bit more. For
instance, when you create additional directories (subdirectories) and
want to match multiple ones:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 09:16:08 test incrond[11704]: access denied on /var/www/test/* - events will be discarded silently
May 17 09:16:08 test incrond[11704]: cannot create watch for user user: (13) Permission denied

# tail audit.log
type=AVC msg=audit(1368774968.416:28504): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1488 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=dir
type=AVC msg=audit(1368774968.416:28505): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1488 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Similarly if you want to watch on a particular file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368775274.655:28552): avc:  denied  { getattr } for  pid=11704 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/var/www/test/testfile&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1709 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=file
type=AVC msg=audit(1368775274.655:28553): avc:  denied  { read } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;testfile&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1709 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So it looks like &lt;em&gt;miscfiles_read_public_files&lt;/em&gt; isn't that bad after
all.&lt;/p&gt;
&lt;p&gt;All we are left with is the access to &lt;code&gt;ngroups_max&lt;/code&gt;. We can ignore the
calls and make sure they don't show up in standard auditing using
&lt;em&gt;kernel_dontaudit_read_kernel_sysctls&lt;/em&gt; or we can allow it with
&lt;em&gt;kernel_read_kernel_sysctls&lt;/em&gt;. I'm going to take the former approach
for my system, but your own idea might be different.&lt;/p&gt;
&lt;p&gt;I tested all this with user incrontabs (as those are the "most"
advanced) but one can easily test with system incrontabs as well
(placing one in &lt;code&gt;/etc/incron.d&lt;/code&gt;). Just be aware that &lt;em&gt;incrond&lt;/em&gt; will take
the first match and will not seek other matches. So if a system
incrontab watches &lt;code&gt;/var/www&lt;/code&gt; and another line (or user incrontab)
watches &lt;code&gt;/var/www/localhost/upload&lt;/code&gt; it is very well possible that only
the &lt;code&gt;/var/www&lt;/code&gt; watch is triggered.&lt;/p&gt;
&lt;p&gt;So right now, our &lt;code&gt;incrond_t&lt;/code&gt; policy looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrond policy
#

allow incrond_t self:capability { setgid setuid };

allow incrond_t incron_spool_t:dir list_dir_perms;
allow incrond_t incron_spool_t:file read_file_perms;

allow incrond_t self:fifo_file { read write };

allow incrond_t incrond_var_run_t:file manage_file_perms;
files_pid_filetrans(incrond_t, incrond_var_run_t, file)

kernel_dontaudit_read_kernel_sysctls(incrond_t)

corecmd_read_bin_symlinks(incrond_t)
corecmd_search_bin(incrond_t)

files_search_spool(incrond_t)

logging_send_syslog_msg(incrond_t)

auth_use_nsswitch(incrond_t)

miscfiles_read_localization(incrond_t)
miscfiles_read_public_files(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next on the agenda is another interface to make other types
"watch-worthy".&lt;/p&gt;</content><category term="SELinux"></category><category term="booleans"></category><category term="incrond"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: the incrond daemon</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/" rel="alternate"></link><published>2013-05-27T03:50:00+02:00</published><updated>2013-05-27T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-27:/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/</id><summary type="html">&lt;p&gt;With &lt;code&gt;incrontab_t&lt;/code&gt; (hopefully) complete, let's look at the &lt;code&gt;incrond_t&lt;/code&gt;
domain. As this domain will also be used to execute the user (and
system) commands provided through the incrontabs, we need to consider
how we are going to deal with this wide range of possible permissions
that it might take. One &lt;/p&gt;</summary><content type="html">&lt;p&gt;With &lt;code&gt;incrontab_t&lt;/code&gt; (hopefully) complete, let's look at the &lt;code&gt;incrond_t&lt;/code&gt;
domain. As this domain will also be used to execute the user (and
system) commands provided through the incrontabs, we need to consider
how we are going to deal with this wide range of possible permissions
that it might take. One would be to make &lt;code&gt;incrond_t&lt;/code&gt; quite powerful, and
extend its privileges as we go further. But in my opinion, that's not a
good way to deal with it.&lt;/p&gt;
&lt;p&gt;Another would be to support a small set of permissions, and introduce an
interface that other modules can use to create a transition when
&lt;code&gt;incrond_t&lt;/code&gt; executes a script properly labeled for a transition. For
instance, a domain &lt;code&gt;foo_t&lt;/code&gt; might have an executable type &lt;code&gt;foo_exec_t&lt;/code&gt;.
Most modules support an interface similar to &lt;em&gt;foo_domtrans&lt;/em&gt; (and
&lt;em&gt;foo_role&lt;/em&gt; if roles are applicable as well), but that assumes that the
&lt;em&gt;incron&lt;/em&gt; policy is modified every time a new target module is made
available (since we then need to add the proper &lt;em&gt;*_domtrans&lt;/em&gt; rules to
the &lt;em&gt;incron&lt;/em&gt; policy. Instead, we might want to make this something that
the &lt;em&gt;foo&lt;/em&gt; SELinux module can decide.&lt;/p&gt;
&lt;p&gt;It is that approach that we are going to take here. To do so, we will
create a new interface called &lt;em&gt;incron_entry&lt;/em&gt;, taken a bit from the
&lt;em&gt;cron_system_entry&lt;/em&gt; interface already in place for the regular &lt;em&gt;cron&lt;/em&gt;
domain (the following comes in &lt;code&gt;incron.if&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## &amp;lt;summary&amp;gt;
##      Make the specified program domain
##      accessible from the incrond job.
## &amp;lt;/summary&amp;gt;
## &amp;lt;param name=&amp;quot;domain&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      The type of the process to transition to
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
## &amp;lt;param name=&amp;quot;entrypoint&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      The type of the file used as an entrypoint to this domain
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
#
interface(`incron_entry&amp;#39;,`
        gen_require(`
                type incrond_t;
        &amp;#39;)

        domtrans_pattern(incrond_t, $2, $1)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this in place, the &lt;em&gt;foo&lt;/em&gt; SELinux module can call
&lt;em&gt;incron_entry(foo_t, foo_exec_t)&lt;/em&gt; so that, the moment &lt;code&gt;incrond_t&lt;/code&gt;
executes a file with label &lt;code&gt;foo_exec_t&lt;/code&gt;, the resulting process will run
in &lt;code&gt;foo_t&lt;/code&gt;. I am going to &lt;em&gt;test&lt;/em&gt; (and I stress that it is only for
&lt;em&gt;testing&lt;/em&gt;) this by assigning &lt;em&gt;incron_entry(system_cronjob_t,
shell_exec_t)&lt;/em&gt;, making every shell script being called run in
&lt;code&gt;system_cronjob_t&lt;/code&gt; domain (for instance in the &lt;code&gt;localuser.te&lt;/code&gt; file that
already assigned &lt;em&gt;incron_role&lt;/em&gt; to the &lt;code&gt;user_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;With that in place, it's time to start our iterations again.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# run_init rc-service incrond start
* start-stop-daemon: failed to start &amp;#39;/usr/sbin/incrond&amp;#39; [ !! ]
* ERROR: incrond failed to start

# tail audit.log
type=AVC msg=audit(1368732494.275:28319): avc:  denied  { read } for  pid=9282 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;localtime&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393663 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:locale_t tclass=file
type=AVC msg=audit(1368732494.275:28320): avc:  denied  { create } for  pid=9282 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732494.276:28321): avc:  denied  { read } for  pid=9282 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;incron.d&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394140 scontext=system_u:system_r:incrond_t tcontext=root:object_r:incron_spool_t tclass=dir
type=AVC msg=audit(1368732494.276:28322): avc:  denied  { create } for  pid=9282 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732494.276:28323): avc:  denied  { create } for  pid=9282 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ignoring the &lt;em&gt;unix_dgram_socket&lt;/em&gt; for now, we need to allow &lt;code&gt;incrond_t&lt;/code&gt;
to read locale information, and to read the files in the
&lt;code&gt;/var/spool/incron&lt;/code&gt; location (this goes in &lt;code&gt;incron.te&lt;/code&gt; again):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrond policy
#

read_files_pattern(incrond_t, incron_spool_t, incron_spool_t)

files_search_spool(incrond_t)

miscfiles_read_localization(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The next run fails again, with the following denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368732806.757:28328): avc:  denied  { create } for  pid=9419 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732806.757:28329): avc:  denied  { read } for  pid=9419 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;incron.d&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394140 scontext=system_u:system_r:incrond_t tcontext=root:object_r:incron_spool_t tclass=dir
type=AVC msg=audit(1368732806.757:28330): avc:  denied  { create } for  pid=9419 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368732806.757:28331): avc:  denied  { create } for  pid=9419 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So although &lt;code&gt;incrond_t&lt;/code&gt; has search rights on the &lt;code&gt;incron_spool_t&lt;/code&gt;
directories (through the &lt;code&gt;read_files_pattern&lt;/code&gt;), we need to grant it
&lt;em&gt;list_dir_perms&lt;/em&gt; as well (which contains the &lt;em&gt;read&lt;/em&gt; permission). As
&lt;em&gt;list_dir_perms&lt;/em&gt; contains search anyhow, we can just update the line
with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t incron_spool_t:dir list_dir_perms;
allow incrond_t incron_spool_t:file read_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the startup seems to work, but we still get denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# run_init rc-service incrond start
* Starting incrond... [ ok ]

# ps -eZ | grep incrond
# tail /var/log/cron.log
(nothing)

# tail audit.log
type=AVC msg=audit(1368733443.799:28340): avc:  denied  { create } for  pid=9551 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368733443.802:28341): avc:  denied  { write } for  pid=9552 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=1970 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_run_t tclass=dir
type=AVC msg=audit(1368733443.806:28342): avc:  denied  { create } for  pid=9552 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
type=AVC msg=audit(1368733443.806:28343): avc:  denied  { create } for  pid=9552 comm=&amp;quot;incrond&amp;quot; scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=unix_dgram_socket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Those &lt;em&gt;unix_dgram_sockets&lt;/em&gt; are here again. But seeing that &lt;code&gt;cron.log&lt;/code&gt;
is empty, and &lt;em&gt;logging_send_syslog_msg&lt;/em&gt; is one of the interfaces that
would enable it, we might want to do just that so that we get more
information about why &lt;strong&gt;incrond&lt;/strong&gt; doesn't properly start. Also, it tries
to write into &lt;code&gt;var_run_t&lt;/code&gt; labeled directories, probably for its PID
file, so add in a proper file transition as well as manage rights:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type incrond_var_run_t;
files_pid_file(incrond_var_run_t)
...
allow incrond_t incrond_var_run_t:file manage_file_perms;
files_pid_filetrans(incrond_t, incrond_var_run_t, file)
...
logging_send_syslog_msg(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that in place:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# run_init rc-service incrond start
* Starting incrond... [ ok ]

# ps -eZ | grep incron
system_u:system_r:incrond_t      9648 ?        00:00:00 incrond

# tail /var/log/cron.log 
May 16 21:51:34 test incrond[9647]: starting service (version 0.5.10, built on May 16 2013 12:11:29)
May 16 21:51:34 test incrond[9648]: loading system tables
May 16 21:51:34 test incrond[9648]: loading user tables
May 16 21:51:34 test incrond[9648]: table for invalid user user found (ignored)
May 16 21:51:34 test incrond[9648]: ready to process filesystem events

# tail audit.log
type=AVC msg=audit(1368733894.641:28347): avc:  denied  { read } for  pid=9648 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;nsswitch.conf&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393768 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:etc_t tclass=file
type=AVC msg=audit(1368733894.645:28349): avc:  denied  { read } for  pid=9648 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;passwd&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394223 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:etc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It looks like we're getting there. Similar as with &lt;strong&gt;incrontab&lt;/strong&gt; we
allow &lt;em&gt;auth_use_nsswitch&lt;/em&gt; as well, and then get:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 16 21:55:10 test incrond[9715]: starting service (version 0.5.10, built on May 16 2013 12:11:29)
May 16 21:55:10 test incrond[9716]: loading system tables
May 16 21:55:10 test incrond[9716]: loading user tables
May 16 21:55:10 test incrond[9716]: loading table for user user
May 16 21:55:10 test incrond[9716]: access denied on /home/user/test2 - events will be discarded silently
May 16 21:55:10 test incrond[9716]: cannot create watch for user user: (13) Permission denied
May 16 21:55:10 test incrond[9716]: ready to process filesystem events

# tail audit.log
type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/home/user/test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
type=AVC msg=audit(1368734110.913:28354): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What happens is that &lt;strong&gt;incrond&lt;/strong&gt; read the (user) crontab, found that it
had to "watch" &lt;code&gt;/home/user/test2&lt;/code&gt; but fails because SELinux doesn't
allow it to do so. We could just allow that, but we might do it a bit
better by looking into what we want it to do in a flexible manner...
next time ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="incrond"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: new types and transitions</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-new-types-and-transitions/" rel="alternate"></link><published>2013-05-26T03:50:00+02:00</published><updated>2013-05-26T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-26:/2013/05/a-selinux-policy-for-incron-new-types-and-transitions/</id><summary type="html">&lt;p&gt;So I've shown the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/"&gt;iterative approach
used&lt;/a&gt;
to develop policies. Again, please be aware that this is my way of
developing policies, other policy developers might have a different
approach. We were working on the &lt;strong&gt;incrontab&lt;/strong&gt; command, so let's
continue with trying to create a new user incrontab:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;So I've shown the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/"&gt;iterative approach
used&lt;/a&gt;
to develop policies. Again, please be aware that this is my way of
developing policies, other policy developers might have a different
approach. We were working on the &lt;strong&gt;incrontab&lt;/strong&gt; command, so let's
continue with trying to create a new user incrontab:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
cannot create temporary file: Permission denied

# tail audit.log
type=AVC msg=audit(1368709633.285:28211): avc:  denied  { setgid } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; capability=6  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368709633.285:28212): avc:  denied  { setuid } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; capability=7  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368709633.287:28213): avc:  denied  { search } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=3927 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:tmp_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The requests for the setuid and setgid capabilities are needed for the
application to safely handle the user incrontabs. Note that SELinux does
not "remove" the setuid bit on the binary itself, but does govern the
related capabilities. Since this is required, we will add these
capabilities to the policy. We also notice that &lt;strong&gt;incrontab&lt;/strong&gt; searched
in the &lt;code&gt;/tmp&lt;/code&gt; location.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t self:capability { setuid setgid };
...
files_search_tmp(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the next round of iteration, we notice the same error message with
the following denial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368728433.521:28215): avc:  denied  { write } for  pid=8913 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=3927 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:tmp_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It is safe to assume here that the process wants to create a temporary
file (if it is a directory, we will find out later and can adapt). But
when temporary files are created, we better make those files a specific
type, like &lt;code&gt;incrontab_tmp_t&lt;/code&gt;. So we define that on top of the policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type incrontab_tmp_t;
files_tmp_file(incrontab_tmp_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Also, we need to allow the &lt;code&gt;incrontab_t&lt;/code&gt; domain write privileges into
the &lt;code&gt;tmp_t&lt;/code&gt; labeled directory, but with an automatic file transition
towards &lt;code&gt;incrontab_tmp_t&lt;/code&gt; for every file written. This is done through
the &lt;em&gt;files_tmp_filetrans&lt;/em&gt; method:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;files_tmp_filetrans(incrontab_t, incrontab_tmp_t, file)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What this sais is that, if a domain &lt;code&gt;incrontab_t&lt;/code&gt; wants to create a
&lt;code&gt;file&lt;/code&gt; inside &lt;code&gt;tmp_t&lt;/code&gt;, then this file is automatically labeled
&lt;code&gt;incrontab_tmp_t&lt;/code&gt;. With SELinux, you can make this more precise: if you
know what the file name would be, then you can add that as a fourth
argument. However, this does not seem necessary now since we definitely
want all files created in &lt;code&gt;tmp_t&lt;/code&gt; to become &lt;code&gt;incrontab_tmp_t&lt;/code&gt;. All that
rests us is to allow &lt;strong&gt;incrontab&lt;/strong&gt; to actually manage those files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t incrontab_tmp_t:file manage_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With those in place, let's look at the outcome:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
editor finished with error: No such file or directory

# tail audit.log
type=AVC msg=audit(1368729268.465:28217): avc:  denied  { search } for  pid=8981 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;bin&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=524289 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:bin_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Considering that here, &lt;strong&gt;incrontab&lt;/strong&gt; is going to launch the users
&lt;code&gt;$EDITOR&lt;/code&gt; application to allow him (or her) to create an incrontab, we
need to allow &lt;code&gt;incrontab_t&lt;/code&gt; not only search privileges inside &lt;code&gt;bin_t&lt;/code&gt;
directories, but also execute rights:
&lt;em&gt;corecmd_exec_bin(incrontab_t)&lt;/em&gt;. We choose here to execute the editor
inside the existing domain (&lt;code&gt;incrontab_t&lt;/code&gt;) instead of creating a
different domain for the editor for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If we would create a separate domain for the editor, the editor
    would eventually need to have major permissions, depending on when
    it is used. Editors can be used to modify the sudoers files, passwd
    files, the &lt;code&gt;/etc/selinux/config&lt;/code&gt; file, etc. Instead, it makes much
    more sense to just be able to launch the editor in the current
    domain (which is much more confined to its specific purpose)&lt;/li&gt;
&lt;li&gt;The additional privileges needed to launch the editor are usually
    very slim, or even nonexistent. It generally only makes sense if, by
    executing it, the existing domain would need many more privileges,
    because then a new (confined) domain keeps the privileges for the
    current domain low.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's see if things work now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
(Editor opened, so I added in an incrontab line. Upon closing:)
cannot move temporary table: Permission denied

# tail audit.log
type=AVC msg=audit(1368729825.673:28237): avc:  denied  { dac_read_search } for  pid=9030 comm=&amp;quot;incrontab&amp;quot; capability=2  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368729825.673:28237): avc:  denied  { dac_override } for  pid=9030 comm=&amp;quot;incrontab&amp;quot; capability=1  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From a quick look through &lt;strong&gt;ps&lt;/strong&gt;, I notice that the application runs as
the user (luckily, otherwise I could use the editor to escape and get a
root shell) after which it tries to do something. Of course, it makes
sense that it wants to move this newly created incrontab file somewhere
in &lt;code&gt;/var/spool/incron&lt;/code&gt; so we grant it the permission to
&lt;code&gt;dac_read_search&lt;/code&gt; (which is lower than &lt;code&gt;dac_override&lt;/code&gt; as &lt;a href="http://blog.siphos.be/2013/05/the-weird-audit_access-permission/"&gt;explained
before&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t self:capability { dac_read_search setuid setgid };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On to the next failure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e 
cannot move temporary table: Permission denied

# tail audit.log
type=AVC msg=audit(1368730155.706:28296): avc:  denied  { write } for  pid=9088 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;incron&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=19725 scontext=user_u:user_r:incrontab_t tcontext=root:object_r:incron_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the application wants to write this file there. Now remember we
already have &lt;code&gt;search_dir_perms&lt;/code&gt; permissions into &lt;code&gt;incron_spool_t&lt;/code&gt;? We
need to expand those with read/write permissions into the directory, and
manage permissions on files (manage because users should be able to
create, modify and delete their files). These two permissions are
combined in the &lt;em&gt;manage_files_pattern&lt;/em&gt; interface, and makes the search
one obsolete:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;manage_files_pattern(incrontab_t, incron_spool_t, incron_spool_t)

$ incrontab -e
...
table updated
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally! And looking at the other options in &lt;strong&gt;incrontab&lt;/strong&gt;, it seems
that the policy for &lt;code&gt;incrontab_t&lt;/code&gt; is finally complete, and looks like
so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrontab policy
#

allow incrontab_t self:capability { setuid setgid dac_read_search };

manage_files_pattern(incrontab_t, incron_spool_t, incron_spool_t)

allow incrontab_t incrontab_tmp_t:file manage_file_perms;
files_tmp_filetrans(incrontab_t, incrontab_tmp_t, file)

corecmd_exec_bin(incrontab_t)

domain_use_interactive_fds(incrontab_t)

files_search_spool(incrontab_t)
files_search_tmp(incrontab_t)

auth_use_nsswitch(incrontab_t)

userdom_use_user_terminals(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next on the agenda: the &lt;code&gt;incrond_t&lt;/code&gt; domain.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: basic set for incrontab</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/" rel="alternate"></link><published>2013-05-25T03:50:00+02:00</published><updated>2013-05-25T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-25:/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/</id><summary type="html">&lt;p&gt;Now that our &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/"&gt;regular user is
allowed&lt;/a&gt;
to execute &lt;strong&gt;incrontab&lt;/strong&gt;, let's fire it up and look at the denials to
build up the policy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That doesn't show much does it? Well, if you look into the &lt;code&gt;audit.log&lt;/code&gt;
(or &lt;code&gt;avc.log&lt;/code&gt;) file, you'll notice a lot of denials &lt;/p&gt;</summary><content type="html">&lt;p&gt;Now that our &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/"&gt;regular user is
allowed&lt;/a&gt;
to execute &lt;strong&gt;incrontab&lt;/strong&gt;, let's fire it up and look at the denials to
build up the policy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That doesn't show much does it? Well, if you look into the &lt;code&gt;audit.log&lt;/code&gt;
(or &lt;code&gt;avc.log&lt;/code&gt;) file, you'll notice a lot of denials. If you are
developing a policy, it is wise to clear the entire log and reproduce
the "situation" so you get a proper idea of the scope.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# cd /var/log/audit
# &amp;gt; audit.log
# tail -f audit.log | grep AVC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now let's run &lt;strong&gt;incrontab --help&lt;/strong&gt; again and look at the denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368707274.429:28180): avc:  denied  { read write } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=user_u:object_r:user_tty_device_t tclass=chr_file
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can start piping this information into &lt;strong&gt;audit2allow&lt;/strong&gt; to generate
policy statements, but I personally prefer not to use &lt;strong&gt;audit2allow&lt;/strong&gt;
for building new policies. For one, it is not intelligent enough to
deduce if a denial should be fixed by allowing it, or by relabeling or
even by creating a new type. Instead, it always grants it. Second, it
does not know if a denial is cosmetic (and thus can be ignored) or not.&lt;/p&gt;
&lt;p&gt;This latter is also why I don't run domains in permissive mode to see
the majority of denials first and to build from those: you might see
denials that are actually never triggered when running in enforcing
mode. So let's look at the access to &lt;code&gt;/dev/tty2&lt;/code&gt;. Given that this is a
user application where we expect output to the screen, we want to grant
it the proper access. With &lt;strong&gt;sefindif&lt;/strong&gt; as
&lt;a href="http://blog.siphos.be/2013/05/commandline-selinux-policy-helper-functions/"&gt;documented&lt;/a&gt;
before, we can look for the proper interfaces we need. I look for
&lt;code&gt;user_tty_device_t&lt;/code&gt; with &lt;code&gt;rw&lt;/code&gt; (commonly used for read-write):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif user_tty_device_t.*rw
system/userdomain.if: template(`userdom_base_user_template&amp;#39;,`
system/userdomain.if:   allow $1_t user_tty_device_t:chr_file { setattr rw_chr_file_perms };
system/userdomain.if: interface(`userdom_use_user_ttys&amp;#39;,`
system/userdomain.if:   allow $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_use_user_terminals&amp;#39;,`
system/userdomain.if:   allow $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_dontaudit_use_user_terminals&amp;#39;,`
system/userdomain.if:   dontaudit $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_dontaudit_use_user_ttys&amp;#39;,`
system/userdomain.if:   dontaudit $1 user_tty_device_t:chr_file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Two of these look interesting: &lt;em&gt;userdom_use_user_ttys&lt;/em&gt; and
&lt;em&gt;userdom_use_user_terminals&lt;/em&gt;. Looking at the API documentation (or
the rules defined therein using &lt;strong&gt;seshowif&lt;/strong&gt;) reveals that
&lt;em&gt;userdom_use_user_terminals&lt;/em&gt; is needed if you also want the
application to work when invoked through a devpts terminal, which is
probably also something our user(s) want to do, so we'll add that. The
second one - using the file descriptor that has the &lt;code&gt;getty_t&lt;/code&gt; context -
is related to this, but not granted through the
&lt;em&gt;userdom_use_user_ttys&lt;/em&gt;. We could grant &lt;em&gt;getty_use_fds&lt;/em&gt; but my
experience tells me that &lt;em&gt;domain_use_interactive_fds&lt;/em&gt; is more likely
to be needed: the application inherits and uses a file descriptor
currently owned by &lt;code&gt;getty_t&lt;/code&gt; but it could be from any of the other
domains that has such file descriptors. For instance, if you grant the
&lt;em&gt;incron_role&lt;/em&gt; to &lt;code&gt;sysadm_r&lt;/code&gt;, then a user that switched roles through
&lt;strong&gt;newrole&lt;/strong&gt; will see denials for using a file descriptor owned by
&lt;code&gt;newrole_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Experience is an important aspect in developing policies. If you would
go through with &lt;em&gt;getty_use_fds&lt;/em&gt; it would work as well, and you'll
probably hit the above mentioned experience later when you try the
application through a few different paths (such as within a screen
session or so). When you &lt;em&gt;think&lt;/em&gt; that the target context (in this case
&lt;code&gt;getty_t&lt;/code&gt;) could be a placeholder (so other types are likely to be
needed as well), make sure you check which attributes are assigned to
the type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seinfo -tgetty_t -x
   getty_t
      privfd
      mcssetcats
      mlsfileread
      mlsfilewrite
      application_domain_type
      domain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of the above ones, &lt;code&gt;privfd&lt;/code&gt; is the important one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif privfd.*use
kernel/domain.if: interface(`domain_use_interactive_fds&amp;#39;,`
kernel/domain.if:       allow $1 privfd:fd use;
kernel/domain.if: interface(`domain_dontaudit_use_interactive_fds&amp;#39;,`
kernel/domain.if:       dontaudit $1 privfd:fd use;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So let's update &lt;code&gt;incron.te&lt;/code&gt; accordingly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
type incron_spool_t;
files_type(incron_spool_t)

###########################################
#
# incrontab policy
#

userdom_use_user_terminals(incrontab_t)
domain_use_interactive_fds(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Rebuild the policy and load it in memory.&lt;/p&gt;
&lt;p&gt;If we now run &lt;strong&gt;incrontab&lt;/strong&gt; we get the online help as we expected. Let's
now look at the currently installed incrontabs (there shouldn't be any
of course):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot determine current user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the denials, we notice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368708632.060:28192): avc:  denied  { create } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=unix_stream_socket
type=AVC msg=audit(1368708632.060:28194): avc:  denied  { read } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;nsswitch.conf&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393768 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:etc_t tclass=file
type=AVC msg=audit(1368708632.062:28196): avc:  denied  { read } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;passwd&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394223 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:etc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's first focus on &lt;code&gt;nsswitch.conf&lt;/code&gt; and &lt;code&gt;passwd&lt;/code&gt;. Although both require
read access to &lt;code&gt;etc_t&lt;/code&gt; files, it might be wrong to just add in
&lt;em&gt;files_read_etc&lt;/em&gt; (which is what &lt;strong&gt;audit2allow&lt;/strong&gt; is probably going to
suggest). For nsswitch, there is a special interface available:
&lt;em&gt;auth_use_nsswitch&lt;/em&gt;. It is very, very likely that you'll need this
one, especially if you want to share the policy with others who might
not have all of the system databases in local files (as &lt;code&gt;etc_t&lt;/code&gt; files).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
domain_use_interactive_fds(incrontab_t)
auth_use_nsswitch(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's retry:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot read table for &amp;#39;user&amp;#39;: Permission denied

# tail audit.log
type=AVC msg=audit(1368708893.260:28199): avc:  denied  { search } for  pid=7997 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;spool&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=20 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:var_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So we need to grant search privileges on &lt;code&gt;var_spool_t&lt;/code&gt;. This is offered
through &lt;em&gt;files_search_spool&lt;/em&gt;. Add it to the policy, rebuild and retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot read table for &amp;#39;user&amp;#39;: Permission denied

# tail audit.log
type=AVC msg=audit(1368709146.426:28201): avc:  denied  { search } for  pid=8046 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;incron&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=19725 scontext=user_u:user_r:incrontab_t tcontext=root:object_r:incron_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For this one, no interface exists yet. We might be able to create one
for ourselves, but as long as other domains don't need it, we can just
add it locally in our policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t incron_spool_t:dir search_dir_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Adding raw allow rules in a policy is, according to the &lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide"&gt;refpolicy
styleguide&lt;/a&gt;,
only allowed if the policy module defines both the source and the
destination type of the rule. If you look into other policies you might
also find that you can use the &lt;em&gt;search_dirs_patter&lt;/em&gt; call. However,
that one only makes sense if you need to do this on top of another
directory - just look at the definition of &lt;em&gt;search_dirs_pattern&lt;/em&gt;. So
with this permission set, let's retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
no table for user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Great, we have successfully updated the policy until the commands
worked. In the next post, we'll enhance it even further while creating
new incrontabs.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="incrontab"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: the basic skeleton</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/" rel="alternate"></link><published>2013-05-23T03:50:00+02:00</published><updated>2013-05-23T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-23:/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/</id><summary type="html">&lt;p&gt;So, in the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/"&gt;previous
post&lt;/a&gt;
I talked about &lt;em&gt;incron&lt;/em&gt; and why I think moving it into the existing cron
policy would not be a good idea. It works, somewhat, but is probably not
that future-proof. So we're going to create our own policy for it.&lt;/p&gt;
&lt;p&gt;In SELinux, policies are generally &lt;/p&gt;</summary><content type="html">&lt;p&gt;So, in the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/"&gt;previous
post&lt;/a&gt;
I talked about &lt;em&gt;incron&lt;/em&gt; and why I think moving it into the existing cron
policy would not be a good idea. It works, somewhat, but is probably not
that future-proof. So we're going to create our own policy for it.&lt;/p&gt;
&lt;p&gt;In SELinux, policies are generally written through 3 files:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a &lt;em&gt;type enforcement&lt;/em&gt; file that contains the SELinux rules applicable
    to the domain(s) related to the application (in our example,
    &lt;em&gt;incron&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;file context&lt;/em&gt; file that tells the SELinux utilities how the files
    and directories offered by the application should be labeled&lt;/li&gt;
&lt;li&gt;an &lt;em&gt;interface definition&lt;/em&gt; file that allows other SELinux policy
    modules to gain rights offered through the (to be written) &lt;em&gt;incron&lt;/em&gt;
    policy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We now need to create a skeleton for the policy. This skeleton will
define the types related to the application. Such types can be the
domains for the processes (the context of the &lt;strong&gt;incrond&lt;/strong&gt; and perhaps
also &lt;strong&gt;incrontab&lt;/strong&gt; applications), the contexts for the directories (if
any) and files, etc.&lt;/p&gt;
&lt;p&gt;So let's take a look at the content of the &lt;em&gt;incron&lt;/em&gt; package. On Gentoo,
we can use &lt;strong&gt;qlist incron&lt;/strong&gt; for this. In the output of &lt;strong&gt;qlist&lt;/strong&gt;, I
added comments to show you how contexts can be (easily) deduced.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Application binary for managing user crontabs. We want to give this a specific
# context because we want the application (which will manage the incrontabs in
# /var/spool/incron) in a specific domain
/usr/bin/incrontab  ## incrontab_exec_t

# General application information files, do not need specific attention
# (the default context is fine)
/usr/share/doc/incron-0.5.10/README.bz2
/usr/share/doc/incron-0.5.10/TODO.bz2
/usr/share/doc/incron-0.5.10/incron.conf.example.bz2
/usr/share/doc/incron-0.5.10/CHANGELOG.bz2
/usr/share/man/man8/incrond.8.bz2
/usr/share/man/man5/incron.conf.5.bz2
/usr/share/man/man5/incrontab.5.bz2
/usr/share/man/man1/incrontab.1.bz2

# Binary for the incrond daemon. This definitely needs its own context, since
# it will be launched from an init script and we do not want it to run in the
# initrc_t domain.
/usr/sbin/incrond ## incrond_exec_t

# This is the init script for the incrond daemon. If we want to allow 
# some users the rights to administer incrond without needing to grant
# those users the sysadm_r role, we need to give this file a different
# context as well.
/etc/init.d/incrond ## incrond_initrc_exec_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this information at hand, and the behavior of the application we
know from the previous post, can lead to the following &lt;code&gt;incron.fc&lt;/code&gt; file,
which defines the file contexts for the application.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/incron.d(/.*)?     gen_context(system_u:object_r:incron_spool_t,s0)

/etc/rc\.d/init\.d/incrond      --      gen_context(system_u:object_r:incrond_initrc_exec_t,s0)

/usr/bin/incrontab      --      gen_context(system_u:object_r:incrontab_exec_t,s0)

/usr/sbin/incrond       --      gen_context(system_u:object_r:incrond_exec_t,s0)

/var/spool/incron(/.*)?         gen_context(system_u:object_r:incron_spool_t,s0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The syntax of this file closely follows the syntax that &lt;strong&gt;semanage
fcontext&lt;/strong&gt; takes - at least for the regular expressions in the
beginning. The last column is specifically for policy development to
generate a context based on the policies' requirements: an MCS/MLS
enabled policy will get the trailing sensitivity with it, but when
MCS/MLS is disabled then it is dropped. The middle column is to specify
if the label should only be set on regular files (&lt;code&gt;--&lt;/code&gt;), directories
(&lt;code&gt;-d&lt;/code&gt;), sockets (&lt;code&gt;-s&lt;/code&gt;), symlinks (&lt;code&gt;-l&lt;/code&gt;), etc. If it is omitted, it
matches whatever class the path matches.&lt;/p&gt;
&lt;p&gt;The second file needed for the skeleton is the &lt;code&gt;incron.te&lt;/code&gt; file, which
would look like so. I added in inline comments here to explain why
certain lines are prepared, but generally this is omitted when the
policy is &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;upstreamed&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(incron, 0.1)
# The above line declares that this file is a SELinux policy file. Its name
# is incron, so the file should saved as incron.te

# First, we declare the incrond_t domain, used for the &amp;quot;incrond&amp;quot; process.
# Because it is launched from an init script, we tell the policy that
# incrond_exec_t (the context of incrond), when launched from init, should
# transition to incrond_t.
#
# Basically, the syntax here is:
# type 
# type 
# 
type incrond_t;
type incrond_exec_t;
init_daemon_domain(incrond_t, incrond_exec_t)

# Next we declare that the incrond_initrc_exec_t is an init script context
# so that init can execute it (remember, SELinux is a mandatory access control
# system, so if we do not tell that init can execute it, it won&amp;#39;t).
type incrond_initrc_exec_t;
init_script_file(incrond_initrc_exec_t)

# We also create the incrontab_t domain (for the &amp;quot;incrontab&amp;quot; application), which
# is triggered through the incrontab_exec_t labeled file. This again follows a bit
# the syntax as we used above, but now the interface call is &amp;quot;application_domain&amp;quot;.
type incrontab_t;
type incrontab_exec_t;
application_domain(incrontab_t, incrontab_exec_t)

# Finally we declare the spool type as well (incron_spool_t) and tell SELinux that
# it will be used for regular files.
type incron_spool_t;
files_type(incron_spool_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Knowing which interface calls, like &lt;em&gt;init_daemon_domain&lt;/em&gt; and
&lt;em&gt;application_domain&lt;/em&gt;, we should use is not obvious at first. Most of
this can be gathered from existing policies. Other frequently occurring
interfaces to be used immediately at the skeleton side are (examples for
a &lt;code&gt;foo_t&lt;/code&gt; domain):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;logging_log_file(foo_log_t)&lt;/em&gt; to inform SELinux that the context
    is used for logging purposes. This allows generic log-related
    daemons to do "their thing" with the file.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_tmp_file(foo_tmp_t)&lt;/em&gt; to identify the context as being
    used for temporary files&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_tmpfs_file(foo_tmpfs_t)&lt;/em&gt; for tmpfs files (which could be
    shared memory)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_pid_file(foo_var_run_t)&lt;/em&gt; for PID files (and other run
    metadata files)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_config_file(foo_conf_t)&lt;/em&gt; for configuration files (often
    within &lt;code&gt;/etc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_lock_file(foo_lock_t)&lt;/em&gt; for lock files (often within
    &lt;code&gt;/run/lock&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We might be using these later as we progress with the policy (for
instance, the PID file is a very high candidate for needing to be
included). However, with the information currently at hand, we have our
first policy module ready for building. Save the type enforcement rules
in &lt;code&gt;incron.te&lt;/code&gt; and the file contexts in &lt;code&gt;incron.fc&lt;/code&gt; and you can then
build the SELinux policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile incron.pp
# semodule -i incron.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On Gentoo, you can then relabel the files and directories offered
through the package using &lt;strong&gt;rlpkg&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# rlpkg incron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next is to start looking at the &lt;strong&gt;incrontab&lt;/strong&gt; application.&lt;/p&gt;</content><category term="SELinux"></category><category term="fc"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category><category term="skeleton"></category><category term="te"></category></entry><entry><title>A SELinux policy for incron: what does it do?</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/" rel="alternate"></link><published>2013-05-22T03:50:00+02:00</published><updated>2013-05-22T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-22:/2013/05/a-selinux-policy-for-incron-what-does-it-do/</id><summary type="html">&lt;p&gt;In this series of posts, we'll go through the creation of a SELinux
policy for
&lt;a href="http://inotify.aiken.cz/?section=incron&amp;amp;page=doc=en"&gt;incron&lt;/a&gt;, a simple
inotify based cron-like application. I will talk about the various steps
that I would take in the creation of this policy, and give feedback when
certain decisions are taken and why. At &lt;/p&gt;</summary><content type="html">&lt;p&gt;In this series of posts, we'll go through the creation of a SELinux
policy for
&lt;a href="http://inotify.aiken.cz/?section=incron&amp;amp;page=doc=en"&gt;incron&lt;/a&gt;, a simple
inotify based cron-like application. I will talk about the various steps
that I would take in the creation of this policy, and give feedback when
certain decisions are taken and why. At the end of the series, we'll
have a hopefully well working policy.&lt;/p&gt;
&lt;p&gt;The first step in developing a policy is to know what the application
does and how/where it works. This allows us to check if its behavior
matches an existing policy (and as such might be best just added to this
policy) or if a new policy needs to be written. So, what does incron do?&lt;/p&gt;
&lt;p&gt;From the documentation, we know that &lt;em&gt;incron&lt;/em&gt; is a cron-like application
that, unlike cron, works with file system notification events instead of
time-related events. Other than that, it uses a similar way of working:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A daemon called &lt;strong&gt;incrond&lt;/strong&gt; is the run-time application that reads
    in the &lt;em&gt;incrontab&lt;/em&gt; files and creates the proper inotify watches.
    When a watch is triggered, it will execute the matching rule.&lt;/li&gt;
&lt;li&gt;The daemon looks at two definitions (incrontabs): one system-wide
    (in &lt;code&gt;/etc/incron.d&lt;/code&gt;) and one for users (in &lt;code&gt;/var/spool/incron&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The user tabfiles are managed through &lt;strong&gt;incrontab&lt;/strong&gt; (the command)&lt;/li&gt;
&lt;li&gt;Logging is done through syslog&lt;/li&gt;
&lt;li&gt;User commands are executed with the users' privileges (so the
    application calls &lt;em&gt;setuid()&lt;/em&gt; and &lt;em&gt;setgid()&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this, one can create a script to be executed when a file is
uploaded (or deleted) to/from a file server, or when a process coredump
occurred, or whatever automation you want to trigger when some file
system event occurred. Events are plenty and can be found in
&lt;code&gt;/usr/include/sys/inotify.h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, with this information, it is safe to assume that we might be able to
push incron in the existing &lt;em&gt;cron&lt;/em&gt; policy. After all, it defines the
contexts for all these and probably doesn't need any additional
tweaking. And this seems to work at first, but a few tests reveal that
the behavior is not that optimal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# chcon -t crond_exec_t /usr/sbin/incrond
# chcon -t crontab_exec_t /usr/bin/incrontab
# chcon -R -t system_cron_spool_t /etc/incron.d
# chcon -t cron_log_t /var/log/cron.log
# chcon -R -t cron_spool_t /var/spool/incron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;System tables work somewhat, but all commands are executed in the
&lt;code&gt;crond_t&lt;/code&gt; domain, not in a &lt;code&gt;system_cronjob_t&lt;/code&gt; or related domain.&lt;br&gt;
User tables fail when dealing with files in the users directories,
since these too run in &lt;code&gt;crond_t&lt;/code&gt; and thus have no read access to the
user home directories.&lt;/p&gt;
&lt;p&gt;The problems we notice come from the fact that the application is very
simple in its code: it is not SELinux-aware (so it doesn't change the
runtime context) as most cron daemons are, and when it changes the user
id it does not call PAM, so we cannot trigger &lt;code&gt;pam_selinux.so&lt;/code&gt; to handle
context changes either. As a result, the entire daemon keeps running in
&lt;code&gt;crond_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is one reason why a separate domain could be interesting: we might
want to extend the rights of the daemon domain a bit, but don't want to
extend these rights to the other cron daemons (who also run in
&lt;code&gt;crond_t&lt;/code&gt;). Another reason is that the cron policy has a few booleans
that would not affect the behavior at all, making it less obvious for
users to troubleshoot. As a result, we'll go for the separate policy
instead - which will be for the next post.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Why oh why does a process run in unlabeled_t?</title><link href="https://blog.siphos.be/2013/05/why-oh-why-does-a-process-run-in-unlabeled_t/" rel="alternate"></link><published>2013-05-21T03:50:00+02:00</published><updated>2013-05-21T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-21:/2013/05/why-oh-why-does-a-process-run-in-unlabeled_t/</id><summary type="html">&lt;p&gt;If you notice that a process is running in the &lt;code&gt;unlabeled_t&lt;/code&gt; domain, the
first question to ask is how it got there.&lt;/p&gt;
&lt;p&gt;Well, one way is to have a process running in a known domain, like
&lt;code&gt;screen_t&lt;/code&gt;, after which the SELinux policy module that provides this
domain is removed from &lt;/p&gt;</summary><content type="html">&lt;p&gt;If you notice that a process is running in the &lt;code&gt;unlabeled_t&lt;/code&gt; domain, the
first question to ask is how it got there.&lt;/p&gt;
&lt;p&gt;Well, one way is to have a process running in a known domain, like
&lt;code&gt;screen_t&lt;/code&gt;, after which the SELinux policy module that provides this
domain is removed from the system (or updated and the update does not
contain the &lt;code&gt;screen_t&lt;/code&gt; definition anymore):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test ~ # ps -eZ | grep screen
root:sysadm_r:sysadm_screen_t    5047 ?        00:00:00 screen
test ~ # semodule -r screen
test ~ # ps -eZ | grep screen
system_u:object_r:unlabeled_t    5047 ?        00:00:00 screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In permissive mode, this will be visible easily; in enforcing mode, the
domains you are running in might not be allowed to do anything with
&lt;code&gt;unlabeled_t&lt;/code&gt; files, directories and processes, so &lt;strong&gt;ps&lt;/strong&gt; might not show
it even though it still exists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test audit # ps -eZ | grep 5047
test audit # ls -dZ /proc/5047
ls: cannot access /proc/5047: Permission denied
test audit # tail audit.log | grep unlabeled
type=AVC msg=audit(1368698097.494:27806): avc:  denied  { getattr } for  pid=4137 comm=&amp;quot;bash&amp;quot; path=&amp;quot;/proc/5047&amp;quot; dev=&amp;quot;proc&amp;quot; ino=6677 scontext=root:sysadm_r:sysadm_t tcontext=system_u:object_r:unlabeled_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that, if you reload the module, the process becomes visible
again. That is because the process context itself (&lt;code&gt;screen_t&lt;/code&gt;) is
retained, but because the policy doesn't know it anymore, it shows it as
&lt;code&gt;unlabeled_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Basically, the moment the policy doesn't know how a label would be
(should be), it uses &lt;code&gt;unlabeled_t&lt;/code&gt;. The SELinux policy then defines how
this &lt;code&gt;unlabeled_t&lt;/code&gt; domain is handled. Processes getting into
&lt;code&gt;unlabeled_t&lt;/code&gt; is not that common though as there is no supported
transition to it. The above one is one way that this still can occur.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="selinux"></category><category term="unlabeled"></category></entry><entry><title>The weird "audit_access" permission</title><link href="https://blog.siphos.be/2013/05/the-weird-audit_access-permission/" rel="alternate"></link><published>2013-05-19T03:50:00+02:00</published><updated>2013-05-19T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-19:/2013/05/the-weird-audit_access-permission/</id><summary type="html">&lt;p&gt;While writing up the posts on capabilities, one thing I had in my mind
was to give some additional information on frequently occurring denials,
such as the &lt;em&gt;dac_override&lt;/em&gt; and &lt;em&gt;dac_read_search&lt;/em&gt; capabilities, and
when they are triggered. For the DAC-related capabilities, policy
developers often notice that these capabilities are triggered without &lt;/p&gt;</summary><content type="html">&lt;p&gt;While writing up the posts on capabilities, one thing I had in my mind
was to give some additional information on frequently occurring denials,
such as the &lt;em&gt;dac_override&lt;/em&gt; and &lt;em&gt;dac_read_search&lt;/em&gt; capabilities, and
when they are triggered. For the DAC-related capabilities, policy
developers often notice that these capabilities are triggered without a
real need for them. So in the majority of cases, the policy developer
wants to disable auditing of this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dontaudit &amp;lt;somedomain&amp;gt; self:capability { dac_read_search dac_override };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When applications wants to search through directories not owned by the
user as which the application runs, &lt;em&gt;both&lt;/em&gt; capabilities will be checked
- first the &lt;em&gt;dac_read_search&lt;/em&gt; one and, if that is denied (it will be
audited though) then &lt;em&gt;dac_override&lt;/em&gt; is checked. If that one is denied
as well, it too will be audited. That is why many developers
automatically &lt;em&gt;dontaudit&lt;/em&gt; both capability calls if the application
itself doesn't really need the permission.&lt;/p&gt;
&lt;p&gt;Let's say you allow this because the application needs it. But then
another issue comes up when the application checks file attributes or
access permissions (which is a second occurring denial that developers
come across with). Such applications use &lt;em&gt;access()&lt;/em&gt; or &lt;em&gt;faccessat()&lt;/em&gt; to
get information about files, but other than that don't do anything with
the files. When this occurs and the domain does not have read, write or
execute permissions on the target, then the denial is shown even when
the application doesn't really read, write or execute the file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char ** argv) {
  printf(&amp;quot;%s: Exists (%d), Readable (%d), Writeable (%d), Executable (%d)\n&amp;quot;, argv[1],
    access(argv[1], F_OK), access(argv[1], R_OK),
    access(argv[1], W_OK), access(argv[1], X_OK));
}

$ check /var/lib/logrotate.status
/var/lib/logrotate.status: Exists (0), Readable (-1), Writeable (-1), Executable (-1)

$ tail -1 /var/log/audit.log
...
type=AVC msg=audit(1367400559.273:5224): avc:  denied  { read } for  pid=12270 comm=&amp;quot;test&amp;quot; name=&amp;quot;logrotate.status&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=2849 scontext=staff_u:staff_r:staff_t tcontext=system_u:object_r:logrotate_var_lib_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This gives the impression that the application is doing nasty stuff,
even when it is merely checking permissions. One way would be to
dontaudit read as well, but if the application does the check against
several files of various types, that might mean you need to include
dontaudit statements for various domains. That by itself isn't wrong,
but perhaps you do not want to audit such checks but do want to audit
real read attempts. This is what the &lt;em&gt;audit_access&lt;/em&gt; permission is for.&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://marc.info/?l=selinux&amp;amp;m=125349740623497&amp;amp;w=2"&gt;audit_access&lt;/a&gt;
&lt;a href="http://marc.info/?l=selinux&amp;amp;m=127239846604513"&gt;permission&lt;/a&gt; is meant to
be used only for &lt;em&gt;dontaudit&lt;/em&gt; statements: it has no effect on the
security of the system itself, so using it in &lt;em&gt;allow&lt;/em&gt; statements has no
effect. The purpose of the permission is to allow policy developers to
not audit access checks without really dontauditing other, possibly
malicious, attempts. In other words, checking the access can be
dontaudited while actually attempting to use the access (reading,
writing or executing the file) will still result in the proper denial.&lt;/p&gt;</content><category term="SELinux"></category><category term="access"></category><category term="audit"></category><category term="audit_access"></category><category term="selinux"></category></entry><entry><title>Commandline SELinux policy helper functions</title><link href="https://blog.siphos.be/2013/05/commandline-selinux-policy-helper-functions/" rel="alternate"></link><published>2013-05-18T03:50:00+02:00</published><updated>2013-05-18T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-18:/2013/05/commandline-selinux-policy-helper-functions/</id><summary type="html">&lt;p&gt;To work on SELinux policies, I use a couple of functions that I can call
on the shell (command line): &lt;strong&gt;seshowif&lt;/strong&gt;, &lt;strong&gt;sefindif&lt;/strong&gt;, &lt;strong&gt;seshowdef&lt;/strong&gt;
and &lt;strong&gt;sefinddef&lt;/strong&gt;. The idea behind the methods is that I want to search
(&lt;em&gt;find&lt;/em&gt;) for an interface (&lt;em&gt;if&lt;/em&gt;) or definition (&lt;em&gt;def&lt;/em&gt;) that contains a
particular method or &lt;/p&gt;</summary><content type="html">&lt;p&gt;To work on SELinux policies, I use a couple of functions that I can call
on the shell (command line): &lt;strong&gt;seshowif&lt;/strong&gt;, &lt;strong&gt;sefindif&lt;/strong&gt;, &lt;strong&gt;seshowdef&lt;/strong&gt;
and &lt;strong&gt;sefinddef&lt;/strong&gt;. The idea behind the methods is that I want to search
(&lt;em&gt;find&lt;/em&gt;) for an interface (&lt;em&gt;if&lt;/em&gt;) or definition (&lt;em&gt;def&lt;/em&gt;) that contains a
particular method or call. Or, if I know what the interface or
definition is, I want to see it (&lt;em&gt;show&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;For instance, to find the name of the interface that allows us to define
file transitions from the &lt;code&gt;postfix_etc_t&lt;/code&gt; label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif filetrans.*postfix_etc
contrib/postfix.if: interface(`postfix_config_filetrans&amp;#39;,`
contrib/postfix.if:     filetrans_pattern($1, postfix_etc_t, $2, $3, $4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Or to show the content of the &lt;em&gt;corenet_tcp_bind_http_port&lt;/em&gt;
interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seshowif corenet_tcp_bind_http_port
interface(`corenet_tcp_bind_http_port&amp;#39;,`
        gen_require(`
                type http_port_t;
        &amp;#39;)

        allow $1 http_port_t:tcp_socket name_bind;
        allow $1 self:capability net_bind_service;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For the definitions, this is quite similar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefinddef socket.*create
obj_perm_sets.spt:define(`create_socket_perms&amp;#39;, `{ create rw_socket_perms }&amp;#39;)
obj_perm_sets.spt:define(`create_stream_socket_perms&amp;#39;, `{ create_socket_perms listen accept }&amp;#39;)
obj_perm_sets.spt:define(`connected_socket_perms&amp;#39;, `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }&amp;#39;)
obj_perm_sets.spt:define(`create_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read nlmsg_write }&amp;#39;)
obj_perm_sets.spt:define(`rw_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read nlmsg_write }&amp;#39;)
obj_perm_sets.spt:define(`r_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read }&amp;#39;)
obj_perm_sets.spt:define(`client_stream_socket_perms&amp;#39;, `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }&amp;#39;)

$ seshowdef manage_files_pattern
define(`manage_files_pattern&amp;#39;,`
        allow $1 $2:dir rw_dir_perms;
        allow $1 $3:file manage_file_perms;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I have these defined in my &lt;code&gt;~/.bashrc&lt;/code&gt; (they are simple
&lt;a href="http://dev.gentoo.org/~swift/blog/01/selinux-funcs.txt"&gt;functions&lt;/a&gt;) and
are used on a daily basis here ;-) If you want to learn a bit more on
developing SELinux policies for Gentoo, make sure you read the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-development.xml"&gt;Gentoo
Hardened SELinux
Development&lt;/a&gt;
guide.&lt;/p&gt;</content><category term="SELinux"></category><category term="bash"></category><category term="definition"></category><category term="functions"></category><category term="interface"></category><category term="policy"></category><category term="selinux"></category><category term="support"></category></entry><entry><title>Looking at the local Linux kernel privilege escalation</title><link href="https://blog.siphos.be/2013/05/looking-at-the-local-linux-kernel-privilege-escalation/" rel="alternate"></link><published>2013-05-17T03:50:00+02:00</published><updated>2013-05-17T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-17:/2013/05/looking-at-the-local-linux-kernel-privilege-escalation/</id><summary type="html">&lt;p&gt;There has been a few posts already on the local Linux kernel privilege
escalation, which has received the
&lt;a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2094"&gt;CVE-2013-2094&lt;/a&gt;
ID.
&lt;a href="http://arstechnica.com/security/2013/05/critical-linux-vulnerability-imperils-users-even-after-silent-fix/"&gt;arstechnica&lt;/a&gt;
has a write-up with links to good resources on the Internet, but I
definitely want to point readers to the
&lt;a href="http://www.reddit.com/r/netsec/comments/1eb9iw/sdfucksheeporgs_semtexc_local_linux_root_exploit/c9ykrck"&gt;explanation&lt;/a&gt;
that Brad Spengler made on the vulnerability.&lt;/p&gt;
&lt;p&gt;In &lt;/p&gt;</summary><content type="html">&lt;p&gt;There has been a few posts already on the local Linux kernel privilege
escalation, which has received the
&lt;a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2094"&gt;CVE-2013-2094&lt;/a&gt;
ID.
&lt;a href="http://arstechnica.com/security/2013/05/critical-linux-vulnerability-imperils-users-even-after-silent-fix/"&gt;arstechnica&lt;/a&gt;
has a write-up with links to good resources on the Internet, but I
definitely want to point readers to the
&lt;a href="http://www.reddit.com/r/netsec/comments/1eb9iw/sdfucksheeporgs_semtexc_local_linux_root_exploit/c9ykrck"&gt;explanation&lt;/a&gt;
that Brad Spengler made on the vulnerability.&lt;/p&gt;
&lt;p&gt;In short, the vulnerability is an &lt;em&gt;out-of-bound&lt;/em&gt; access to an array
within the Linux perf code (which is a performance measuring subsystem
enabled when &lt;code&gt;CONFIG_PERF_EVENTS&lt;/code&gt; is enabled). This subsystem is often
enabled as it offers a wide range of performance measurement techniques
(see &lt;a href="https://perf.wiki.kernel.org/index.php/Main_Page"&gt;its wiki&lt;/a&gt; for
more information). You can check on your own system through the kernel
configuration (&lt;strong&gt;zgrep CONFIG_PERF_EVENTS /proc/config.gz&lt;/strong&gt; if you
have the latter pseudo-file available - it is made available through
&lt;code&gt;CONFIG_IKCONFIG_PROC&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The public exploit maps memory in userland, fills it with known data,
then triggers an out-of-bound decrement that tricks the kernel into
decrementing this data (mapped in userland). By looking at where the
decrement occurred, the exploit now knows the base address of the array.
Next, it targets (through the same vulnerability) the IDT base
(Interrupt Descriptor Table) and targets the overflow interrupt vector.
It increments the top part of the address that the vector points to
(which is 0xffffffff, becoming 0x00000000 thus pointing to the
userland), maps this memory region itself with shellcode, and then
triggers the overflow. The shell code used in the public exploit
modifies the credentials of the current task, sets uid/gid with root and
gives full capabilities, and then executes a shell.&lt;/p&gt;
&lt;p&gt;As Brad mentions, &lt;a href="https://grsecurity.net/~spender/uderef.txt"&gt;UDEREF&lt;/a&gt;
(an option in a grSecurity enabled kernel) should mitigate the attempt
to get to the userland. On my system, the exploit fails with the
following (start of) oops (without affecting the system further) when it
tries to close the file descriptor returned from the syscall that
invokes the decrement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ 1926.226678] PAX: please report this to pageexec@freemail.hu
[ 1926.227019] BUG: unable to handle kernel paging request at 0000000381f5815c
[ 1926.227019] IP: [] sw_perf_event_destroy+0x1a/0xa0
[ 1926.227019] PGD 58a7c000 
[ 1926.227019] Thread overran stack, or stack corrupted
[ 1926.227019] Oops: 0002 [#4] PREEMPT SMP 
[ 1926.227019] Modules linked in: libcrc32c
[ 1926.227019] CPU 0 
[ 1926.227019] Pid: 4267, comm: test Tainted: G      D      3.8.7-hardened #1 Bochs Bochs
[ 1926.227019] RIP: 0010:[]  [] sw_perf_event_destroy+0x1a/0xa0
[ 1926.227019] RSP: 0018:ffff880058a03e08  EFLAGS: 00010246
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The exploit also finds that the decrement didn't succeed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test: semtex.c:76: main: Assertion &amp;#39;i&amp;lt;0x0100000000/4&amp;#39; failed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A second mitigation is that
&lt;a href="http://pax.grsecurity.net/docs/PaXTeam-H2HC12-PaX-kernel-self-protection.pdf"&gt;KERNEXEC&lt;/a&gt;
(also offered through grSecurity) which prevents the kernel from
executing data that is writable (including userland data). So modifying
the IDT would be mitigated as well.&lt;/p&gt;
&lt;p&gt;Another important mitigation is TPE - &lt;em&gt;Trusted Path Execution&lt;/em&gt;. This
feature prevents the execution of binaries that are not located in a
root-owned directory and owned by a trusted group (which on my system is
10 = wheel). So users attempting to execute such code will fail with a
&lt;em&gt;Permission denied&lt;/em&gt; error, and the following is shown in the logs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[ 3152.165780] grsec: denied untrusted exec (due to not being in trusted group and file in non-root-owned directory) of /home/user/test by /home/user/test[bash:4382] uid/euid:1000/1000 gid/egid:100/100, parent /bin/bash[bash:4352] uid/euid:1000/1000 gid/egid:100/100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, even though a nicely hardened system should be fairly immune
against the currently circling public exploit, it should be noted that
it is not immune against the vulnerability itself. The methods above
mentioned make it so that that particular way of gaining root access is
not possible, but it still allows an attacker to decrement and increment
memory in specific locations so other exploits might be found to modify
the system.&lt;/p&gt;
&lt;p&gt;Now out-of-bound vulnerabilities are not new. Recently (february this
year), a
&lt;a href="http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=MTMxMTg"&gt;vulnerability&lt;/a&gt;
in the networking code also provided an attack vector to get a local
privilege escalation. A mandatory access control system like SELinux has
little impact on such vulnerabilities if you allow users to execute
their own code. Even confined users can modify the exploit to disable
SELinux (since the shell code is ran with ring0 privileges it can access
and modify the SELinux state information in the kernel).&lt;/p&gt;
&lt;p&gt;Many thanks to Brad for the excellent write-up, and to the &lt;a href="http://www.gentoo.org/proj/en/hardened"&gt;Gentoo
Hardened&lt;/a&gt; team for providing the
grSecurity PaX/TPE protections in its &lt;code&gt;hardened-sources&lt;/code&gt; kernel.&lt;/p&gt;</content><category term="Security"></category><category term="event"></category><category term="grsecurity"></category><category term="kernexec"></category><category term="linux"></category><category term="pax"></category><category term="perf"></category><category term="selinux"></category><category term="uderef"></category><category term="vulnerability"></category></entry><entry><title>Overriding the default SELinux policies</title><link href="https://blog.siphos.be/2013/05/overriding-the-default-selinux-policies/" rel="alternate"></link><published>2013-05-15T03:50:00+02:00</published><updated>2013-05-15T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-15:/2013/05/overriding-the-default-selinux-policies/</id><summary type="html">&lt;p&gt;Extending SELinux policies with additional rules is easy. As SELinux
uses a &lt;em&gt;deny by default&lt;/em&gt; approach, all you need to do is to &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file"&gt;create a
policy
module&lt;/a&gt;
that contains the additional (allow) rules, load that and you're all
set. But what if you want to remove some rules?&lt;/p&gt;
&lt;p&gt;Well, sadly &lt;/p&gt;</summary><content type="html">&lt;p&gt;Extending SELinux policies with additional rules is easy. As SELinux
uses a &lt;em&gt;deny by default&lt;/em&gt; approach, all you need to do is to &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file"&gt;create a
policy
module&lt;/a&gt;
that contains the additional (allow) rules, load that and you're all
set. But what if you want to remove some rules?&lt;/p&gt;
&lt;p&gt;Well, sadly, SELinux does not support deny rules. Once an allow rule is
loaded in memory, it cannot be overturned anymore. Yes, you can disable
the module itself that provides the rules, but you cannot selectively
disable rules. So what to do?&lt;/p&gt;
&lt;p&gt;Generally, you can disable the module that contains the rules you want
to disable, and load a custom module that defines everything the
original module did, except for those rules you don't like. For
instance, if you do not want the &lt;code&gt;skype_t&lt;/code&gt; domain to be able to
read/write to the video device, create your own skype-providing module
(&lt;em&gt;myskype&lt;/em&gt;) with the exact same content (except for the module name at
the first line) as the original skype module, except for the video
device:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dev_read_sound(skype_t)
# dev_read_video_dev(skype_t)
dev_write_sound(skype_t)
# dev_write_video_dev(skype_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Load in this policy, and you now have the &lt;code&gt;skype_t&lt;/code&gt; domain without the
video access. You will get post-install failures when Gentoo pushes out
an update to the policy though, since it will attempt to reload the
&lt;code&gt;skype.pp&lt;/code&gt; file (through the &lt;code&gt;selinux-skype&lt;/code&gt; package) and fail because
it declares types and attributes already provided (by &lt;em&gt;myskype&lt;/em&gt;). You
can &lt;a href="http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=3&amp;amp;chap=5#doc_chap1"&gt;exclude the
package&lt;/a&gt;
from being updated, which works as long as no packages depend on it. Or
live with the post-install failure ;-) But there might be a simpler
approach: &lt;em&gt;epatch_user&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Recently, I added in support for &lt;em&gt;epatch_user&lt;/em&gt; in the policy ebuilds.
This allows users to create patches against the policy source code that
we use and put them in &lt;code&gt;/etc/portage/patches&lt;/code&gt; in the directory of the
right category/package. For module patches, the working directory used
is within the &lt;code&gt;policy/modules&lt;/code&gt; directory of the policy checkout. For
base, it is below the policy checkout (in other words, the patch will
need to use the &lt;code&gt;refpolicy/&lt;/code&gt; directory base). But because of how
&lt;em&gt;epatch_user&lt;/em&gt; works, any patch taken from the base will work as it will
start stripping directories up to the fourth one.&lt;/p&gt;
&lt;p&gt;This approach is also needed if you want to exclude rules from
interfaces rather than from the &lt;code&gt;.te&lt;/code&gt; file: create a small patch and put
it in &lt;code&gt;/etc/portage/patches&lt;/code&gt; for the &lt;code&gt;sec-policy/selinux-base&lt;/code&gt; package
(as this provides the interfaces).&lt;/p&gt;</content><category term="Gentoo"></category><category term="ebuild"></category><category term="epatch_user"></category><category term="Gentoo"></category><category term="override"></category><category term="patch"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Highlevel assessment of Cdorked and Gentoo Hardened/SELinux</title><link href="https://blog.siphos.be/2013/05/highlevel-assessment-of-cdorked-and-gentoo-hardenedselinux/" rel="alternate"></link><published>2013-05-14T03:50:00+02:00</published><updated>2013-05-14T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-14:/2013/05/highlevel-assessment-of-cdorked-and-gentoo-hardenedselinux/</id><summary type="html">&lt;p&gt;With all the
&lt;a href="http://www.welivesecurity.com/2013/05/07/linuxcdorked-malware-lighttpd-and-nginx-web-servers-also-affected/"&gt;reports&lt;/a&gt;
surrounding
&lt;a href="https://threatpost.com/attack-using-backdoored-apache-binaries-to-lead-to-blackhole-kit/"&gt;Cdorked&lt;/a&gt;,
I took a look at if SELinux and/or other Gentoo Hardened technologies
could reduce the likelihood that this infection occurs on your system.&lt;/p&gt;
&lt;p&gt;First of all, we don't know yet how the malware gets installed on the
server. We do know that the &lt;/p&gt;</summary><content type="html">&lt;p&gt;With all the
&lt;a href="http://www.welivesecurity.com/2013/05/07/linuxcdorked-malware-lighttpd-and-nginx-web-servers-also-affected/"&gt;reports&lt;/a&gt;
surrounding
&lt;a href="https://threatpost.com/attack-using-backdoored-apache-binaries-to-lead-to-blackhole-kit/"&gt;Cdorked&lt;/a&gt;,
I took a look at if SELinux and/or other Gentoo Hardened technologies
could reduce the likelihood that this infection occurs on your system.&lt;/p&gt;
&lt;p&gt;First of all, we don't know yet how the malware gets installed on the
server. We do know that the Apache binaries themselves are modified, so
the first thing to look at is to see if this risk can be reduced. Of
course, using an intrusion detection system like
&lt;a href="https://wiki.gentoo.org/wiki/AIDE"&gt;AIDE&lt;/a&gt; helps, but even with Gentoo's
&lt;strong&gt;qcheck&lt;/strong&gt; command you can test the integrity of the files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# qcheck www-servers/apache
Checking www-servers/apache-2.2.24 ...
  * 424 out of 424 files are good
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the binary is modified, this would result in something equivalent to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Checking www-servers/apache-2.2.24 ...
 MD5-DIGEST: /usr/sbin/apache2
  * 423 out of 424 files are good
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I don't know if the modified binary would otherwise work just fine, I
have not been able to find exact details on the infected binary to (in a
sandbox environment of course) analyze this further. Also, because we
don't know how they are installed, it is not easy to know if binaries
that you built yourself are equally likely to be modified/substituted or
if the attack checks checksums of the binaries against a known list.&lt;/p&gt;
&lt;p&gt;Assuming that it would run, then the infecting malware would need to set
the proper SELinux context on the file (if it overwrites the existing
binary, then the context is retained, otherwise it gets the default
context of &lt;code&gt;bin_t&lt;/code&gt;). If the context is wrong, then starting Apache
results in:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apache2: Syntax error on line 61 of /etc/apache2/httpd.conf: Cannot load /usr/lib64/apache2/modules/mod_actions.so into server: /usr/lib64/apache2/modules/mod_actions.so: cannot open shared object file: Permission denied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is because the modified binary stays in the calling domain context
(&lt;code&gt;initrc_t&lt;/code&gt;). If you use a targeted policy, then this will not present
itself as &lt;code&gt;initrc_t&lt;/code&gt; is an unconfined domain. But with strict policies,
&lt;code&gt;initrc_t&lt;/code&gt; is not allowed to read &lt;code&gt;httpd_modules_t&lt;/code&gt;. Even worse, the
remainder of SELinux protections don't apply anymore, since with
unconfined domains, all bets are off. That is why Gentoo focuses this
hard on using a strict policy.&lt;/p&gt;
&lt;p&gt;So, what if the binary runs in the proper domain? Well then, from the
articles I read, the malware can do a reverse connect. That means that
the domain will attempt to connect to an IP address provided by the
attacker (in a specifically crafted URL). For SELinux, this means that
the &lt;em&gt;name_connect&lt;/em&gt; permission is checked:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# sesearch -s httpd_t -c tcp_socket -p name_connect -ACTS
Found 20 semantic av rules:
   allow nsswitch_domain dns_port_t : tcp_socket { name_connect } ; 
DT allow httpd_t port_type : tcp_socket { name_connect } ; [ httpd_can_network_connect ]
DT allow httpd_t ftp_port_t : tcp_socket { name_connect } ; [ httpd_can_network_relay ]
DT allow httpd_t smtp_port_t : tcp_socket { name_connect } ; [ httpd_can_sendmail ]
DT allow httpd_t postgresql_port_t : tcp_socket { name_connect } ; [ httpd_can_network_connect_db ]
DT allow httpd_t oracledb_port_t : tcp_socket { name_connect } ; [ httpd_can_network_connect_db ]
DT allow httpd_t squid_port_t : tcp_socket { name_connect } ; [ httpd_can_network_relay ]
DT allow httpd_t mssql_port_t : tcp_socket { name_connect } ; [ httpd_can_network_connect_db ]
DT allow httpd_t kerberos_port_t : tcp_socket { name_connect } ; [ allow_kerberos ]
DT allow nsswitch_domain ldap_port_t : tcp_socket { name_connect } ; [ authlogin_nsswitch_use_ldap ]
DT allow httpd_t http_cache_port_t : tcp_socket { name_connect } ; [ httpd_can_network_relay ]
DT allow httpd_t http_port_t : tcp_socket { name_connect } ; [ httpd_can_network_relay ]
DT allow httpd_t http_port_t : tcp_socket { name_connect } ; [ httpd_graceful_shutdown ]
DT allow httpd_t mysqld_port_t : tcp_socket { name_connect } ; [ httpd_can_network_connect_db ]
DT allow httpd_t ocsp_port_t : tcp_socket { name_connect } ; [ allow_kerberos ]
DT allow nsswitch_domain kerberos_port_t : tcp_socket { name_connect } ; [ allow_kerberos ]
DT allow httpd_t pop_port_t : tcp_socket { name_connect } ; [ httpd_can_sendmail ]
DT allow nsswitch_domain ocsp_port_t : tcp_socket { name_connect } ; [ allow_kerberos ]
DT allow httpd_t gds_db_port_t : tcp_socket { name_connect } ; [ httpd_can_network_connect_db ]
DT allow httpd_t gopher_port_t : tcp_socket { name_connect } ; [ httpd_can_network_relay ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So by default, the Apache (&lt;code&gt;httpd_t&lt;/code&gt;) domain is allowed to connect to
DNS port (to resolve hostnames). All other &lt;em&gt;name_connect&lt;/em&gt; calls depend
on SELinux booleans (mentioned after it) that are by default disabled
(at least on Gentoo). Disabling hostname resolving is not really
feasible, so if the attacker uses a DNS port as port that the malware
needs to connect to, SELinux will not deny it (unless you use additional
networking constraints).&lt;/p&gt;
&lt;p&gt;Now, the reverse connect is an interesting feature of the malware, but
not the main one. The main focus of the malware is to redirect customers
to particular sites that can trick the user in downloading additional
(client) malware. Because this is done internally within Apache, SELinux
cannot deal with this. As a user, make sure you configure your browser
not to trust non-local iframes and such (always do this, not just
because there is a possible threat right now). The configuration of
Cdorked is a shared memory segment of Apache itself. Of course, since
Apache uses shared memory, the malware embedded within will also have
access to the shared memory. However, if this shared memory would need
to be accessed by third party applications (the malware seems to grant
read/write rights on everybody to this segment) SELinux will prevent
this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# sesearch -t httpd_t -c shm -ACTS
Found 2 semantic av rules:
   allow unconfined_domain_type domain : shm { create destroy getattr setattr read write associate unix_read unix_write lock } ; 
   allow httpd_t httpd_t : shm { create destroy getattr setattr read write associate unix_read unix_write lock } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Only unconfined domains and the &lt;code&gt;httpd_t&lt;/code&gt; domain itself have access to
&lt;code&gt;httpd_t&lt;/code&gt; labeled shared memory.&lt;/p&gt;
&lt;p&gt;So what about IMA/EVM? Well, those will not help here since IMA checks
for integrity of files that were modified &lt;em&gt;offline&lt;/em&gt;. As the modification
of the Apache binaries is most likely done online, IMA would just accept
this.&lt;/p&gt;
&lt;p&gt;For now, it seems that a good system integrity approach is the most
effective until we know more about how the malware-infected binary is
written to the system in the first place (as this is better protected by
MAC controls like SELinux).&lt;/p&gt;</content><category term="Security"></category><category term="apache"></category><category term="cdorked"></category><category term="Gentoo"></category><category term="hardened"></category><category term="ima"></category><category term="selinux"></category></entry><entry><title>SECMARK and SELinux</title><link href="https://blog.siphos.be/2013/05/secmark-and-selinux/" rel="alternate"></link><published>2013-05-13T03:50:00+02:00</published><updated>2013-05-13T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-13:/2013/05/secmark-and-selinux/</id><summary type="html">&lt;p&gt;When using SECMARK, the administrator configures the &lt;strong&gt;iptables&lt;/strong&gt; or
&lt;strong&gt;netfilter&lt;/strong&gt; rules to add a label to the packet data structure (on the
host itself) that can be governed through SELinux policies. Unlike peer
labeling, here the labels assigned to the network traffic is completely
locally defined. Consider the following command &lt;/p&gt;</summary><content type="html">&lt;p&gt;When using SECMARK, the administrator configures the &lt;strong&gt;iptables&lt;/strong&gt; or
&lt;strong&gt;netfilter&lt;/strong&gt; rules to add a label to the packet data structure (on the
host itself) that can be governed through SELinux policies. Unlike peer
labeling, here the labels assigned to the network traffic is completely
locally defined. Consider the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# iptables -t mangle -A INPUT -p tcp --src 192.168.1.2 --dport 443
  -j SECMARK --selctx system_u:object_r:myauth_packet_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this command, packets that originate from the &lt;em&gt;192.168.1.2&lt;/em&gt; host
and arrive on port 443 (typically used for HTTPS traffic) are marked as
&lt;code&gt;myauth_packet_t&lt;/code&gt;. SELinux policy writers can then allow domains to
receive this type of packets (or send) through the &lt;em&gt;packet&lt;/em&gt; class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Allow sockets with mydomain_t context to receive packets labeled myauth_packet_t
allow mydomain_t myauth_packet_t:packet recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The SELinux policy modules enable this through the
&lt;em&gt;corenet_sendrecv_&amp;lt;type&amp;gt;_{client,server}_packets&lt;/em&gt; interfaces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_sendrecv_http_client_packets(mybrowser_t)
# allow mybrowser_t http_client_packet_t:packet { send recv };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As a common rule, packets are marked as client packets or server
packets, depending on the role of the &lt;em&gt;domain&lt;/em&gt;. In the above example,
the domain is a browser, so acts as a web client. So, it needs to send
and receive &lt;code&gt;http_client_packet_t&lt;/code&gt;. A web server on the other hand would
need to send and receive &lt;code&gt;http_server_packet_t&lt;/code&gt;. Note that the packets
that are sent over the wire do not have any labels assigned to them -
this is all local to the system. So even when the source and destination
use SELinux with SECMARK, on the source server the packets might be
labeled as &lt;code&gt;http_client_packet_t&lt;/code&gt; whereas on the target they are seen as
&lt;code&gt;http_server_packet_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As far as I know, when you want to use SECMARK, you will need to set the
contexts with &lt;strong&gt;iptables&lt;/strong&gt; yourself (there is no default labeling), so
knowing about the above convention is important.&lt;/p&gt;
&lt;p&gt;Again, Paul Moore has &lt;a href="http://paulmoore.livejournal.com/4281.html"&gt;more
information&lt;/a&gt; about this.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="secmark"></category><category term="selinux"></category></entry><entry><title>Peer labeling in SELinux policy</title><link href="https://blog.siphos.be/2013/05/peer-labeling-in-selinux-policy/" rel="alternate"></link><published>2013-05-12T03:50:00+02:00</published><updated>2013-05-12T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-12:/2013/05/peer-labeling-in-selinux-policy/</id><summary type="html">&lt;p&gt;Allow me to start with an important warning: I don't have much hands-on
experience with the remainder of this post. Its based on the few
resources I found on the Internet and a few tests done locally which
I've investigated in my attempt to understand SELinux policy writing for
networking &lt;/p&gt;</summary><content type="html">&lt;p&gt;Allow me to start with an important warning: I don't have much hands-on
experience with the remainder of this post. Its based on the few
resources I found on the Internet and a few tests done locally which
I've investigated in my attempt to understand SELinux policy writing for
networking stuff.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, let's look into &lt;em&gt;peer labeling&lt;/em&gt;. As
mentioned in my &lt;a href="http://blog.siphos.be/2013/05/selinux-policy-and-network-controls/"&gt;previous
post&lt;/a&gt;,
SELinux supports some more advanced networking security features than
the default socket restrictions. I mentioned SECMARK and NetLabel
before, but NetLabel is actually part of the family of &lt;em&gt;peer&lt;/em&gt; labeling
technologies.&lt;/p&gt;
&lt;p&gt;With this technology approach, all participating systems in the network
must support the same labeling method. NetLabel supports CIPSO
(&lt;a href="https://tools.ietf.org/html/draft-ietf-cipso-ipsecurity-01"&gt;Commerial IP Security
Option&lt;/a&gt;)
where hosts label their network traffic to be part of a particular
"Domain of Interpretation". The labels are used by the hosts to identify
where a packet should be for. NetLabel, within Linux, is then used to
translate those CIPSO labels. SELinux itself labels the incoming sockets
based on the NetLabel information and the context of the listening
socket, resulting in a context that is governed policy-wise through the
&lt;em&gt;peer&lt;/em&gt; class. Since this is based on the information in the packet
instead of defined on the system itself, this allows remote systems to
have a say in how the packets are labeled.&lt;/p&gt;
&lt;p&gt;Another peer technology is the &lt;em&gt;Labeled IPSec&lt;/em&gt; one. In this case the
labels are fully provided by the remote system. I think they are based
on the security association within the IPSec setup.&lt;/p&gt;
&lt;p&gt;In both cases, in the SELinux policies, three definitions are important
to keep an eye out on: &lt;em&gt;interface&lt;/em&gt; definitions, &lt;em&gt;node&lt;/em&gt; definitions and
&lt;em&gt;peer&lt;/em&gt; definitions.&lt;/p&gt;
&lt;p&gt;Interface definitions allow users to (mainly) set the sensitivity that
is allowed to pass the interface. Using &lt;strong&gt;semanage interface&lt;/strong&gt; this can
be controlled by the user. One can also assign a different context to
the interface - by default, this is &lt;code&gt;netif_t&lt;/code&gt;. The permissions that are
checked on the traffic is &lt;em&gt;ingress&lt;/em&gt; (incoming) and &lt;em&gt;egress&lt;/em&gt; (outgoing)
traffic, and most policies set this through the following call (comment
shows the underlying SELinux rules, where &lt;em&gt;tcp_send&lt;/em&gt; and &lt;em&gt;tcp_recv&lt;/em&gt;
are - I think - obsolete):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_sendrecv_generic_if(something_t)
# allow something_t netif_t:netif { tcp_send tcp_recv egress ingress };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Node definitions define which targets (nodes, which can be IP addresses
or subnets) traffic meant for a particular socket is allow to originate
from (&lt;em&gt;recvfrom&lt;/em&gt;) or sent to (&lt;em&gt;sendto&lt;/em&gt;). Again, users can define their
own node types and manage them using &lt;strong&gt;semanage node&lt;/strong&gt;. The default node
I already covered in the previous post (&lt;code&gt;node_t&lt;/code&gt;) and is allowed by most
policies by default through the following call (where the &lt;em&gt;tcp_send&lt;/em&gt;
and &lt;em&gt;tcp_recv&lt;/em&gt; are probably deprecated as well):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_sendrecv_generic_node(something_t)
# allow something_t node_t:node { tcp_send tcp_recv sendto recvfrom };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, peer definitions are based on the labels from the traffic. If
the system uses NetLabel, then the target label will always be
&lt;code&gt;netlabel_peer_t&lt;/code&gt; since the workings of CIPSO are mainly (only?) mapped
towards sensitivity labels (in MLS policy). As a result, SELinux always
displays the peer as being &lt;code&gt;netlabel_peer_t&lt;/code&gt;. In case of Labeled IPSec,
this isn't the case as the peer label is transmitted by the peer itself.&lt;/p&gt;
&lt;p&gt;For NetLabel support, policies generally include two methods - one is to
support unlabeled traffic (only needed the moment you have support for
labeled traffic) and one is to allow the NetLabel'ed traffic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_all_recvfrom_unlabeled(something_t)
# allow something_t unlabeled_t:peer recv;
corenet_all_recvfrom_netlabel(something_t)
# allow something_t netlabel_peer_t:peer recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In case of IPSec for instance, the peer will have a provided label, as
is shown by the call for accepting hadoop traffic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;hadoop_recvfrom(something_t)
# allow something_t hadoop_t:peer recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, this alone is not sufficient for labeled IPSec. We also need to
allow the domain to be allowed to send anything towards an IPSec
security association. There is an interface called
&lt;em&gt;corenet_tcp_recvfrom_labeled&lt;/em&gt; that takes two arguments which,
amongst other things, enables &lt;em&gt;sendto&lt;/em&gt; towards its association.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_recvfrom_labeled(some_t, thing_t)
# allow { some_t thing_t} self:association sendto;
# allow some_t thing_t:peer recv;
# allow thing_t some_t:peer recv;
# corenet_tcp_recvfrom_netlabel(some_t)
# corenet_tcp_recvfrom_netlabel(thing_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This interface is usually called within a &lt;em&gt;*_tcp_connect()&lt;/em&gt; interface
for a particular domain, like with the &lt;em&gt;mysql_tcp_connect&lt;/em&gt; example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`mysql_tcp_connect&amp;#39;,`
        gen_require(`
                type mysqld_t;
        &amp;#39;)

        corenet_tcp_recvfrom_labeled($1, mysqld_t)
        corenet_tcp_sendrecv_mysqld_port($1) # deprecated
        corenet_tcp_connect_mysqld_port($1)
        corenet_sendrecv_mysqld_client_packets($1)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When using peer labeling, the domain that is allowed something is based
on the socket context of the application. Also, the rules when using
peer labeling are &lt;em&gt;in addition to&lt;/em&gt; the rules mentioned before
("standard" networking control): &lt;em&gt;name_bind&lt;/em&gt; and &lt;em&gt;name_connect&lt;/em&gt; are
always checked.&lt;/p&gt;
&lt;p&gt;For more information, make sure you check &lt;a href="http://paulmoore.livejournal.com"&gt;Paul Moore's
blog&lt;/a&gt;, such as the
&lt;a href="http://paulmoore.livejournal.com/2128.html?nojs=1"&gt;egress/ingress&lt;/a&gt;
information. And if you know of resources that show this in a more
practical setting (above is mainly to work with the SELinux policy) I'm
all ears.&lt;/p&gt;</content><category term="SELinux"></category><category term="cipso"></category><category term="ipsec"></category><category term="peer"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>SELinux policy and network controls</title><link href="https://blog.siphos.be/2013/05/selinux-policy-and-network-controls/" rel="alternate"></link><published>2013-05-11T03:50:00+02:00</published><updated>2013-05-11T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-11:/2013/05/selinux-policy-and-network-controls/</id><summary type="html">&lt;p&gt;Let's talk about how SELinux governs network streams (and how it
reflects this into the policy).&lt;/p&gt;
&lt;p&gt;When you don't do fancy stuff like SECMARK or netlabeling, then the
classes that you should keep an eye on are &lt;em&gt;tcp_socket&lt;/em&gt; and
&lt;em&gt;udp_socket&lt;/em&gt; (depending on the protocol). There used to be &lt;em&gt;node&lt;/em&gt; and &lt;/p&gt;</summary><content type="html">&lt;p&gt;Let's talk about how SELinux governs network streams (and how it
reflects this into the policy).&lt;/p&gt;
&lt;p&gt;When you don't do fancy stuff like SECMARK or netlabeling, then the
classes that you should keep an eye on are &lt;em&gt;tcp_socket&lt;/em&gt; and
&lt;em&gt;udp_socket&lt;/em&gt; (depending on the protocol). There used to be &lt;em&gt;node&lt;/em&gt; and
&lt;em&gt;netif&lt;/em&gt; as well, but the support (enforcement) for these have been
&lt;a href="http://lists.openwall.net/netdev/2009/03/27/144"&gt;removed a while ago&lt;/a&gt;
for the "old style" network control enforcement. The concepts are still
available though, and I believe they take effect when netlabeling is
used. But let's first look at the regular networking aspects.&lt;/p&gt;
&lt;p&gt;The idea behind the regular network related permissions are that you
define either daemon-like behavior (which "binds" to a port) or
client-like behavior (which "connects" to a port). Consider an FTP
daemon (domain &lt;code&gt;ftpd_t&lt;/code&gt;) versus FTP client (example domain &lt;code&gt;ncftp_t&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In case of a daemon, the policy would contain the following (necessary)
rules:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_bind_generic_node(ftpd_t) # Somewhat legacy but still needed
corenet_tcp_bind_ftp_port(ftpd_t)
corenet_tcp_bind_ftp_data_port(ftpd_t)
corenet_tcp_bind_all_unreserved_ports(ftpd_t) # In case of passive mode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This gets translated to the following "real" SELinux statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow ftpd_t node_t:tcp_socket node_bind;
allow ftpd_t ftp_port_t:tcp_socket name_bind;
allow ftpd_t ftp_data_port_t:tcp_socket name_bind;
allow ftpd_t unreserved_port_type:tcp_socket name_bind;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I mention that &lt;em&gt;corenet_tcp_bind_generic_node&lt;/em&gt; as being somewhat
legacy. When you use netlabeling, you can define different nodes (a
"node" in that case is a label assigned to an IP address or IP subnet)
and as such define policy-wise where daemons can bind on (or clients can
connect to). However, without netlabel, the only node that you get to
work with is &lt;code&gt;node_t&lt;/code&gt; which represents any possible node. Also, the use
of passive mode within the ftp policy is governed through the
&lt;em&gt;ftpd_use_passive_mode&lt;/em&gt; boolean.&lt;/p&gt;
&lt;p&gt;For a client, the following policy line would suffice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_connect_ftp_port(ncftp_t)
# allow ncftp_t ftp_port_t:tcp_socket name_connect;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Well, I lied. Because of how FTP works, if you use active connections,
you need to allow the client to bind on an unreserved port, and allow
the server to connect to unreserved ports (cfr code snippet below), but
you get the idea.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_connect_all_unreserved_ports(ftpd_t)

corenet_tcp_bind_generic_node(ncftp_t)
corenet_tcp_bind_all_unreserved_ports(ncftp_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the past, policy developers also had to include other lines, but
these have by time become obsolete (&lt;em&gt;corenet_tcp_sendrecv_ftp_port&lt;/em&gt;
for instance). These methods defined the ability to send and receive
messages on the port, but this is no longer controlled this way. If you
need such controls, you will need to look at SELinux and SECMARK (which
uses packets with the &lt;em&gt;packet&lt;/em&gt; class) or netlabel (which uses the &lt;em&gt;peer&lt;/em&gt;
class and peer types to send or receive messages from).&lt;/p&gt;
&lt;p&gt;And that'll be for a different post.&lt;/p&gt;</content><category term="SELinux"></category><category term="networking"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Overview of Linux capabilities, part 2</title><link href="https://blog.siphos.be/2013/05/overview-of-linux-capabilities-part-2/" rel="alternate"></link><published>2013-05-05T03:50:00+02:00</published><updated>2013-05-05T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-05:/2013/05/overview-of-linux-capabilities-part-2/</id><summary type="html">&lt;p&gt;As I've (in a very high level) &lt;a href="http://blog.siphos.be/2013/05/capabilities-a-short-intro/"&gt;described
capabilities&lt;/a&gt;
and talked a bit on how to &lt;a href="http://blog.siphos.be/2013/05/restricting-and-granting-capabilities/"&gt;work with
them&lt;/a&gt;,
I started with a small overview of
&lt;a href="http://blog.siphos.be/2013/05/overview-of-linux-capabilities-part-1/"&gt;file-related&lt;/a&gt;
capabilities. So next up are process-related capabilities (note, this
isn't a conform terminology, more some categorization that I do myself).&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;CAP_IPC_LOCK&lt;/dt&gt;
&lt;dd&gt;Allow the &lt;/dd&gt;&lt;/dl&gt;</summary><content type="html">&lt;p&gt;As I've (in a very high level) &lt;a href="http://blog.siphos.be/2013/05/capabilities-a-short-intro/"&gt;described
capabilities&lt;/a&gt;
and talked a bit on how to &lt;a href="http://blog.siphos.be/2013/05/restricting-and-granting-capabilities/"&gt;work with
them&lt;/a&gt;,
I started with a small overview of
&lt;a href="http://blog.siphos.be/2013/05/overview-of-linux-capabilities-part-1/"&gt;file-related&lt;/a&gt;
capabilities. So next up are process-related capabilities (note, this
isn't a conform terminology, more some categorization that I do myself).&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;CAP_IPC_LOCK&lt;/dt&gt;
&lt;dd&gt;Allow the process to lock memory&lt;/dd&gt;
&lt;dt&gt;CAP_IPC_OWNER&lt;/dt&gt;
&lt;dd&gt;Bypass the permission checks for operations on System V IPC objects
(similar to the &lt;code&gt;CAP_DAC_OVERRIDE&lt;/code&gt; for files)&lt;/dd&gt;
&lt;dt&gt;CAP_KILL&lt;/dt&gt;
&lt;dd&gt;Bypass permission checks for sending signals&lt;/dd&gt;
&lt;dt&gt;CAP_SETUID&lt;/dt&gt;
&lt;dd&gt;Allow the process to make arbitrary manipulations of process UIDs
and create forged UID when passing socket credentials via UNIX
domain sockets&lt;/dd&gt;
&lt;dt&gt;CAP_SETGID&lt;/dt&gt;
&lt;dd&gt;Same, but then for GIDs&lt;/dd&gt;
&lt;dt&gt;CAP_SYS_NICE&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;This capability governs several permissions/abilities, namely to
allow the process to
&lt;/p&gt;
-   change the &lt;em&gt;nice&lt;/em&gt; value of itself and other processes
-   set real-time scheduling priorities for itself, and set
    scheduling policies and priorities for arbitrary processes
-   set the CPU affinity for arbitrary processes
-   apply &lt;em&gt;migrate_pages&lt;/em&gt; to arbitrary processes and allow
    processes to be migrated to arbitrary nodes
-   apply &lt;em&gt;move_pages&lt;/em&gt; to arbitrary processes
-   use the &lt;code&gt;MPOL_MF_MOVE_ALL&lt;/code&gt; flag with &lt;em&gt;mbind()&lt;/em&gt; and
    &lt;em&gt;move_pages()&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;p&gt;
The abilities related to page moving, migration and nodes is of
importance for NUMA systems, not something most workstations have
or need.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;CAP_SYS_PACCT&lt;/dt&gt;
&lt;dd&gt;Use &lt;em&gt;acct()&lt;/em&gt;, to enable or disable system resource accounting for
the process&lt;/dd&gt;
&lt;dt&gt;CAP_SYS_PTRACE&lt;/dt&gt;
&lt;dd&gt;Allow the process to trace arbitrary processes using &lt;em&gt;ptrace()&lt;/em&gt;,
apply &lt;em&gt;get_robust_list()&lt;/em&gt; against arbitrary processes and inspect
processes using &lt;em&gt;kcmp()&lt;/em&gt;.&lt;/dd&gt;
&lt;dt&gt;CAP_SYS_RAWIO&lt;/dt&gt;
&lt;dd&gt;Allow the process to perform I/O port operations, access
&lt;code&gt;/proc/kcore&lt;/code&gt; and employ the &lt;code&gt;FIBMAP&lt;/code&gt; &lt;em&gt;ioctl()&lt;/em&gt; operation.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Capabilities such as &lt;code&gt;CAP_KILL&lt;/code&gt; and &lt;code&gt;CAP_SETUID&lt;/code&gt; are very important to
govern correctly, but this post would be rather dull (given that the
definitions of the above capabilities can be found from the manual page)
if I wouldn't talk a bit more about its feasibility. Take a look at the
following C application code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/capability.h&amp;gt;
#include &amp;lt;sys/prctl.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char ** argv) {
  printf(&amp;quot;cap_setuid and cap_setgid: %d\n&amp;quot;, prctl(PR_CAPBSET_READ, CAP_SETUID|CAP_SETGID, 0, 0, 0));
  printf(&amp;quot; %s\n&amp;quot;, cap_to_text(cap_get_file(argv[0]), NULL));
  printf(&amp;quot; %s\n&amp;quot;, cap_to_text(cap_get_proc(), NULL));
  if (setresuid(0, 0, 0));
    printf(&amp;quot;setresuid(): %s\n&amp;quot;, strerror(errno));
  execve(&amp;quot;/bin/sh&amp;quot;, NULL, NULL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At first sight, it looks like an application to get root privileges
(&lt;em&gt;setresuid()&lt;/em&gt;) and then spawn a shell. If that application would be
given &lt;code&gt;CAP_SETUID&lt;/code&gt; and &lt;code&gt;CAP_SETGID&lt;/code&gt; effectively, it would allow anyone
who executed it to automatically get a root shell, wouldn't it?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ gcc -o test -lcap test.c
# setcap cap_setuid,cap_setgid+ep test
$ ./test
cap_setuid and cap_setgid: 1
 = cap_setgid,cap_setuid+ep
 =
setresuid() failed: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So what happened? After all, the two capabilities are set with the &lt;em&gt;+ep&lt;/em&gt;
flags given. Then why aren't these capabilities enabled? Well, this
binary was stored on a file system that is mounted with the &lt;em&gt;nosuid&lt;/em&gt;
option. As a result, this capability is &lt;em&gt;not&lt;/em&gt; enabled and the
application didn't work. If I move the file to another file system that
doesn't have the &lt;em&gt;nosuid&lt;/em&gt; option:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ /usr/local/bin/test
cap_setuid and cap_setgid: 1
 = cap_setgid,cap_setuid+ep
 = cap_setgid,cap_setuid+ep
setresuid() failed: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So the capabilities now do get enabled, so why does this still fail?
This now is due to SELinux:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1367393377.342:4778): avc:  denied  { setuid } for  pid=21418 comm=&amp;quot;test&amp;quot; capability=7  scontext=staff_u:staff_r:staff_t tcontext=staff_u:staff_r:staff_t tclass=capability
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And if you enable grSecurity's TPE, we can't even start the binary to
begin with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ./test
-bash: ./test: Permission denied
$ /lib/ld-linux-x86-64.so.2 /home/test/test
/home/test/test: error while loading shared libraries: /home/test/test: failed to map segment from shared object: Permission denied

# dmesg
...
[ 5579.567842] grsec: From 192.168.100.1: denied untrusted exec (due to not being in trusted group and file in non-root-owned directory) of /home/test/test by /home/test/test[bash:4221] uid/euid:1002/1002 gid/egid:100/100, parent /bin/bash[bash:4195] uid/euid:1002/1002 gid/egid:100/100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When all these "security obstacles" are not enabled, then the call
succeeds:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ /usr/local/bin/test
cap_setuid and cap_setgid: 1
 = cap_setgid,cap_setuid+ep
 = cap_setgid,cap_setuid+ep
setresuid() failed: Success
root@hpl tmp #
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This again shows how important it is to regularly review
capability-enabled files on the file system, as this is a major security
problem that cannot be detected by only looking for setuid binaries, but
also that securing a system is not limited to one or a few settings: one
always has to take the entire setup into consideration, hardening the
system so it becomes more difficult for malicious users to abuse it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# filecap -a
file                 capabilities
/usr/local/bin/test     setgid, setuid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="Security"></category><category term="capabilities"></category><category term="grsecurity"></category><category term="linux"></category><category term="nosuid"></category><category term="selinux"></category><category term="tpe"></category></entry><entry><title>Capabilities, a short intro</title><link href="https://blog.siphos.be/2013/05/capabilities-a-short-intro/" rel="alternate"></link><published>2013-05-02T03:50:00+02:00</published><updated>2013-05-02T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-02:/2013/05/capabilities-a-short-intro/</id><summary type="html">&lt;p&gt;Capabilities. You probably have heard of them already, but when you
start developing SELinux policies, you'll notice that you come in closer
contact with them than before. This is because SELinux, when
applications want to do something "root-like", checks the capability of
that application. Without SELinux, this either requires the &lt;/p&gt;</summary><content type="html">&lt;p&gt;Capabilities. You probably have heard of them already, but when you
start developing SELinux policies, you'll notice that you come in closer
contact with them than before. This is because SELinux, when
applications want to do something "root-like", checks the capability of
that application. Without SELinux, this either requires the binary to
have the proper capability set, or the application to run in root modus.
With SELinux, the capability also needs to be granted to the SELinux
context (the domain in which the application runs).&lt;/p&gt;
&lt;p&gt;But forget about SELinux for now, and let's focus on capabilities.
Capabilities in Linux are flags that tell the kernel what the
application is allowed to do, but unlike file access, capabilities for
an application are system-wide: there is no "target" to which it
applies. Think about an "ability" of an application. See for yourself
through &lt;strong&gt;man capabilities&lt;/strong&gt;. If you have no additional security
mechanism in place, the Linux root user has all capabilities assigned to
it. And you can remove capabilities from the root user if you want to,
but generally, capabilities are used to grant applications that tiny bit
more privileges, without needing to grant them root rights.&lt;/p&gt;
&lt;p&gt;Consider the &lt;strong&gt;ping&lt;/strong&gt; utility. It is marked setuid root on some
distributions, because the utility requires the (cap)ability to send raw
packets. This capability is known as &lt;code&gt;CAP_NET_RAW&lt;/code&gt;. However, thanks to
capabilities, you can now mark the &lt;strong&gt;ping&lt;/strong&gt; application with this
capability and drop the setuid from the file. As a result, the
application does not run with full root privileges anymore, but with the
restricted privileges of the user plus one capability, namely the
&lt;code&gt;CAP_NET_RAW&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let's take this &lt;strong&gt;ping&lt;/strong&gt; example to the next level: copy the binary
(possibly relabel it as &lt;code&gt;ping_exec_t&lt;/code&gt; if you run with SELinux), make
sure it does not hold the setuid and try it out:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# cp ping anotherping
# chcon -t ping_exec_t anotherping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now as a regular user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ping -c 1 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.057 ms

$ anotherping -c 1 127.0.0.1
ping: icmp open socket: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's assign the binary with the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability flag:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# setcap cap_net_raw+ep anotherping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And tadaa:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ anotherping -c 1 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.054 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What &lt;strong&gt;setcap&lt;/strong&gt; did was place an extended attribute to the file, which
is a binary representation of the capabilities assigned to the
application. The additional information (&lt;code&gt;+ep&lt;/code&gt;) means that the
capability is &lt;em&gt;p&lt;/em&gt;ermitted and &lt;em&gt;e&lt;/em&gt;ffective.&lt;/p&gt;
&lt;p&gt;So long for the primer, I'll talk about the various capabilities in a
later post.&lt;/p&gt;</content><category term="Security"></category><category term="capabilities"></category><category term="linux"></category><category term="ping"></category><category term="selinux"></category></entry><entry><title>SELinux mount options</title><link href="https://blog.siphos.be/2013/05/selinux-mount-options/" rel="alternate"></link><published>2013-05-01T03:50:00+02:00</published><updated>2013-05-01T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-01:/2013/05/selinux-mount-options/</id><summary type="html">&lt;p&gt;When you read through the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml"&gt;Gentoo Hardened SELinux
handbook&lt;/a&gt;,
you'll notice that we sometimes update &lt;code&gt;/etc/fstab&lt;/code&gt; with some
SELinux-specific settings. So, what are these settings about and are
there more of them?&lt;/p&gt;
&lt;p&gt;First of all, let's look at a particular example from the installation
instructions so you see what &lt;/p&gt;</summary><content type="html">&lt;p&gt;When you read through the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml"&gt;Gentoo Hardened SELinux
handbook&lt;/a&gt;,
you'll notice that we sometimes update &lt;code&gt;/etc/fstab&lt;/code&gt; with some
SELinux-specific settings. So, what are these settings about and are
there more of them?&lt;/p&gt;
&lt;p&gt;First of all, let's look at a particular example from the installation
instructions so you see what I am talking about:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tmpfs  /tmp  tmpfs  defaults,noexec,nosuid,rootcontext=system_u:object_r:tmp_t  0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What the &lt;em&gt;rootcontext=&lt;/em&gt; option does here is to set the context of the
"root" of that file system (meaning, the context of &lt;code&gt;/tmp&lt;/code&gt; in the
example) to the specified context &lt;em&gt;before&lt;/em&gt; the file system is made
visible to the userspace. Because we do it soon, the file system is
known as &lt;code&gt;tmp_t&lt;/code&gt; throughout its life cycle (not just after the mount or
so).&lt;/p&gt;
&lt;p&gt;Another option that you'll frequently see on the Internet is the
&lt;em&gt;context=&lt;/em&gt; option. This option is most frequently used for file systems
that do not support extended attributes, and as such cannot store the
context of files on the file system. With the &lt;em&gt;context=&lt;/em&gt; mount option
set, all files on that file system get the specified context. For
instance, &lt;em&gt;context=system_u:object_r:removable_t&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If the file system does support extended attributes, you might find some
benefit in using the &lt;em&gt;defcontext=&lt;/em&gt; option. When set, the context of
files and directories (and other resources on that file system) that do
not have a SELinux context set yet will use this default context.
However, once a context is set, it will use that context instead.&lt;/p&gt;
&lt;p&gt;The last context-related mount option is &lt;em&gt;fscontext=&lt;/em&gt;. With this option,
you set the context of the "filesystem" class object of the file system
rather than the mount itself (or the files). Within SELinux,
"filesystem" is one of the resource classes that can get a context.
Remember the &lt;code&gt;/tmp&lt;/code&gt; mount example from before? Well, even though the
files are labeled &lt;code&gt;tmp_t&lt;/code&gt;, the file system context itself is still
&lt;code&gt;tmpfs_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is important to know that, if you use one of these mount options,
&lt;em&gt;context=&lt;/em&gt; is mutually exclusive to the other options as it "forces" the
context on all resources (including the filesystem class).&lt;/p&gt;</content><category term="SELinux"></category><category term="mount"></category><category term="selinux"></category></entry><entry><title>Securely handling libffi</title><link href="https://blog.siphos.be/2013/04/securely-handling-libffi/" rel="alternate"></link><published>2013-04-28T03:50:00+02:00</published><updated>2013-04-28T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-28:/2013/04/securely-handling-libffi/</id><summary type="html">&lt;p&gt;I've recently came across &lt;a href="http://sourceware.org/libffi/"&gt;libffi&lt;/a&gt; again.
No, not because it was mentioned during the &lt;a href="http://www.gentoo.org/proj/en/hardened"&gt;Gentoo
Hardened&lt;/a&gt; online meeting, but
because my &lt;code&gt;/var/tmp&lt;/code&gt; wasn't mounted correctly, and &lt;strong&gt;emerge&lt;/strong&gt; (actually
python) uses libffi. Most users won't notice this, because libffi works
behind the scenes. But when it fails, it fails bad &lt;/p&gt;</summary><content type="html">&lt;p&gt;I've recently came across &lt;a href="http://sourceware.org/libffi/"&gt;libffi&lt;/a&gt; again.
No, not because it was mentioned during the &lt;a href="http://www.gentoo.org/proj/en/hardened"&gt;Gentoo
Hardened&lt;/a&gt; online meeting, but
because my &lt;code&gt;/var/tmp&lt;/code&gt; wasn't mounted correctly, and &lt;strong&gt;emerge&lt;/strong&gt; (actually
python) uses libffi. Most users won't notice this, because libffi works
behind the scenes. But when it fails, it fails bad. And SELinux actually
helped me quickly identify what the problem is.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ emerge --info
segmentation fault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The abbreviation "libffi" comes from &lt;em&gt;Foreign Function Interface&lt;/em&gt;, and
is a library that allows developers to dynamically call code from
another application or library. But the method how it approaches this
concerns me a bit. Let's look at some &lt;strong&gt;strace&lt;/strong&gt; output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;8560  open(&amp;quot;/var/tmp/ffiZ8gKPd&amp;quot;, O_RDWR|O_CREAT|O_EXCL, 0600) = 11
8560  unlink(&amp;quot;/var/tmp/ffiZ8gKPd&amp;quot;)      = 0
8560  ftruncate(11, 4096)               = 0
8560  mmap(NULL, 4096, PROT_READ|PROT_EXEC, MAP_SHARED, 11, 0) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Generally, what libffi does, is to create a file somewhere where it can
write files (it checks the various mounts on a system to get a list of
possible target file systems), adds the necessary data (that it wants to
execute) to it, unlinks the file from the file system (but keep the file
descriptor open, so that the file cannot (easily) be modified on the
system anymore) and then maps it to memory for executable access. &lt;em&gt;If&lt;/em&gt;
executing is allowed by the system (for instance because the mount point
does not have &lt;code&gt;noexec&lt;/code&gt;), then SELinux will trap it because the domain
(in our case now, &lt;code&gt;portage_t&lt;/code&gt;) is trying to execute an (unlinked) file
for which it holds no execute rights on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1366656205.201:2221): avc:  denied  { execute } for  
pid=8560 comm=&amp;quot;emerge&amp;quot; path=2F7661722F66666962713154465A202864656C6574656429 
dev=&amp;quot;dm-3&amp;quot; ino=6912 scontext=staff_u:sysadm_r:portage_t tcontext=staff_u:object_r:var_t
tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When you notice something like this (an execute on an unnamed file),
then this is because the file descriptor points to a file already
unlinked from the system. Finding out what it was about might be hard
(but with &lt;strong&gt;strace&lt;/strong&gt; it is easy as ... well, whatever is easy for you).&lt;/p&gt;
&lt;p&gt;Now what happened was that, because &lt;code&gt;/var/tmp&lt;/code&gt; wasn't mounted, files
created inside it got the standard type (&lt;code&gt;var_t&lt;/code&gt;) which the Portage
domain isn't allowed to execute. It is allowed to execute a lot of
types, but not that one ;-) When &lt;code&gt;/var/tmp&lt;/code&gt; is properly mounted, the
file gets the &lt;code&gt;portage_tmp_t&lt;/code&gt; type where it does hold execute rights
for.&lt;/p&gt;
&lt;p&gt;Now generally, I don't like having world-writeable locations without
&lt;code&gt;noexec&lt;/code&gt;. For &lt;code&gt;/tmp&lt;/code&gt;, &lt;code&gt;noexec&lt;/code&gt; is enabled, but for &lt;code&gt;/var/tmp&lt;/code&gt; I have
(well, had ;-) to allow execution from the file system, mainly because
some (many?) Gentoo package builds require it. So how about this dual
requirement, of allowing Portage to write (and execute) its own files,
and allow libffi to do its magic? Certainly, from a security point of
view, I might want to restrict this further...&lt;/p&gt;
&lt;p&gt;Well, we need to make sure that the location where Portage works with
(the location pointed to by &lt;code&gt;$PORTAGE_TMPDIR&lt;/code&gt;) is specifically made
available for Portage: have the directory only writable by the Portage
user. I keep it labeled as &lt;code&gt;tmp_t&lt;/code&gt; so that the existing policies apply,
but it might work with &lt;code&gt;portage_tmp_t&lt;/code&gt; immediately set as well. Perhaps
I'll try that one later. With that set, we can have this mount-point set
with exec rights (so that libffi can place its file there) in a somewhat
more secure manner than allowing exec on world-writeable locations.&lt;/p&gt;
&lt;p&gt;So now my &lt;code&gt;/tmp&lt;/code&gt; and &lt;code&gt;/var/tmp&lt;/code&gt; (and &lt;code&gt;/run&lt;/code&gt; and &lt;code&gt;/dev/shm&lt;/code&gt; and
&lt;code&gt;/lib64/rc/init.d&lt;/code&gt;) are tmpfs-mounts with the &lt;code&gt;noexec&lt;/code&gt; (as well as
&lt;code&gt;nodev&lt;/code&gt; and &lt;code&gt;nosuid&lt;/code&gt;) bits set, with the location pointed towards by
&lt;code&gt;$PORTAGE_TMPDIR&lt;/code&gt; being only really usable by the Portage user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -ldZ /var/portage
drwxr-x---. 4 portage root system_u:object_r:tmp_t 4096 Apr 22 21:45 /var/portage/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And libffi? Well, allowing applications to create their own executables
and executing it is something that should be carefully governed. I'm not
aware of any existing or past vulnerabilities, but I can imagine that
opening the &lt;code&gt;ffi*&lt;/code&gt; file(s) the moment they come up (to make sure you
have a file descriptor) allows you to overwrite the content after libffi
has created it but before the application actually executes it. By
limiting the locations where applications can write files to (important
step one) and the types they can execute (important step two) we can
already manage this a bit more. Using regular DAC, this is quite
difficult to achieve, but with SELinux, we can actually control this a
bit more.&lt;/p&gt;
&lt;p&gt;Let's first see how many domains are allowed to create, write and
execute files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sesearch -c file -p write,create,execute -A | grep write | grep create   
 | grep execute | awk &amp;#39;{print $1}&amp;#39; | sort | uniq | wc -l
32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Okay, 32 target domains. Not that bad, and certainly doable to verify
manually (hell, even in a scripted manner). You can now check which of
those domains have rights to execute generic binaries (&lt;code&gt;bin_t&lt;/code&gt;),
possibly needed for command execution vulnerabilities or privilege
escalation. Or that have specific capabilities. And if you want to know
which of those domains use libffi, you can use &lt;strong&gt;revdep-rebuild&lt;/strong&gt; to
find out which files are linked to the libffi libraries.&lt;/p&gt;
&lt;p&gt;It goes to show that trying to keep your box secure is a never-ending
story (please, companies, allow your system administrators to do their
job by giving them the ability to continuously increase security rather
than have them ask for budget to investigate potential security
mitigation directives based on the paradigm of business case and return
on investment using pareto-analytics blaaaahhhh....), and that SELinux
can certainly be an important method to help achieve it.&lt;/p&gt;</content><category term="Security"></category><category term="libffi"></category><category term="selinux"></category><category term="strace"></category></entry><entry><title>How logins get their SELinux user context</title><link href="https://blog.siphos.be/2013/04/how-logins-get-their-selinux-user-context/" rel="alternate"></link><published>2013-04-27T03:50:00+02:00</published><updated>2013-04-27T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-27:/2013/04/how-logins-get-their-selinux-user-context/</id><summary type="html">&lt;p&gt;Sometimes, especially when users are converting their systems to be
SELinux-enabled, their user context is wrong. An example would be when,
after logon (in permissive mode), the user is in the
&lt;code&gt;system_u:system_r:local_login_t&lt;/code&gt; domain instead of a user domain like
&lt;code&gt;staff_u:staff_r:staff_t&lt;/code&gt;.&lt;br&gt;
So, how does a login get &lt;/p&gt;</summary><content type="html">&lt;p&gt;Sometimes, especially when users are converting their systems to be
SELinux-enabled, their user context is wrong. An example would be when,
after logon (in permissive mode), the user is in the
&lt;code&gt;system_u:system_r:local_login_t&lt;/code&gt; domain instead of a user domain like
&lt;code&gt;staff_u:staff_r:staff_t&lt;/code&gt;.&lt;br&gt;
So, how does a login get its SELinux user context?&lt;/p&gt;
&lt;p&gt;Let's look at the entire chain of SELinux context changes across a boot.
At first, when the system boots, the kernel (and all processes invoked
from it) run in the &lt;code&gt;kernel_t&lt;/code&gt; domain (I'm going to ignore the other
context fields for now until they become relevant). When the kernel
initialization has been completed, the kernel executes the &lt;strong&gt;init&lt;/strong&gt;
binary. When you use an initramfs, then a script might be called. This
actually doesn't matter that much yet, since SELinux stays within the
&lt;code&gt;kernel_t&lt;/code&gt; domain &lt;em&gt;until&lt;/em&gt; a SELinux-aware &lt;strong&gt;init&lt;/strong&gt; is launched.&lt;/p&gt;
&lt;p&gt;When the &lt;strong&gt;init&lt;/strong&gt; binary is executed, init of course starts. But as
mentioned, init is SELinux-aware, meaning it will invoke SELinux-related
commands. One of these is that it will load the SELinux policy (as
stored in &lt;code&gt;/etc/selinux&lt;/code&gt;) and then reexecute itself. Because of that,
its process context changes from &lt;code&gt;kernel_t&lt;/code&gt; towards &lt;code&gt;init_t&lt;/code&gt;. This is
because the &lt;strong&gt;init&lt;/strong&gt; binary itself is labeled as &lt;code&gt;init_exec_t&lt;/code&gt; and a
type transition is defined from &lt;code&gt;kernel_t&lt;/code&gt; towards &lt;code&gt;init_t&lt;/code&gt; when
&lt;code&gt;init_exec_t&lt;/code&gt; is executed.&lt;/p&gt;
&lt;p&gt;Ok, so &lt;strong&gt;init&lt;/strong&gt; now runs in &lt;code&gt;init_t&lt;/code&gt; and it goes on with whatever it
needs to do. This includes invoking init scripts (which, btw, run in
&lt;code&gt;initrc_t&lt;/code&gt; because the scripts are labeled &lt;code&gt;initrc_exec_t&lt;/code&gt; or with a
type that has the &lt;code&gt;init_script_file_type&lt;/code&gt; attribute set, and a
transition from &lt;code&gt;init_t&lt;/code&gt; to &lt;code&gt;initrc_t&lt;/code&gt; is defined when such files are
executed). When the bootup is finally completed, &lt;strong&gt;init&lt;/strong&gt; launches the
&lt;em&gt;getty&lt;/em&gt; processes. The commands are mentioned in &lt;code&gt;/etc/inittab&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ grep getty /etc/inittab
c1:12345:respawn:/sbin/agetty --noclear 38400 tty1 linux
c2:2345:respawn:/sbin/agetty 38400 tty2 linux
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;These binaries are also explicitly labeled &lt;code&gt;getty_exec_t&lt;/code&gt;. As a result,
the &lt;strong&gt;getty&lt;/strong&gt; (or &lt;strong&gt;agetty&lt;/strong&gt;) processes run in the &lt;code&gt;getty_t&lt;/code&gt; domain
(because a transition is defined from &lt;code&gt;init_t&lt;/code&gt; to &lt;code&gt;getty_t&lt;/code&gt; when
&lt;code&gt;getty_exec_t&lt;/code&gt; is executed). Ok, so gettys run in &lt;code&gt;getty_t&lt;/code&gt;. But what
happens when a user now logs on to the system?&lt;/p&gt;
&lt;p&gt;Well, the getty's invoke the &lt;strong&gt;login&lt;/strong&gt; binary which, you guessed it
right, is labeled as something: &lt;code&gt;login_exec_t&lt;/code&gt;. As a result (because,
again, a transition is defined in the policy), the login process runs as
&lt;code&gt;local_login_t&lt;/code&gt;. Now the login process invokes the various PAM
subroutines which follow the definitions in &lt;code&gt;/etc/pam.d/login&lt;/code&gt;. On
Gentoo systems, this by default points to the &lt;code&gt;system-local-login&lt;/code&gt;
definitions which points to the &lt;code&gt;system-login&lt;/code&gt; definitions. And in this
definition, especially under the sessions section, we find a reference
to &lt;code&gt;pam_selinux.so&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;session         required        pam_selinux.so close
...
session         required        pam_selinux.so multiple open
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now here is where some of the magic starts (see my post on &lt;a href="http://blog.siphos.be/2012/12/using-pam_selinux-to-switch-contexts/"&gt;Using
pam_selinux to switch
contexts&lt;/a&gt;
for the gritty details). The methods inside the &lt;code&gt;pam_selinux.so&lt;/code&gt; binary
will look up what the context should be for a user login. For instance,
when the &lt;em&gt;root&lt;/em&gt; user logs on, it has SELinux checking what SELinux user
&lt;em&gt;root&lt;/em&gt; is mapped to, equivalent to running &lt;strong&gt;semanage login -l&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ semanage login -l | grep ^root
root                      root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this case, the SELinux user for root is &lt;em&gt;root&lt;/em&gt;, but this is not
always the case (that login and user are the same). For instance, my
regular administrative account maps to the &lt;em&gt;staff_u&lt;/em&gt; SELinux user.&lt;/p&gt;
&lt;p&gt;Next, it checks what the default context should be for this user. This
is done by checking the &lt;code&gt;default_contexts&lt;/code&gt; file (such as the one in
&lt;code&gt;/etc/selinux/strict/contexts&lt;/code&gt; although user-specific overrides can be
(and are) placed in the &lt;code&gt;users&lt;/code&gt; subdirectory) based on the context of
the process that is asking SELinux what the default context should be.
In our case, it is the &lt;strong&gt;login&lt;/strong&gt; process running as &lt;code&gt;local_login_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ grep -HR local_login_t /etc/selinux/strict/contexts/*
default_contexts:system_r:local_login_t user_r:user_t staff_r:staff_t sysadm_r:sysadm_t unconfined_r:unconfined_t
users/unconfined_u:system_r:local_login_t               unconfined_r:unconfined_t
users/guest_u:system_r:local_login_t            guest_r:guest_t
users/user_u:system_r:local_login_t             user_r:user_t
users/staff_u:system_r:local_login_t            staff_r:staff_t sysadm_r:sysadm_t
users/root:system_r:local_login_t  unconfined_r:unconfined_t sysadm_r:sysadm_t staff_r:staff_t user_r:user_t
users/xguest_u:system_r:local_login_t   xguest_r:xguest_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since we are verifying this for the &lt;em&gt;root&lt;/em&gt; SELinux user, the following
line of the &lt;code&gt;users/root&lt;/code&gt; file is what matters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system_r:local_login_t  unconfined_r:unconfined_t sysadm_r:sysadm_t staff_r:staff_t user_r:user_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, SELinux looks for the first match in that line that the user has
access to. This is defined by the roles that the user is allowed to
access:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ semanage user -l | grep root
root            staff_r sysadm_r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As &lt;em&gt;root&lt;/em&gt; is allowed both the &lt;em&gt;staff_r&lt;/em&gt; and &lt;em&gt;sysadm_r&lt;/em&gt; roles, the
first one found &lt;em&gt;in the default context file&lt;/em&gt; that matches will be used.
So it is &lt;em&gt;not&lt;/em&gt; the order in which the roles are displayed in the
&lt;strong&gt;semanage user -l&lt;/strong&gt; output that matters, but the order of the contexts
in the &lt;em&gt;default context&lt;/em&gt; file. In the example, this is
&lt;code&gt;sysadm_r:sysadm_t&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system_r:local_login_t  unconfined_r:unconfined_t sysadm_r:sysadm_t staff_r:staff_t user_r:user_t
                        &amp;lt;-----------+-----------&amp;gt; &amp;lt;-------+-------&amp;gt; &amp;lt;------+------&amp;gt; &amp;lt;-----+-----&amp;gt;
                                    `- no matching role   `- first (!)     `- second      `- no match
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now that we know what the context &lt;em&gt;should&lt;/em&gt; be, this is used for the
first execution that the process (still &lt;strong&gt;login&lt;/strong&gt;) will do. So &lt;strong&gt;login&lt;/strong&gt;
changes the Linux user (if applicable) and invokes the shell of that
user. Because this is the first execution that is done by &lt;strong&gt;login&lt;/strong&gt;, the
new context is set (being &lt;code&gt;root:sysadm_r:sysadm_t&lt;/code&gt;) for the shell.&lt;/p&gt;
&lt;p&gt;And that is why, if you run &lt;strong&gt;id -Z&lt;/strong&gt;, it returns the user context
(&lt;code&gt;root:sysadm_r:sysadm_t&lt;/code&gt;) if everything works out fine ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="context"></category><category term="selinux"></category><category term="user"></category></entry><entry><title>New SELinux userspace release</title><link href="https://blog.siphos.be/2013/04/new-selinux-userspace-release/" rel="alternate"></link><published>2013-04-26T03:50:00+02:00</published><updated>2013-04-26T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-26:/2013/04/new-selinux-userspace-release/</id><summary type="html">&lt;p&gt;A new &lt;a href="http://userspace.selinuxproject.org/trac/wiki/Releases"&gt;release&lt;/a&gt;
of the SELinux userspace utilities was recently announced. I have made
the packages for Gentoo available and they should now be in the main
tree (\~arch of course). During the testing of the packages however, I
made a stupid mistake of running the tests on the wrong &lt;/p&gt;</summary><content type="html">&lt;p&gt;A new &lt;a href="http://userspace.selinuxproject.org/trac/wiki/Releases"&gt;release&lt;/a&gt;
of the SELinux userspace utilities was recently announced. I have made
the packages for Gentoo available and they should now be in the main
tree (\~arch of course). During the testing of the packages however, I
made a stupid mistake of running the tests on the wrong VM, one that
didn't contain the new packages. Result: no regressions (of course). My
fault for not using in-ebuild tests properly, as I
&lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=465846"&gt;should&lt;/a&gt;. So you'll
probably see me blogging about the in-ebuild testing soon ;-)&lt;/p&gt;
&lt;p&gt;In any case, the regressions I did find out (quite fast after I updated
my main laptop with them as well) where a &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=467258"&gt;missing function in
libselinux&lt;/a&gt;, a &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=467264"&gt;referral
to a non-existing makefile when using "semanage
permissive"&lt;/a&gt; and the new
&lt;strong&gt;sepolicy&lt;/strong&gt; application &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=467268"&gt;requiring yum python
bindings&lt;/a&gt;. At least,
with the missing function (hopefully correctly) resolved, all tests I
usually do (except for the permissive domains) are now running well
again.&lt;/p&gt;
&lt;p&gt;This only goes to show how important testing is. Of course, I
&lt;a href="http://marc.info/?l=selinux&amp;amp;m=136692033821285&amp;amp;w=2"&gt;reported&lt;/a&gt; the bugs
on the mailinglist of the userspace utilities as well. Hopefully they
can look at them while I'm asleep so I can integrate fixes tomorrow more
easily ;-)&lt;/p&gt;</content><category term="Gentoo"></category><category term="automation"></category><category term="regression"></category><category term="release"></category><category term="selinux"></category><category term="test"></category><category term="testing"></category><category term="userspace"></category></entry><entry><title>Using strace to troubleshoot SELinux problems</title><link href="https://blog.siphos.be/2013/04/using-strace-to-troubleshoot-selinux-problems/" rel="alternate"></link><published>2013-04-24T03:50:00+02:00</published><updated>2013-04-24T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-24:/2013/04/using-strace-to-troubleshoot-selinux-problems/</id><summary type="html">&lt;p&gt;When SELinux is playing tricks on you, you can just "allow" whatever it
wants to do, but that is not always an option: sometimes, there is no
denial in sight because the problem lays within SELinux-aware
applications (applications that might change their behavior based on
what the policy sais or &lt;/p&gt;</summary><content type="html">&lt;p&gt;When SELinux is playing tricks on you, you can just "allow" whatever it
wants to do, but that is not always an option: sometimes, there is no
denial in sight because the problem lays within SELinux-aware
applications (applications that might change their behavior based on
what the policy sais or even based on if SELinux is enabled or not). At
other times, you get a strange behavior that isn't directly visible what
the cause is. But mainly, if you want to make sure that allowing
something is correct (and not just a corrective action), you need to be
absolutely certain that what you want to allow is security-wise
acceptable.&lt;/p&gt;
&lt;p&gt;To debug such issues, I often take the &lt;strong&gt;strace&lt;/strong&gt; command to debug the
application at hand. To use &lt;strong&gt;strace&lt;/strong&gt;, I toggle the &lt;em&gt;allow_ptrace&lt;/em&gt;
boolean (&lt;strong&gt;strace&lt;/strong&gt; uses &lt;code&gt;ptrace()&lt;/code&gt; which, by default, isn't allowed
policy-wise) and then run the offending application through &lt;strong&gt;strace&lt;/strong&gt;
(or attach to the running process if it is a daemon). For instance, to
debug a &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=463222"&gt;tmux issue&lt;/a&gt; we
had with the policy not that long ago:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# setsebool allow_ptrace on
# strace -o strace.log -f -s 256 tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The resulting log file (strace.log) might seem daunting at first to look
at. What you see are the system calls that the process is performing,
together with their options but also the return code of each call. This
is especially important as SELinux, if it denies something, often
returns something like EACCESS (Permission Denied).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;7313  futex(0x349e016f080, FUTEX_WAKE_PRIVATE, 2147483647) = 0
7313  futex(0x5aad58fd84, FUTEX_WAKE_PRIVATE, 2147483647) = 0
7313  stat(&amp;quot;/&amp;quot;, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7313  stat(&amp;quot;/home&amp;quot;, {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7313  stat(&amp;quot;/home/swift&amp;quot;, {st_mode=S_IFDIR|0755, st_size=12288, ...}) = 0
7313  stat(&amp;quot;/home/swift/.pki&amp;quot;, {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7313  stat(&amp;quot;/home/swift/.pki/nssdb&amp;quot;, {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7313  statfs(&amp;quot;/home/swift/.pki/nssdb&amp;quot;, 0x3c3cab6fa50) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Most (if not all) of the methods shown in a strace log are documented
through manpages, so you can quickly find out that &lt;code&gt;futex()&lt;/code&gt; is about
fast user-space locking, &lt;code&gt;stat()&lt;/code&gt; (&lt;strong&gt;man 2 stat&lt;/strong&gt; to see the information
about the method instead of the application) is about getting file
status and &lt;code&gt;statfs()&lt;/code&gt; is for getting file system statistics.&lt;/p&gt;
&lt;p&gt;The most common permission issues you'll find are file related:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;7313  open(&amp;quot;/proc/filesystems&amp;quot;, O_RDONLY) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the above case, you notice that the application is trying to open the
&lt;code&gt;/proc/filesystems&lt;/code&gt; file read-only. In the SELinux logs, this might be
displayed as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;audit.log:type=AVC msg=audit(1365794728.180:3192): avc:  denied  { read } for  
pid=860 comm=&amp;quot;nacl_helper_boo&amp;quot; name=&amp;quot;filesystems&amp;quot; dev=&amp;quot;proc&amp;quot; ino=4026532034 
scontext=staff_u:staff_r:chromium_naclhelper_t tcontext=system_u:object_r:proc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the case of &lt;strong&gt;tmux&lt;/strong&gt; before was not an obvious one. In the end, I
compared the strace output's of two runs (one in enforcing and one in
permissive) to find what the difference would be. This is the result:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Enforcing:

10905 fcntl(9, F_GETFL) = 0x8000 (flags O_RDONLY|O_LARGEFILE) 
10905 fcntl(9, F_SETFL, O_RDONLY|O_NONBLOCK|O_LARGEFILE) = 0

Permissive:

10905 fcntl(9, F_GETFL) = 0x8002 (flags O_RDWR|O_LARGEFILE) 
10905 fcntl(9, F_SETFL, O_RDWR|O_NONBLOCK|O_LARGEFILE) = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You notice the difference? In enforcing-mode, one of the flags on the
file descriptor has &lt;code&gt;O_RDONLY&lt;/code&gt; whereas the one in permissive mode as
&lt;code&gt;O_RDWR&lt;/code&gt;. This means that the file descriptor in enforcing mode is
read-only whereas in permissive-mode is read-write. What we then do in
the strace logs is to see where this file descriptor (with id=9) comes
from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;10905 dup(0)     = 9
10905 dup(1)     = 10
10905 dup(2)     = 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As the man-pages sais, &lt;code&gt;dup()&lt;/code&gt; duplicates a file descriptor. And
because, by convention, the first three file descriptors of an
application correspond with standard input (0), standard output (1) and
error output (2), we now know that the file descriptor with id=9 comes
from the standard input file descriptor. Although this one should be
read-only (it is the input that the application gets = reads), it seems
that tmux might want to use this for writes as well. And that is what
happens - tmux sends the file descriptor to the tmux server to check if
it is a tty and then uses it to write to the screen.&lt;/p&gt;
&lt;p&gt;Now what does that have to do with SELinux? It has to mean something,
otherwise running in permissive mode would give the same result. After
some investigation, we found out that using &lt;strong&gt;newrole&lt;/strong&gt; to switch roles
changes the flags of the standard input (as then provided by
&lt;strong&gt;newrole&lt;/strong&gt;) from &lt;code&gt;O_RDWR&lt;/code&gt; to &lt;code&gt;O_RDONLY&lt;/code&gt; (code snippet from &lt;code&gt;newrole.c&lt;/code&gt;
- look at the first call to &lt;code&gt;open()&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/* Close the tty and reopen descriptors 0 through 2 */
if (ttyn) {
        if (close(fd) || close(0) || close(1) || close(2)) {
                fprintf(stderr, _(&amp;quot;Could not close descriptors.\n&amp;quot;));
                goto err_close_pam;
        }
        fd = open(ttyn, O_RDONLY | O_NONBLOCK);
        if (fd != 0)
                goto err_close_pam;
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) &amp;amp; ~O_NONBLOCK);
        fd = open(ttyn, O_RDWR | O_NONBLOCK);
        if (fd != 1)
                goto err_close_pam;
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) &amp;amp; ~O_NONBLOCK);
        fd = open(ttyn, O_RDWR | O_NONBLOCK);
        if (fd != 2)
                goto err_close_pam;
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) &amp;amp; ~O_NONBLOCK);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Such obscure problems are much easier to detect and troubleshoot thanks
to tools like &lt;strong&gt;strace&lt;/strong&gt;.&lt;/p&gt;</content><category term="SELinux"></category><category term="debug"></category><category term="selinux"></category><category term="strace"></category></entry><entry><title>SLOT'ing the old swig-1</title><link href="https://blog.siphos.be/2013/04/sloting-the-old-swig-1/" rel="alternate"></link><published>2013-04-23T03:50:00+02:00</published><updated>2013-04-23T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-23:/2013/04/sloting-the-old-swig-1/</id><summary type="html">&lt;p&gt;The &lt;a href="http://www.swig.org"&gt;SWIG&lt;/a&gt; tool helps developers in building
interfaces/libraries that can be accessed from many other languages than
the ones the library is initially written in or for. The SELinux
userland utility &lt;a href="http://oss.tresys.com/projects/setools"&gt;setools&lt;/a&gt; uses
it to provide Python and Ruby interfaces even though the application
itself is written in C &lt;/p&gt;</summary><content type="html">&lt;p&gt;The &lt;a href="http://www.swig.org"&gt;SWIG&lt;/a&gt; tool helps developers in building
interfaces/libraries that can be accessed from many other languages than
the ones the library is initially written in or for. The SELinux
userland utility &lt;a href="http://oss.tresys.com/projects/setools"&gt;setools&lt;/a&gt; uses
it to provide Python and Ruby interfaces even though the application
itself is written in C. Sadly, the tool currently requires swig-1 for
its building of the interfaces and uses constructs that do not seem to
be compatible with swig-2 (same with the apse package, btw).&lt;/p&gt;
&lt;p&gt;I first tried to &lt;a href="http://comments.gmane.org/gmane.comp.security.selinux/17822"&gt;patch
setools&lt;/a&gt; to
support swig-2, but eventually found regressions in the libapol library
it provides so the patch didn't work out (that is why some users
mentioned that a previous setools version did build with swig - yes it
did, but the result wasn't correct). Recently, a &lt;a href="https://plus.google.com/117641514179258643044/posts/gNrhVDuwGzp"&gt;post on Google Plus'
SELinux
community&lt;/a&gt;
showed me that I wasn't wrong in this matter (it really does require
swig-1 and doesn't seem to be trivial to fix).&lt;/p&gt;
&lt;p&gt;Hence, I have to fix the &lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=453512"&gt;gentoo build
problem&lt;/a&gt; where one set
of tools requires swig-1 and another swig-2. Otherwise world-updates and
even building stages for SELinux systems would fail as Portage finds
incompatible dependencies. One way to approach this is to use Gentoo's
support for
&lt;a href="http://devmanual.gentoo.org/general-concepts/slotting/"&gt;SLOTs&lt;/a&gt;. When a
package (ebuild) in Gentoo defines a SLOT, it tells the package manager
that the same package but a different version might be installed
alongside the package if that has a different SLOT version. In case of
swig, the idea is to give swig-1 a different slot than swig-2 (which
uses &lt;code&gt;SLOT="0"&lt;/code&gt;) and make sure that both do not install the same files
(otherwise you get file collisions).&lt;/p&gt;
&lt;p&gt;Luckily, swig places all of its files except for the &lt;strong&gt;swig&lt;/strong&gt; binary
itself in &lt;code&gt;/usr/share/swig/&amp;lt;version&amp;gt;&lt;/code&gt;, so all I had left to do was to
make sure the binary itself is renamed. I chose to use &lt;strong&gt;swig1.3&lt;/strong&gt;
(similar as to how tools like &lt;strong&gt;ruby&lt;/strong&gt; and &lt;strong&gt;python&lt;/strong&gt; and for some
packages even &lt;strong&gt;java&lt;/strong&gt; is implemented on Gentoo). The result (through
&lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=466650"&gt;bug 466650&lt;/a&gt;) is now in
the tree, as well as an adapted setools package that uses the new swig
SLOT.&lt;/p&gt;
&lt;p&gt;Thanks to Samuli Suominen for getting me on the (hopefully ;-) right
track. I don't know why I was afraid of doing this, it was much less
complex than I thought (now let's hope I didn't break other things ;-)&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="selinux"></category><category term="setools"></category><category term="slot"></category><category term="swig"></category></entry><entry><title>Introducing selocal for small SELinux policy enhancements</title><link href="https://blog.siphos.be/2013/04/introducing-selocal-for-small-selinux-policy-enhancements/" rel="alternate"></link><published>2013-04-21T03:50:00+02:00</published><updated>2013-04-21T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-21:/2013/04/introducing-selocal-for-small-selinux-policy-enhancements/</id><summary type="html">&lt;p&gt;When working with a SELinux-enabled system, administrators will
eventually need to make small updates to the existing policy. Instead of
building their own full policy (always an option, but most likely not
maintainable in the long term) one or more SELinux policy modules are
created (most distributions use a modular &lt;/p&gt;</summary><content type="html">&lt;p&gt;When working with a SELinux-enabled system, administrators will
eventually need to make small updates to the existing policy. Instead of
building their own full policy (always an option, but most likely not
maintainable in the long term) one or more SELinux policy modules are
created (most distributions use a modular approach to the SELinux policy
development) which are then loaded on their target systems.&lt;/p&gt;
&lt;p&gt;In the past, users had to create their own policy module by creating
(and maintaining) the necessary &lt;code&gt;.te&lt;/code&gt; file(s), building the proper &lt;code&gt;.pp&lt;/code&gt;
files and loading it in the active policy store. In Gentoo, from
&lt;code&gt;policycoreutils-2.1.13-r11&lt;/code&gt; onwards, a script is provided to the users
that hopefully makes this a bit more intuitive for regular users:
&lt;strong&gt;selocal&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As the name implies, &lt;strong&gt;selocal&lt;/strong&gt; aims to provide an interface for
handling &lt;em&gt;local&lt;/em&gt; policy updates that do not need to be packaged or
distributed otherwise. It is a command-line application that you feed
single policy rules at one at a time. Each rule can be accompanied with
a single-line comment, making it obvious for the user to know why he
added the rule in the first place.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --help
Usage: selocal [] []

Command can be one of:
  -l, --list            List the content of a SELinux module
  -a, --add             Add an entry to a SELinux module
  -d, --delete          Remove an entry from a SELinux module
  -M, --list-modules    List the modules currently known by selocal
  -u, --update-dep      Update the dependencies for the rules
  -b, --build           Build the SELinux module (.pp) file (requires privs)
  -L, --load            Load the SELinux module (.pp) file (requires privs)

Options can be one of:
  -m, --module          Module name to use (default: selocal)
  -c, --comment        Comment (with --add)

The option -a requires that a rule is given, like so:
  selocal -a &amp;quot;dbadm_role_change(staff_r)&amp;quot;
The option -d requires that a line number, as shown by the --list, is given, like so:
  selocal -d 12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's say that you need to launch a small script you written as a
daemon, but you want this to run while you are still in the &lt;em&gt;staff_t&lt;/em&gt;
domain (it is a user-sided daemon you use personally). As regular
&lt;em&gt;staff_t&lt;/em&gt; isn't allowed to have processes bind on generic ports/nodes,
you need to enhance the SELinux policy a bit. With &lt;strong&gt;selocal&lt;/strong&gt;, you can
do so as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --add &amp;quot;corenet_tcp_bind_generic_node(staff_t)&amp;quot; --comment &amp;quot;Launch local webserv.py daemon&amp;quot;
# selocal --add &amp;quot;corenet_tcp_bind_generic_port(staff_t)&amp;quot; --comment &amp;quot;Launch local webserv.my daemon&amp;quot;
# selocal --build --load
(some output on building the policy module)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When finished, the local policy is enhanced with the two mentioned
rules. You can query which rules are currently stored in the policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --list
12: corenet_tcp_bind_generic_node(staff_t) # Launch local webserv.py daemon
13: corenet_tcp_bind_generic_port(staff_t) # Launch local webserv.py daemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you need to delete a rule, just pass the line number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --delete 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Having this tool around also makes it easier to test out changes
suggested through bugreports. When I test such changes, I add in the bug
report ID as the comment so I can track which settings are still local
and which ones have been pushed to our policy repository. Underlyingly,
&lt;strong&gt;selocal&lt;/strong&gt; creates and maintains the necessary policy file in
&lt;path&gt;\~/.selocal&lt;/path&gt; and by default uses the &lt;em&gt;selocal&lt;/em&gt; policy module
name.&lt;/p&gt;
&lt;p&gt;I hope this tool helps users with their quest on using SELinux. Feedback
and comments are always appreciated! It is a small bash script and might
still have a few bugs in it, but I have been using it for a few months
so most quirks should be handled.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="policy"></category><category term="selinux"></category><category term="selocal"></category></entry><entry><title>Another Gentoo Hardened month has passed</title><link href="https://blog.siphos.be/2013/04/another-gentoo-hardened-month-has-passed/" rel="alternate"></link><published>2013-04-18T23:36:00+02:00</published><updated>2013-04-18T23:36:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-18:/2013/04/another-gentoo-hardened-month-has-passed/</id><summary type="html">&lt;p&gt;Another month has passed, so time to mention again what we have all been
doing lately ;-)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Toolchain&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Version 4.8 of GCC is available in the tree, but currently masked. The
package contains a fix needed to build hardened-sources, and a fix for
the asan (address sanitizer).
&lt;a href="http://www.internetnews.com/blog/skerner/open-source-gcc-4.8-compiler-including-address-sanitizer-security.html"&gt;asan&lt;/a&gt;
support in &lt;/p&gt;</summary><content type="html">&lt;p&gt;Another month has passed, so time to mention again what we have all been
doing lately ;-)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Toolchain&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Version 4.8 of GCC is available in the tree, but currently masked. The
package contains a fix needed to build hardened-sources, and a fix for
the asan (address sanitizer).
&lt;a href="http://www.internetnews.com/blog/skerner/open-source-gcc-4.8-compiler-including-address-sanitizer-security.html"&gt;asan&lt;/a&gt;
support in GCC 4.8 might be seen as an improvement security-wise, but it
is yet unclear if it is an integral part of GCC or could be disabled
with a configure flag. Apparently, asan "makes building gcc 4.8 crazy".
Seeing that it comes from Google, and building Google Chromium is also
crazy, I start seeing a pattern here.&lt;/p&gt;
&lt;p&gt;Anyway, it turns out that PaX/grSec and asan do not get along yet (ASAN
assumes/uses hardcoded userland address space size values, which breaks
when UDEREF is set as it pitches a bit from the size):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ERROR: AddressSanitizer failed to allocate 0x20000001000 (2199023259648) bytes at address 0x0ffffffff000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Given that this is hardcoded in the resulting binaries, it isn't
sufficient to change the size value from 47 bits to 46 bits as hardened
systems can very well boot a kernel with and another kernel without
UDEREF, causing the binaries to fail on the other kernel. Instead, a
proper method would be to dynamically check the size of a userland
address.&lt;/p&gt;
&lt;p&gt;However, GCC 4.8 also brings along some nice enhancements and features.
uclibc profiles work just fine with GCC 4.8, including armv7a and
mips/mipsel. The latter is especially nice to hear, since mips used to
require significant effort with previous GCCs.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Kernel and grSecurity/PaX&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;More recent kernels have now been stabilized to stay close to the
grSecurity/PaX upstream developments. The most recent stable kernel now
is hardened-sources-3.8.3. Others still available are hardened-sources
versions 3.2.40-r1 and 2.6.32-r156.&lt;/p&gt;
&lt;p&gt;The support for XATTR_PAX is still progressing, but a few issues have
come up. One is that non-hardened systems are seeing warnings about
&lt;strong&gt;pax-mark&lt;/strong&gt; not being able to set the XATTR_PAX on tmpfs since vanilla
kernels do not have the patch to support &lt;code&gt;user.*&lt;/code&gt; extended attribute
namespaces for tmpfs. A second issue is that the &lt;strong&gt;install&lt;/strong&gt;
application, as provided by &lt;code&gt;coreutils&lt;/code&gt;, does not copy extended
attributes. This has impact on ebuilds where pax markings are done
before the install phase of a package. But only doing pax markings after
the install phase isn't sufficient either, since sometimes we need the
binaries to be marked already for test phases or even in the compile
phase. So this is still something on the near horizon.&lt;/p&gt;
&lt;p&gt;Most likely the necessary tools will be patched to include extended
attributes on copy operations. However, we need to take care only to
copy over those attributes that make sense: &lt;code&gt;user.pax&lt;/code&gt; does, but
security ones like &lt;code&gt;security.evm&lt;/code&gt; and &lt;code&gt;security.selinux&lt;/code&gt; shouldn't as
those are either recomputed when needed, or governed through policy. The
idea is that USE="pax_kernel" will enable the above on &lt;code&gt;coreutils&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SELinux&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The SELinux support in Gentoo has seen a fair share of updates on the
userland utilities (like policycoreutils, setools, libselinux and such).
Most of these have already made the stable tree or are close to be
bumped to stable. The SELinux policy also has been updated a lot: most
changes can be tracked through bugzilla, looking for the
&lt;code&gt;sec-policy r13&lt;/code&gt; whiteboard. The changes can be applied to the system
immediately if you use the live ebuilds (like &lt;code&gt;selinux-base-9999&lt;/code&gt;), but
I'm planning on releasing revision 13 of our policy set soon.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;System Integrity&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Some of the "early adopter" problems we've noticed on Gentoo Hardened
have been integrated in the repositories upstream and are slowly
progressing towards the main Linux kernel tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Profiles&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;All hardened profiles have been moved to the 13.0 base. Some people
frowned when they noticed that the uclibc profiles do not inherit from
any architecture-related profile. This is however with reason: the
architecture profiles are (amongst other reasons) focusing on the glibc
specifics of the architecture. Since the profile intended here is for
uclibc, those changes are not needed (nor wanted). Hence, these are
collapsed in a single profile.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Documentation&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For SELinux, the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml"&gt;SELinux
handbook&lt;/a&gt;
now includes information about USE="unconfined" as well as the
&lt;code&gt;selinux_gentoo&lt;/code&gt; init script as provided by &lt;code&gt;policycoreutils&lt;/code&gt;. Users who
are already running with SELinux enabled can just look at the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml?part=2&amp;amp;chap=7"&gt;Change
History&lt;/a&gt;
to see which changes affect them.&lt;/p&gt;
&lt;p&gt;A set of &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials"&gt;tutorials&lt;/a&gt;
(which I've blogged about earlier as well) have been put online at the
&lt;a href="https://wiki.gentoo.org"&gt;Gentoo Wiki&lt;/a&gt;. Next to the SELinux tutorials,
an article pertaining to &lt;a href="https://wiki.gentoo.org/wiki/AIDE"&gt;AIDE&lt;/a&gt; has
been added as well as it fits nicely within the principles/concepts of
the &lt;a href="http://www.gentoo.org/proj/en/hardened/integrity/index.xml"&gt;System
Integrity&lt;/a&gt;
subproject.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Media&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you don't do it already, start following
&lt;a href="https://twitter.com/GentooHardened"&gt;@GentooHardened&lt;/a&gt; ;-)&lt;/p&gt;</content><category term="Gentoo"></category><category term="asan"></category><category term="gcc"></category><category term="Gentoo"></category><category term="grsecurity"></category><category term="hardened"></category><category term="integrity"></category><category term="irc"></category><category term="meeting"></category><category term="pax"></category><category term="selinux"></category><category term="uderef"></category></entry><entry><title>What could SELinux have done to mitigate the postgresql vulnerability?</title><link href="https://blog.siphos.be/2013/04/what-could-selinux-have-done-to-mitigate-the-postgresql-vulnerability/" rel="alternate"></link><published>2013-04-16T14:00:00+02:00</published><updated>2013-04-16T14:00:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-16:/2013/04/what-could-selinux-have-done-to-mitigate-the-postgresql-vulnerability/</id><summary type="html">&lt;p&gt;&lt;a href="http://www.gentoo.org"&gt;Gentoo&lt;/a&gt; is one of the various distributions
which supports &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux"&gt;SELinux&lt;/a&gt;
as a &lt;em&gt;Mandatory Access Control&lt;/em&gt; system to, amongst other things,
mitigate the results of a succesfull exploit against software. So what
about the recent &lt;a href="http://www.postgresql.org/support/security/faq/2013-04-04/"&gt;PostgreSQL
vulnerability&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;When correctly configured, the PostgreSQL daemon will run in the
&lt;code&gt;postgresql_t&lt;/code&gt; domain. In SELinux-speak &lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.gentoo.org"&gt;Gentoo&lt;/a&gt; is one of the various distributions
which supports &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux"&gt;SELinux&lt;/a&gt;
as a &lt;em&gt;Mandatory Access Control&lt;/em&gt; system to, amongst other things,
mitigate the results of a succesfull exploit against software. So what
about the recent &lt;a href="http://www.postgresql.org/support/security/faq/2013-04-04/"&gt;PostgreSQL
vulnerability&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;When correctly configured, the PostgreSQL daemon will run in the
&lt;code&gt;postgresql_t&lt;/code&gt; domain. In SELinux-speak, a domain can be seen as a name
granted to a set of permissions (what is allowed) and assigned to one or
more processes. A process that "runs in domain postgresql_t" will be
governed by the policy rules (what is and isn't allowed) for that
domain.&lt;/p&gt;
&lt;p&gt;The vulnerability we speak of is about creating new files or overwriting
existing files, potentially corrupting the database itself (when the
database files are overwritten). Creating new files is handled through
the &lt;em&gt;create&lt;/em&gt; privilege on files (and &lt;em&gt;add_name&lt;/em&gt; on directories),
writing into files is handled through the &lt;em&gt;write&lt;/em&gt; privilege. Given
certain circumstances, one could even &lt;a href="http://blog.blackwinghq.com/2013/04/08/2/"&gt;write commands inside
files&lt;/a&gt; that are executed by
particular users on the system (btw, the link gives a great explanation
on the vulnerability).&lt;/p&gt;
&lt;p&gt;So let's look at what SELinux does and could have done.&lt;/p&gt;
&lt;p&gt;In the current situation, as we explained, &lt;code&gt;postgresql_t&lt;/code&gt; is the only
domain we need to take into account (the PostgreSQL policy does not use
separate domains for the runtime processes). Let's look at what
directory labels it is allowed to write into:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sesearch -s postgresql_t -c dir -p add_name -SCATd
Found 11 semantic av rules:
   allow postgresql_t postgresql_log_t : dir { add_name } ; 
   allow postgresql_t var_log_t : dir { add_name } ; 
   allow postgresql_t var_lock_t : dir { add_name } ; 
   allow postgresql_t tmp_t : dir { add_name } ; 
   allow postgresql_t postgresql_tmp_t : dir { add_name } ; 
   allow postgresql_t postgresql_var_run_t : dir { add_name } ; 
   allow postgresql_t postgresql_db_t : dir { add_name } ; 
   allow postgresql_t etc_t : dir { add_name } ; 
   allow postgresql_t tmpfs_t : dir { add_name } ; 
   allow postgresql_t var_lib_t : dir { add_name } ; 
   allow postgresql_t var_run_t : dir { add_name } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So the PostgreSQL service is allowed to create files inside directories
labeled with one of the following labels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;postgresql_log_t&lt;/code&gt;, used for PostgreSQL log files
    (&lt;code&gt;/var/log/postgresql&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var_log_t&lt;/code&gt;, used for the generic log files (&lt;code&gt;/var/log&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var_lock_t&lt;/code&gt;, used for lock files (&lt;code&gt;/run/lock&lt;/code&gt; or &lt;code&gt;/var/lock&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmp_t&lt;/code&gt;, used for the temporary file directory (&lt;code&gt;/tmp&lt;/code&gt; or
    &lt;code&gt;/var/tmp&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postgresql_tmp_t&lt;/code&gt;, used for the PostgreSQL temporary
    files/directories&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postgresql_var_run_t&lt;/code&gt;, used for the runtime information (like
    PID files) of PostgreSQL (&lt;code&gt;/var/run/postgresql&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postgresql_db_t&lt;/code&gt;, used for the PostgreSQL database files
    (&lt;code&gt;/var/lib/postgresql&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etc_t&lt;/code&gt;, used for the generic system configuration files (&lt;code&gt;/etc/&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var_lib_t&lt;/code&gt;, used for the &lt;code&gt;/var/lib&lt;/code&gt; data&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var_run_t&lt;/code&gt;, used for the &lt;code&gt;/var/run&lt;/code&gt; or &lt;code&gt;/run&lt;/code&gt; data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next to this, depending on the label of the directory, the PostgreSQL
service is allowed to write into files with the following label assigned
(of importance to both creating new files as well as overwriting
existing ones):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sesearch -s postgresql_t -c file -p write -SCATd
Found 11 semantic av rules:
   allow postgresql_t postgresql_log_t : file { write } ; 
   allow postgresql_t postgresql_lock_t : file { write } ; 
   allow postgresql_t faillog_t : file { write } ; 
   allow postgresql_t lastlog_t : file { write } ; 
   allow postgresql_t postgresql_tmp_t : file { write } ; 
   allow postgresql_t hugetlbfs_t : file { write } ; 
   allow postgresql_t postgresql_var_run_t : file { write } ; 
   allow postgresql_t postgresql_db_t : file { write } ; 
   allow postgresql_t postgresql_t : file { write } ; 
   allow postgresql_t security_t : file { write } ; 
   allow postgresql_t etc_t : file { write } ;

Found 6 semantic te rules:
   type_transition postgresql_t var_log_t : file postgresql_log_t; 
   type_transition postgresql_t var_lock_t : file postgresql_lock_t; 
   type_transition postgresql_t tmp_t : file postgresql_tmp_t; 
   type_transition postgresql_t tmpfs_t : file postgresql_tmp_t; 
   type_transition postgresql_t var_lib_t : file postgresql_db_t; 
   type_transition postgresql_t var_run_t : file postgresql_var_run_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If an exploit creates a new file, the &lt;em&gt;add_name&lt;/em&gt; permission on the
directory is needed. If otoh the exploit is overwriting existing files,
I think the only permission needed here is the &lt;em&gt;write&lt;/em&gt; on the files
(also &lt;em&gt;open&lt;/em&gt; but all the writes have &lt;em&gt;open&lt;/em&gt; as well in the above case).&lt;/p&gt;
&lt;p&gt;Now accessing and being able to write files into the database file
directory is expected - it is the functionality of the server, so unless
we could separate domains more, this is a "hit" we need to take. Sadly
though, this is also the label used for the PostgreSQL service account
home directory here (not sure if this is for all distributions), making
it more realistic that an attacker writes something in the home
directory &lt;code&gt;.profile&lt;/code&gt; file and hopes for the administrator to do
something like &lt;strong&gt;su postgres -&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Next, the &lt;code&gt;etc_t&lt;/code&gt; write privileges also worry me, not mainly because it
can write there, but also because I can hardly understand why -
PostgreSQL is supposed to run under its own, non-root user (luckily) so
unless there are &lt;code&gt;etc_t&lt;/code&gt; labeled directories owned by the PostgreSQL
service account (or world writeable - please no, kthx). And this isn't
an "inherited" permission from something - the policy currently has
&lt;code&gt;files_manage_etc_files(postgresql_t)&lt;/code&gt; set, and has been since 2005 or
earlier. I'm really wondering if this is still needed.&lt;/p&gt;
&lt;p&gt;But I digress. Given that there are no PostgreSQL-owned directories nor
world-writeable ones in &lt;code&gt;/etc&lt;/code&gt;, let's look at a few other ones.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;security_t&lt;/code&gt; is used for the SELinux pseudo file system, and is used
    for the SEPostgreSQL support. From the looks of it, only the root
    Linux user has the rights to do really harmful things on this file
    system (and only if he too has write permissions on &lt;code&gt;security_t&lt;/code&gt;),
    non-root should be limited to verifying if contexts exist or have
    particular rights. Still, I might investigate this further as I'm
    intrigued about many of the pseudo files in &lt;code&gt;/sys/fs/selinux&lt;/code&gt; that
    I'm not fully sure yet what they deal with.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmp_t&lt;/code&gt; should not be a major concern. Most (if not all) daemons and
    services that use temporary files have file transitions to their own
    type so that access to these files, even if it would be allowed by
    regular permissions, is still prohibited by SELinux&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lastlog_t&lt;/code&gt; is also a weird one, again because it shouldn't be
    writeable for anyone else but root accounts; if succesfull, an
    attacker can overwrite the lastlog information which might be used
    by some as a means for debugging who was logged on when (part
    of forensics).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given the information above, it is a bit sad to see that SELinux can't
protect PostgreSQL users from this particular vulnerability - most of
the "mitigation" (if any) is because the process runs as non-root to
begin with (which is another hint at users not to think SELinux is
sufficient to restrict the permissions of processes). But could it have
been different?&lt;/p&gt;
&lt;p&gt;In my opinion, yes, and I'll see if we can learn from it for the future.&lt;/p&gt;
&lt;p&gt;First of all, we should do more policy code auditing. It might not be
easy to remove policy rules generally, but we should at least try. I use
a small script that enables auditing (SELinux auditing, so &lt;em&gt;auditallow&lt;/em&gt;
statements) for the entire domain, and then selectively disables
auditing until I get no hits anymore. The remainder of &lt;em&gt;auditallow&lt;/em&gt;
statements warrant a closer look to see if they are still needed or not.
I'll get onto that in the next few days.&lt;/p&gt;
&lt;p&gt;Second, we might want to have service accounts use a different home
directory, where they do have the necessary search privileges for, but
no write privileges. Exploits that write stuff into a home directory
(hoping for a &lt;strong&gt;su postgresql -&lt;/strong&gt;) are then mitigated a bit.&lt;/p&gt;
&lt;p&gt;Third, we might want to look into separating the domains according to
the architecture of the service. This requires intimate knowledge of the
ins and outs of PostgreSQL and might even require PostgreSQL patching,
so is not something light. But if no patching is needed (such as when
all process launches are done using known file executions) we could have
a separate domain for the master process, server processes and perhaps
even the various subfunction processes (like the WAL writer, BG writer,
etc.). The Postfix service has such a more diverse (but also complex)
policy. Such a subdomain structure in the policy might reduce the risk
if the vulnerable process (I think this is the master process) does not
need to write to database files (as this is handled by other processes),
so no &lt;code&gt;postgresql_db_t&lt;/code&gt; write privileges.&lt;/p&gt;
&lt;p&gt;If others have ideas on how we can improve service security (for
instance through SELinux policy development) or knows of other exploits
related to this vulnerability that I didn't come across yet, please give
a comment on it below.&lt;/p&gt;</content><category term="Security"></category><category term="postgresql"></category><category term="selinux"></category><category term="vulnerability"></category></entry><entry><title>Not needing run_init for password-less service management</title><link href="https://blog.siphos.be/2013/04/not-needing-run_init-for-password-less-service-management/" rel="alternate"></link><published>2013-04-09T22:14:00+02:00</published><updated>2013-04-09T22:14:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-09:/2013/04/not-needing-run_init-for-password-less-service-management/</id><summary type="html">&lt;p&gt;One of the things that has been bugging me was why, even with having
&lt;code&gt;pam_rootok.so&lt;/code&gt; set in &lt;code&gt;/etc/pam.d/run_init&lt;/code&gt;, I cannot enjoy
passwordless service management without using &lt;strong&gt;run_init&lt;/strong&gt; directly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# rc-service postgresql-9.2 status
Authenticating root.
Password:

# run_init rc-service postgresql-9.2 status
Authenticating root.
 * status: started
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So I &lt;/p&gt;</summary><content type="html">&lt;p&gt;One of the things that has been bugging me was why, even with having
&lt;code&gt;pam_rootok.so&lt;/code&gt; set in &lt;code&gt;/etc/pam.d/run_init&lt;/code&gt;, I cannot enjoy
passwordless service management without using &lt;strong&gt;run_init&lt;/strong&gt; directly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# rc-service postgresql-9.2 status
Authenticating root.
Password:

# run_init rc-service postgresql-9.2 status
Authenticating root.
 * status: started
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So I decided to &lt;strong&gt;strace&lt;/strong&gt; the two commands and look for the
differences. I found out that there is even a SELinux permission for
being able to use the &lt;em&gt;rootok&lt;/em&gt; setting for passwords! Apparently,
&lt;code&gt;pam_rootok.so&lt;/code&gt; is SELinux-aware and does some additional checks.&lt;/p&gt;
&lt;p&gt;Although I don't know the exact details of it, it looks for the context
before the call (exec) of &lt;strong&gt;run_init&lt;/strong&gt; occurred. Then it checks if this
domain has the right for &lt;em&gt;passwd { rootok }&lt;/em&gt; (unless SELinux is in
permissive, in which case it just continues) and only then it allows the
"rootok" to succeed.&lt;/p&gt;
&lt;p&gt;Now why doesn't this work without using &lt;strong&gt;run_init&lt;/strong&gt;? I think it has to
do with how we integrate &lt;strong&gt;run_init&lt;/strong&gt; in the scripts, because out of
the trace I found that the previous context was also &lt;em&gt;run_init_t&lt;/em&gt;
(instead of &lt;em&gt;sysadm_t&lt;/em&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;20451 open(&amp;quot;/proc/self/task/20451/attr/current&amp;quot;, O_RDONLY) = 3
20451 read(3, &amp;quot;root:sysadm_r:run_init_t\0&amp;quot;, 4095) = 25
20451 close(3)                          = 0
20451 gettid()                          = 20451
20451 open(&amp;quot;/proc/self/task/20451/attr/prev&amp;quot;, O_RDONLY) = 3
20451 read(3, &amp;quot;root:sysadm_r:run_init_t\0&amp;quot;, 4095) = 25
20451 close(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Because there already is a transition to &lt;em&gt;run_init_t&lt;/em&gt; upon calling the
scripts, the underlying call to &lt;strong&gt;runscripts&lt;/strong&gt; causes the "previous"
attribute to be set to &lt;em&gt;run_init_t&lt;/em&gt; as well, and only then is
&lt;strong&gt;run_init&lt;/strong&gt; called (which then causes the PAM functions to be called).
But by prepending the commands with &lt;strong&gt;run_init&lt;/strong&gt; (which quickly causes
the PAM functions to be called) the previous context is &lt;em&gt;sysadm_t&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I tested on a system with the following policy update, and this succeeds
nicely.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(localruninit, 1.0)

gen_require(`
  class passwd { passwd chfn chsh rootok };
  type run_init_t;
&amp;#39;)

allow run_init_t self:passwd rootok;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I'll probably add this in Gentoo's policy.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="hardened"></category><category term="pam"></category><category term="rootok"></category><category term="run_init"></category><category term="selinux"></category></entry><entry><title>Separate puppet provider for Gentoo/SELinux?</title><link href="https://blog.siphos.be/2013/04/separate-puppet-provider-for-gentooselinux/" rel="alternate"></link><published>2013-04-07T19:22:00+02:00</published><updated>2013-04-07T19:22:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-07:/2013/04/separate-puppet-provider-for-gentooselinux/</id><summary type="html">&lt;p&gt;While slowly transitioning my playground infrastructure towards Puppet,
I already am in process of creating a custom provider for things such as
services. Puppet uses providers as "implementations" for the functions
Puppet needs. For instance, for the &lt;em&gt;service&lt;/em&gt; type (which handles init
script services), there are providers for RedHat, Debian &lt;/p&gt;</summary><content type="html">&lt;p&gt;While slowly transitioning my playground infrastructure towards Puppet,
I already am in process of creating a custom provider for things such as
services. Puppet uses providers as "implementations" for the functions
Puppet needs. For instance, for the &lt;em&gt;service&lt;/em&gt; type (which handles init
script services), there are providers for RedHat, Debian, FreeBSD, ...
and it also has providers called &lt;em&gt;gentoo&lt;/em&gt; and &lt;em&gt;openrc&lt;/em&gt;. The &lt;em&gt;openrc&lt;/em&gt; one
uses the service scripts that Gentoo's OpenRC provides, such as
&lt;strong&gt;rc-service&lt;/strong&gt; and &lt;strong&gt;rc-status&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;On a SELinux-enabled system, and especially when using a decentralized
Puppet environment (I dropped the puppet master set in favor of a
decentralized usage of Puppet), if you call &lt;strong&gt;rc-service&lt;/strong&gt; to, say,
start a service, it will ask for the users' password. Of course, Puppet
doesn't want this, so I have to prefix the commands with &lt;strong&gt;run_init&lt;/strong&gt;
and have a &lt;code&gt;pam_rootok.so&lt;/code&gt; rule in run_init's PAM definition.&lt;/p&gt;
&lt;p&gt;So far that's a simple change - I just patched the &lt;code&gt;openrc.rb&lt;/code&gt; file to
do so. But then the second problem I'm facing is that Puppet wants to
use return code based commands for checking the run-time state of
services. Even though some of my services weren't running, Puppet either
thought they were or called the start routine and consider the service
started. Sadly that wasn't the case, as the rc-* scripts always return
0 (you'll need to parse the output).&lt;/p&gt;
&lt;p&gt;So what I did now is to create a simple script called &lt;code&gt;runstatus&lt;/code&gt; which
returns the state of services. It's crude, but seems to work:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nv"&gt;SERVICENAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;# We need to exit:&lt;/span&gt;
&lt;span class="c1"&gt;# 0 - if running&lt;/span&gt;
&lt;span class="c1"&gt;# 1 - if dead but PID exists&lt;/span&gt;
&lt;span class="c1"&gt;# 2 - if dead but lock file exists&lt;/span&gt;
&lt;span class="c1"&gt;# 3 - if not running&lt;/span&gt;
&lt;span class="c1"&gt;# 4 - if unknown&lt;/span&gt;

rc-status -a -C &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;SERVICENAME&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -q started &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
rc-status -a -C &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;SERVICENAME&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -q stopped &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;I then have the service provider (I now provide my own instead of
patching the openrc one) call &lt;strong&gt;runstatus&lt;/strong&gt; to get the state of a
service, as well as call it after trying to start a service. But as this
is quite basic functioning, I'm wondering if I'm doing things the right
way or not. Who else has experience with Puppet and Gentoo, and did you
have to tweak things to get services and such working?&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="openrc"></category><category term="provider"></category><category term="puppet"></category><category term="selinux"></category></entry><entry><title>Fiddling with puppet apply</title><link href="https://blog.siphos.be/2013/03/fiddling-with-puppet-apply/" rel="alternate"></link><published>2013-03-20T12:31:00+01:00</published><updated>2013-03-20T12:31:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-03-20:/2013/03/fiddling-with-puppet-apply/</id><summary type="html">&lt;p&gt;As part of a larger exercise, I am switching my local VM set from a
more-or-less scripted manual configuration towards a fully
Puppet-powered one. Of course, it still uses a lot of custom modules and
is most likely too ugly to expose to the wider internet, but it does
seem &lt;/p&gt;</summary><content type="html">&lt;p&gt;As part of a larger exercise, I am switching my local VM set from a
more-or-less scripted manual configuration towards a fully
Puppet-powered one. Of course, it still uses a lot of custom modules and
is most likely too ugly to expose to the wider internet, but it does
seem to improve my ability to quickly rebuild images if I corrupt them
somehow.&lt;/p&gt;
&lt;p&gt;One of the tricks I am using is to use a local apply instead of using a
Puppet master server - mainly because that master server is again a VM
that might need to be build up and consumes some resources that I'd
rather have free for other VMs. So what I do now is akin to the
following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# puppet apply --modulepath /mnt/puppet/modules /mnt/puppet/manifests/site.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;All I have to do is make sure that the /mnt/puppet location is a shared
resource (in my case, an NFSv4 read-only mount) which I can just mount
on a fresh image.&lt;/p&gt;
&lt;p&gt;Part of this exercise I noticed that Puppet by default uses the regular
&lt;em&gt;gentoo&lt;/em&gt; provider for the services. I'd like to use the &lt;em&gt;openrc&lt;/em&gt;
provider instead, as I can easily tweak that one to work with SELinux (I
need to prepend &lt;strong&gt;run_init&lt;/strong&gt; to the &lt;strong&gt;rc-service&lt;/strong&gt; calls, otherwise
SELinux wants to authenticate the user and Puppet doesn't like that; I
have a pam_rootok.so statement in the run_init PAM file to allow
unattended calls towards rc-service).&lt;/p&gt;
&lt;p&gt;A quick Google revealed that all I had to do was to add a &lt;em&gt;provider
=&amp;gt; openrc&lt;/em&gt; in the service definitions, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;service { &amp;quot;net.eth0&amp;quot;:
  provider =&amp;gt; openrc,
  ensure =&amp;gt; running,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As mentioned, I still manually patch the openrc provider (located in
/usr/lib64/ruby/site_ruby/1.9.1/puppet/provider/service) so that the
run_init command is known as well, and that all invocations of the
rc-service is prepended with run_init:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
  commands :runinit =&amp;gt; &amp;#39;/usr/sbin/run_init&amp;#39;
  commands :rcservice =&amp;gt; &amp;#39;/sbin/rc-service&amp;#39;
...
 [command(:runinit), command(:rcservice), @resource[:name], :start ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the same for the stop and status definitions. I might use Portage'
postinst hook to automatically apply the patch so I don't need to do
this manually each time.&lt;/p&gt;</content><category term="Gentoo"></category><category term="provider"></category><category term="puppet"></category><category term="selinux"></category><category term="service"></category></entry><entry><title>SELinux tutorial series</title><link href="https://blog.siphos.be/2013/03/selinux-tutorial-series/" rel="alternate"></link><published>2013-03-15T00:34:00+01:00</published><updated>2013-03-15T00:34:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-03-15:/2013/03/selinux-tutorial-series/</id><summary type="html">&lt;p&gt;As we get a growing number of SELinux users within Gentoo Hardened and
because the SELinux usage at the firm I work at is most likely going to
grow as well, I decided to join the bunch of documents on SELinux that
are "out there" and start a series of &lt;/p&gt;</summary><content type="html">&lt;p&gt;As we get a growing number of SELinux users within Gentoo Hardened and
because the SELinux usage at the firm I work at is most likely going to
grow as well, I decided to join the bunch of documents on SELinux that
are "out there" and start a series of my own. After all, too much
documentation probably doesn't hurt, and SELinux definitely deserves a
lot of documentation.&lt;/p&gt;
&lt;p&gt;I decided to use the &lt;a href="https://wiki.gentoo.org"&gt;Gentoo Wiki&lt;/a&gt; for this
endeavour instead of a GuideXML approach (which is the format used for
Gentoo documentation on the main site). The set of tutorials that I
already wrote can be found under the
&lt;a href="https://wiki.gentoo.org/wiki/SELinux"&gt;SELinux&lt;/a&gt; : &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials"&gt;Gentoo Hardened
SELinux Tutorials&lt;/a&gt;
location. Although of course meant to support the Gentoo Hardened
SELinux users, I'm hoping to keep the initial set of tutorial articles
deliberately distribution-independent so I can refer to them at work as
well.&lt;/p&gt;
&lt;p&gt;For now (this is a week's work, so don't expect this amount of tutorials
to double in the next few days) I wrote about the security context of a
process, how SELinux controls file and directory accesses, where to find
SELinux permission denial details, controlling file contexts yourself
and how a process gets into a certain context.&lt;/p&gt;
&lt;p&gt;I hope I can keep the articles in good shape and with a gradual step-up
in complexity. That does mean that most articles are not complete (for
instance, when talking about domain transitions, I don't talk about
constraints that might prohibit them, or about the role and type
mismatches (invalid context) that you might get, etc.) and that those
details will follow in later articles. Hopefully that allows users to
learn step by step.&lt;/p&gt;
&lt;p&gt;At the end of each tutorial, you will find a "What you need to remember"
section. This is a very short overview of what was said in the tutorial
and that you will need to know in future articles. If you ever read a
tutorial article, then this section might be sufficient for you to
remember again what it was about - no need to reread the entire article.&lt;/p&gt;
&lt;p&gt;Consider it an attempt at a &lt;code&gt;tl;dr&lt;/code&gt; for articles ;-) Enjoy your reading,
and if you have any remarks, don't hesitate to contribute on the wiki or
talk through the "Talk" pages.&lt;/p&gt;</content><category term="SELinux"></category><category term="articles"></category><category term="documentation"></category><category term="Gentoo"></category><category term="hardened"></category><category term="selinux"></category><category term="tutorials"></category><category term="wiki"></category></entry><entry><title>Gentoo Hardened progress meeting of march 2013</title><link href="https://blog.siphos.be/2013/03/gentoo-hardened-progress-meeting-of-march-2013/" rel="alternate"></link><published>2013-03-07T22:46:00+01:00</published><updated>2013-03-07T22:46:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-03-07:/2013/03/gentoo-hardened-progress-meeting-of-march-2013/</id><summary type="html">&lt;p&gt;Another month has passed, so time for a new progress meeting...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Toolchain&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GCC v4.7 has been unmasked, allowing a large set of users to test out
the new GCC. It is also expected that GCC 4.8-rc1 will hit the tree next
week. In the hardened-dev overlay, hardened support &lt;/p&gt;</summary><content type="html">&lt;p&gt;Another month has passed, so time for a new progress meeting...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Toolchain&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GCC v4.7 has been unmasked, allowing a large set of users to test out
the new GCC. It is also expected that GCC 4.8-rc1 will hit the tree next
week. In the hardened-dev overlay, hardened support for x86, amd64 and
arm has been added (SPEC updates) and the remainder of architectures
will be added by the end of the week.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kernel and grSecurity/PaX&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kernel 3.7.5 had a security issue (local root privilege escalation) so
3.7.5-r1 which held a fix for this was stabilized quickly. However,
other (non-security) problems have been reported, such as one with
dovecot, regarding the VSIZE memory size. This should be fixed in the
3.8 series, so these are candidate for a faster stabilization. This
faster stabilization is never fun, as it increases the likelihood that
we miss other things, but they are needed as the vulnerability in the
previous stable kernel was too severe.&lt;/p&gt;
&lt;p&gt;Regarding XATTR_PAX, we are getting pretty close to the migration. The
eclass is ready and will be announced for review on the appropriate
mailinglists later this week. A small problem still remains on
Paludis-using systems (Paludis does not record NEEDED.ELF.2 information
- linkage information - so it is hard to get all the linkage information
on a system). A different revdep-pax and migrate-pax toolset will be
built that detects the necessary linkage information, but much slower
than on a Portage-running system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELinux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The 11th revision of the policies are now stable, and work is on the way
for the 12th revision which will hit the tree soon. Some work is on the
way for setools and policycoreutils (one due to a new release - setools
- and the other one due to a build failure if PAM is not set). Both
packages will hit the hardened-dev overlay soon.&lt;/p&gt;
&lt;p&gt;A new "edition" of the selinuxnode virtual image has been pushed to the
mirror system, providing a SELinux-enabled (enforcing) Gentoo Hardened
system with grSecurity and PaX, as well as IMA and EVM enabled.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Profiles&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The 13.0 profiles have been running fine for a while at a few of our
developer systems. No changes have been needed (yet) so things are
looking good.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Integrity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The necessary userland utilities have been moved to the main tree. The
documentation for IMA/EVM has been updated as well to reflec the current
state of IMA/EVM within Gentoo Hardened. IMA, even with the custom
policies, seems to be working well. EVM on the other hand has some
issues, so you might need to run with EVM=fix for now. Debugging on this
issue is on the way.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Some of the user oriented documentation (integrity and SELinux) have
been moved to the Gentoo Wiki for easier user contributions and
simplified management. Other documents will follow soon.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="grsecurity"></category><category term="hardened"></category><category term="kernel"></category><category term="pax"></category><category term="profiles"></category><category term="selinux"></category><category term="toolchain"></category></entry><entry><title>Uploading selinuxnode test VM</title><link href="https://blog.siphos.be/2013/02/uploading-selinuxnode-test-vm/" rel="alternate"></link><published>2013-02-25T03:05:00+01:00</published><updated>2013-02-25T03:05:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-02-25:/2013/02/uploading-selinuxnode-test-vm/</id><summary type="html">&lt;p&gt;At the time of writing (but I'll delay the publication of this post a
few hours), I'm uploading a new SELinux-enabled KVM guest image. This is
not an update on the previous image though (it's a reinstalled system -
after all, I use VMs for testing, so it makes sense to &lt;/p&gt;</summary><content type="html">&lt;p&gt;At the time of writing (but I'll delay the publication of this post a
few hours), I'm uploading a new SELinux-enabled KVM guest image. This is
not an update on the previous image though (it's a reinstalled system -
after all, I use VMs for testing, so it makes sense to reinstall from
time to time to check if the installation instructions are still
accurate). However, the focus remains the same:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A minimal Gentoo Linux installation for amd64 (x86_64) as guest
    within a KVM hypervisor. The image is about 190 Mb in size
    compressed, and 1.6 Gb in size uncompressed. The file format is
    Qemu's QCOW2 so expect the image to grow as you work with it. The
    file systems are, in total, sized to about 50 Gb.&lt;/li&gt;
&lt;li&gt;The installation has SELinux enabled (strict policy, enforcing
    mode), various grSecurity settings enabled (including PaX and TPE),
    but now also includes IMA (Integrity Measurement Architecture) and
    EVM (Extended Verification Module) although EVM is by default
    started in fix mode.&lt;/li&gt;
&lt;li&gt;The image will not start any network-facing daemons by default
    (unlike the previous image) for security reasons (if I let this
    image stay around this long as I did with the previous, it's prone
    to have some vulnerabilities in the future, although I'm hoping I
    can update the image more frequently). This includes SSH, so you'll
    need access to the image console first after which you can configure
    the network and start SSH (&lt;strong&gt;run_init rc-service sshd start&lt;/strong&gt; does
    the trick).&lt;/li&gt;
&lt;li&gt;A couple of default accounts are created, and the image will display
    those accounts and their passwords on the screen (it is a test/play
    VM, not a production VM).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are still a few minor issues with it, that I hope to fix by the
next upload:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://bugs.gentoo.org/show_bug.cgi?id=457812"&gt;Bug 457812&lt;/a&gt; is
    still applicable to the image, so you'll notice lots of SELinux
    denials on the mknod capability. They seem to be cosmetic though.&lt;/li&gt;
&lt;li&gt;At shutdown, udev somewhere fails with a SELinux initial
    context problem. I thought I had it covered, but I noticed after
    compressing the image that it is still there. I'll fix it - I
    promise ;)&lt;/li&gt;
&lt;li&gt;EVM is enabled in fix mode, because otherwise EVM is &lt;a href="http://sourceforge.net/mailarchive/forum.php?thread_name=1361476641.29360.114.camel%40falcor1&amp;amp;forum_name=linux-ima-user"&gt;prohibiting
    mode
    changes&lt;/a&gt;
    on files in /run. I still have to investigate this further though -
    I had to use the EVM=fix workaround due to time pressure.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When uploaded, I'll ask the Gentoo infrastructure team to synchronise
the image with our mirrors so you can enjoy it. It'll be on the
distfiles, under experimental/amd64/qemu-selinux (it has the 20130224
date in the name, so you can see for yourself if the sync has already
occurred or not).&lt;/p&gt;</content><category term="Gentoo"></category><category term="evm"></category><category term="Gentoo"></category><category term="grsecurity"></category><category term="hardened"></category><category term="ima"></category><category term="kvm"></category><category term="selinux"></category><category term="virtual"></category></entry><entry><title>Working on a new selinuxnode VM</title><link href="https://blog.siphos.be/2013/02/working-on-a-new-selinuxnode-vm/" rel="alternate"></link><published>2013-02-23T14:04:00+01:00</published><updated>2013-02-23T14:04:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-02-23:/2013/02/working-on-a-new-selinuxnode-vm/</id><summary type="html">&lt;p&gt;A long time ago, I made a &lt;a href="http://distfiles.gentoo.org/experimental/amd64/qemu-selinux/"&gt;SELinux enabled
VM&lt;/a&gt; for
people to play with, displaying a minimal Gentoo installation, including
the hardening features it supports (PIE/PIC toolchain, grSecurity, PaX
and SELinux). I'm currently trying to create a new one, which also
includes IMA/EVM, but it looks like &lt;/p&gt;</summary><content type="html">&lt;p&gt;A long time ago, I made a &lt;a href="http://distfiles.gentoo.org/experimental/amd64/qemu-selinux/"&gt;SELinux enabled
VM&lt;/a&gt; for
people to play with, displaying a minimal Gentoo installation, including
the hardening features it supports (PIE/PIC toolchain, grSecurity, PaX
and SELinux). I'm currently trying to create a new one, which also
includes IMA/EVM, but it looks like I still have many things to
investigate further...&lt;/p&gt;
&lt;p&gt;First of all, I notice that many SELinux domains want to use the mknod
capability, even for domains of which I have no idea whatsoever why they
need it. I don't notice any downsides though, and running in permissive
mode doesn't change the domain behavior. But still, I'm reluctant to
mark them dontaudit as long as I'm not 100% sure.&lt;/p&gt;
&lt;p&gt;Second, the gettys (I think it is the getty) result in a "Cannot change
SELinux context: permission denied" error, even though everything is
running in the right SELinux context. I still have to confirm if it
really is the getty process or something else (the last run I had the
impression it was a udev-related process). But there are no denials and
no SELinux errors in the logs.&lt;/p&gt;
&lt;p&gt;Third, during shutdown, many domains have problems accessing their PID
files in /var/run (which is a link to /run). I most likely need to allow
read privileges on all domains that have access to var_run_t towards
the var_t symlinks. It isn't a problem per se (the processes still run
correctly) but ugly as hell, and if you introduce monitoring it'll go
haywire (as no PID files were either found, or were stale).&lt;/p&gt;
&lt;p&gt;Also, EVM is giving me a hard time, not allowing me to change mode and
ownership in files on /var/run. I have received some feedback from the
IMA user list on this so it is still very much a work-in-progress.&lt;/p&gt;
&lt;p&gt;Finally, the first attempt to generate a new VM resulted in a download
of 817 MB (instead of the 158 MB of the previous release), so I still
have to correct my USE flags and doublecheck the installed applications.
Anyway, definitely to be continued. Too bad time is a scarce resource
:-(&lt;/p&gt;</content><category term="Gentoo"></category><category term="evm"></category><category term="Gentoo"></category><category term="hardened"></category><category term="ima"></category><category term="selinux"></category><category term="selinuxnode"></category><category term="vm"></category></entry><entry><title>Gentoo Hardened goes onward (aka project meeting)</title><link href="https://blog.siphos.be/2013/02/gentoo-hardened-goes-onward-aka-project-meeting/" rel="alternate"></link><published>2013-02-07T23:40:00+01:00</published><updated>2013-02-07T23:40:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-02-07:/2013/02/gentoo-hardened-goes-onward-aka-project-meeting/</id><summary type="html">&lt;p&gt;It's been a while again, so time for another Gentoo Hardened online
progress meeting.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Toolchain&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;GCC 4.8 is on development stage 4, so the hardened patches will be
worked on next week. Some help on it is needed to test the patches on
ARM, PPC and MIPS though. For &lt;/p&gt;</summary><content type="html">&lt;p&gt;It's been a while again, so time for another Gentoo Hardened online
progress meeting.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Toolchain&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;GCC 4.8 is on development stage 4, so the hardened patches will be
worked on next week. Some help on it is needed to test the patches on
ARM, PPC and MIPS though. For those interested, keep a close eye on the
hardened-dev overlay as those will contain the latest fixes. When GCC
4.9 starts development phase 1, Zorry will again try to upstream the
patches.&lt;/p&gt;
&lt;p&gt;With the coming fixes, we might probably (need to) remove the various
hardenedno* GCC profiles from the hardened Gentoo profiles. This
shouldn't impact too many users as ebuilds add in the correct flags
anyhow (for instance when needing to turn off PIE/PIC).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Kernel, grSecurity and PaX&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The kernel release 3.7.0 that we have stable in our tree has seen a few
setbacks, but no higher version is stable yet (mainly due to the
stabilization period needed). 3.7.4-r1 and 3.7.5 are prime candidates
with good track record,&lt;br&gt;
so we might be stabilizing 3.7.5 in the very near future (next week
probably).&lt;/p&gt;
&lt;p&gt;On the PaX flag migration (you know, from ELF-header based marking to
extended attributes marking), the documentation has seen its necessary
upgrades and the userland utilities have been updated to reflect the use
of xattr markings. The eclass we use for the markings will use the
correct utility based on the environment.&lt;/p&gt;
&lt;p&gt;One issue faced when trying to support both markings is that some
actions (like the "paxctl -Cc" which creates the PT_PAX header if it is
missing) make no sense with the other (as there is no header when using
XATTR_PAX). The eclass will be updated to ignore these flags when
XATTR_PAX is selected.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SELinux&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Revision 10 is stable in the tree, and revision 11 is waiting
stabilization period. A few more changes have been put in the policy
repository already (which are installed when using the live ebuilds) and
will of course be part of&lt;br&gt;
revision 12.&lt;/p&gt;
&lt;p&gt;A change in the userland utilities was also pushed out to allow
permissive domains (so run a single domain in permissive mode instead of
the entire system).&lt;/p&gt;
&lt;p&gt;Finally, the SELinux eclass has been updated to remove SELinux modules
from all defined SELinux module stores if the SELinux policy package is
removed from the system. Before that, the user had to remove the modules
from the store himself manually, but this is error-prone and easily
forgotten, especially for the non-default SELinux policy stores.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Profiles&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;All hardened subprofiles are marked as deprecated now (you've seen the
discussions on this on the mailinglist probably on this) so we now have
a sane set of hardened profiles to manage. The subprofiles were used for
things like&lt;br&gt;
"desktop" or "server", whereas users can easily stack their profiles as
they see fit anyhow - so there was little reason for the project to
continue managing those subprofiles.&lt;/p&gt;
&lt;p&gt;Also, now that Gentoo has released its 13.0 profile, we will need to
migrate our profiles to the 13.0 ones as well. So, the idea is to
temporarily support 13.0 in a subprofile, test it thoroughly, and then
remove the subprofile and switch the main one to 13.0.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;System Integrity&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The documentation for IMA and EVM is available on the Gentoo Hardened
project site. They currently still refer to the IMA and EVM subsystems
as development-only, but they are available in the stable kernels now.
Especially the default policy that is available in the kernel is pretty
useful. When you want to consider custom policies (for instance with
SELinux integration) you'll need a kernel patch that is already
upstreamed but not applied to the stable kernels yet.&lt;/p&gt;
&lt;p&gt;To support IMA/EVM, a package called ima-evm-utils is available in the
hardened-dev overlay, which will be moved to the main tree soon.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Documentation&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As mentioned before, the PaX documentation has seen quite a lot of
updates. Other documents that have seen updates are the Hardened FAQ,
Integrity subproject and SELinux documentation although most of them
were small changes.&lt;/p&gt;
&lt;p&gt;Another suggestion given is to clean up the Hardened project page;
however, there has been some talk within Gentoo to move project pages to
the Gentoo wiki. Such a move might make the suggestion easier to handle.
And while on the subject of the wiki, we might want to move user guides
to the wiki already.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bugs&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Bug &lt;a href="https://bugs.gentoo.org/443630"&gt;443630&lt;/a&gt; refers to segmentation
faults with libvirt when starting Qemu domains on a SELinux-enabled
host. Sadly, I'm not able to test libvirt myself so either someone with
SELinux and libvirt&lt;br&gt;
expertise can chime in, or we will need to troubleshoot it by bug
(using gdb, strace'ing more, ...) which might take quite some time and
is not user friendly...&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Media&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Various talks where held at FOSDEM regarding Gentoo Hardened, and a lot
of people attended those talks. Also the round table was quite
effective, with many users interacting with developers all around. For
next year, chances are very high that we'll give a "What has changed
since last year" session and a round table again.&lt;/p&gt;
&lt;p&gt;With many thanks to the usual suspects: Zorry, blueness, prometheanfire,
lejonet, klondike and the several dozen contributors that are going to
kill me for not mentioning their (nick)names.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="grsecurity"></category><category term="hardened"></category><category term="kernel"></category><category term="meeting"></category><category term="minutes"></category><category term="online"></category><category term="pax"></category><category term="profiles"></category><category term="selinux"></category></entry></feed>