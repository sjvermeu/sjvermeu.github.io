<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Simplicity is a form of art... - policy</title><link href="https://blog.siphos.be/" rel="alternate"></link><link href="https://blog.siphos.be/tag/policy/feed/atom.xml" rel="self"></link><id>https://blog.siphos.be/</id><updated>2015-08-11T19:18:00+02:00</updated><entry><title>Why we do confine Firefox</title><link href="https://blog.siphos.be/2015/08/why-we-do-confine-firefox/" rel="alternate"></link><published>2015-08-11T19:18:00+02:00</published><updated>2015-08-11T19:18:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-11:/2015/08/why-we-do-confine-firefox/</id><summary type="html">&lt;p&gt;If you're a bit following the SELinux development community you will know
&lt;a href="http://danwalsh.livejournal.com"&gt;Dan Walsh&lt;/a&gt;, a &lt;a href="http://people.redhat.com/dwalsh/"&gt;Red Hat&lt;/a&gt;
security engineer. Today he &lt;a href="http://danwalsh.livejournal.com/72697.html"&gt;blogged&lt;/a&gt; 
about &lt;em&gt;CVE-2015-4495 and SELinux, or why doesn't SELinux confine Firefox&lt;/em&gt;. He 
should've asked why the &lt;em&gt;reference policy&lt;/em&gt; or &lt;em&gt;Red Hat/Fedora policy&lt;/em&gt; does not
confine Firefox, because SELinux …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you're a bit following the SELinux development community you will know
&lt;a href="http://danwalsh.livejournal.com"&gt;Dan Walsh&lt;/a&gt;, a &lt;a href="http://people.redhat.com/dwalsh/"&gt;Red Hat&lt;/a&gt;
security engineer. Today he &lt;a href="http://danwalsh.livejournal.com/72697.html"&gt;blogged&lt;/a&gt; 
about &lt;em&gt;CVE-2015-4495 and SELinux, or why doesn't SELinux confine Firefox&lt;/em&gt;. He 
should've asked why the &lt;em&gt;reference policy&lt;/em&gt; or &lt;em&gt;Red Hat/Fedora policy&lt;/em&gt; does not
confine Firefox, because SELinux is, as I've
&lt;a href="http://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/"&gt;mentioned before&lt;/a&gt;,
not the same as its policy.&lt;/p&gt;
&lt;p&gt;In effect, Gentoo's SELinux policy &lt;em&gt;does&lt;/em&gt; confine Firefox by default. One of the
principles we focus on in Gentoo Hardened is to
&lt;a href="https://wiki.gentoo.org/wiki/Project:SELinux/Development_policy#Develop_desktop_policies"&gt;develop desktop policies&lt;/a&gt;
in order to reduce exposure and information leakage of user documents. We might
not have the manpower to confine all desktop applications, but I do think it is
worthwhile to at least attempt to do this, even though what Dan Walsh mentioned
is also correct: desktops are notoriously difficult to use a mandatory access
control system on.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;How Gentoo wants to support more confined desktop applications&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What Gentoo Hardened tries to do is to support the
&lt;a href="http://standards.freedesktop.org/basedir-spec/basedir-spec-0.8.html"&gt;XDG Base Directory Specification&lt;/a&gt;
for several documentation types. Downloads are marked as &lt;code&gt;xdg_downloads_home_t&lt;/code&gt;,
pictures are marked as &lt;code&gt;xdg_pictures_home_t&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;With those types defined, we grant the regular user domains full access to
those types, but start removing access to user content from applications. Rules
such as the following are commented out or removed from the policies:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# userdom_manage_user_home_content_dirs(mozilla_t)
# userdom_manage_user_home_content_files(mozilla_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Instead, we add in a call to a template we have defined ourselves:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userdom_user_content_access_template(mozilla, { mozilla_t mozilla_plugin_t })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This call makes access to user content optional through SELinux booleans. For
instance, for the &lt;code&gt;mozilla_t&lt;/code&gt; domain (which is used for Firefox), the following
booleans are created:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Read generic (user_home_t) user content
mozilla_read_generic_user_content       -&amp;gt;      true

# Read all user content
mozilla_read_all_user_content           -&amp;gt;      false

# Manage generic (user_home_t) user content
mozilla_manage_generic_user_content     -&amp;gt;      false

# Manage all user content
mozilla_manage_all_user_content         -&amp;gt;      false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, the default setting is that Firefox can read user content, but
only non-specific types. So &lt;code&gt;ssh_home_t&lt;/code&gt;, which is used for the SSH related
files, is not readable by Firefox with our policy &lt;em&gt;by default&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;By changing these booleans, the policy is fine-tuned to the requirements of
the administrator. On my systems, &lt;code&gt;mozilla_read_generic_user_content&lt;/code&gt; is switched
off.&lt;/p&gt;
&lt;p&gt;You might ask how we can then still support a browser if it cannot access user
content to upload or download. Well, as mentioned before, we support the XDG
types. The browser is allowed to manage &lt;code&gt;xdg_download_home_t&lt;/code&gt; files and
directories. For the majority of cases, this is sufficient. I also don't mind
copying over files to the &lt;code&gt;~/Downloads&lt;/code&gt; directory just for uploading files. But
I am well aware that this is not what the majority of users would want, which
is why the default is as it is.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;There is much more work to be done sadly&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As said earlier, the default policy will allow &lt;em&gt;reading&lt;/em&gt; of user files if those
files are not typed specifically. Types that are protected by our policy (but not
by the reference policy standard) includes SSH related files at &lt;code&gt;~/.ssh&lt;/code&gt; and
GnuPG files at &lt;code&gt;~/.gnupg&lt;/code&gt;. Even other configuration files, such as for my Mutt
configuration (&lt;code&gt;~/.muttrc&lt;/code&gt;) which contains a password for an IMAP server I connect
to, are not reachable.&lt;/p&gt;
&lt;p&gt;However, it is still far from perfect. One of the reasons is that many desktop
applications are not "converted" yet to our desktop policy approach. Yes, Chromium
is also already converted, and policies we've added such as for Skype also do not
allow direct access unless the user explicitly enabled it. But Evolution for instance
isn't yet.&lt;/p&gt;
&lt;p&gt;Converting desktop policies to a more strict setup requires lots of testing, which
translates to many human resources. Within Gentoo, only a few developers and 
contributors are working on policies, and considering that this is not a change
that is already part of the (upstream) reference policy, some contributors also
do not want to put lots of focus on it either. But without having done the works,
it will not be easy (nor probably acceptable) to upstream this (the XDG patch has
been submitted a few times already but wasn't deemed ready yet then).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Having a more restrictive policy isn't the end&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As the blog post of Dan rightly mentioned, there are still quite some other
ways of accessing information that we might want to protect. An application 
might not have access to user files, but can be able to communicate (for instance
through DBus) with an application that does, and through that instruct it to
pass on the data.&lt;/p&gt;
&lt;p&gt;Plugins might require permissions which do not match with the principles set up
earlier. When we tried out Google Talk (needed for proper Google Hangouts support)
we noticed that it requires many, many more privileges. Luckily, we were able to
write down and develop a policy for the Google Talk plugin (&lt;code&gt;googletalk_plugin_t&lt;/code&gt;)
so it is still properly confined. But this is just a single plugin, and I'm sure
that more plugins exist which will have similar requirements. Which leads to more
policy development.&lt;/p&gt;
&lt;p&gt;But having workarounds does not make the effort we do worthless. Being able to
work around a firewall through application data does not make the firewall
useless, it is just one of the many security layers. The same is true with SELinux
policies.&lt;/p&gt;
&lt;p&gt;I am glad that we at least try to confine desktop applications more, and
that Gentoo Hardened users who use SELinux are at least somewhat more protected
from the vulnerability (even with the default case) and that our investment for
this is sound.&lt;/p&gt;</content><category term="SELinux"></category><category term="gentoo"></category><category term="selinux"></category><category term="policy"></category><category term="firefox"></category><category term="cve"></category><category term="vulnerability"></category><category term="xdg"></category></entry><entry><title>Don't confuse SELinux with its policy</title><link href="https://blog.siphos.be/2015/08/dont-confuse-selinux-with-its-policy/" rel="alternate"></link><published>2015-08-03T01:49:00+02:00</published><updated>2015-08-03T01:49:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-08-03:/2015/08/dont-confuse-selinux-with-its-policy/</id><summary type="html">&lt;p&gt;With the increased attention that SELinux is getting thanks to its inclusion in
recent &lt;a href="https://source.android.com/devices/tech/security/selinux/"&gt;Android&lt;/a&gt;
releases, more and more people are understanding that SELinux is not a singular
security solution. Many administrators are still disabling SELinux on their 
servers because it does not play well with their day-to-day operations. But …&lt;/p&gt;</summary><content type="html">&lt;p&gt;With the increased attention that SELinux is getting thanks to its inclusion in
recent &lt;a href="https://source.android.com/devices/tech/security/selinux/"&gt;Android&lt;/a&gt;
releases, more and more people are understanding that SELinux is not a singular
security solution. Many administrators are still disabling SELinux on their 
servers because it does not play well with their day-to-day operations. But
the Android inclusion shows that SELinux itself is not the culprit for this:
it is the policy.&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Policy versus enforcement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELinux has conceptually segregated the enforcement from the rules/policy. 
There is an in-kernel enforcement (the SELinux subsystem) which is configured
through an administrator-provided policy (the SELinux rules). As long as 
SELinux was being used on servers, chances are very high that the policy that
is being used is based on the &lt;a href="https://github.com/TresysTechnology/refpolicy/wiki"&gt;SELinux Reference Policy&lt;/a&gt;
as this is, as far as I know, the only policy implementation for Linux systems
that is widely usable.&lt;/p&gt;
&lt;p&gt;The reference policy project aims to provide a well designed, broadly usable
yet still secure set of rules. And through this goal, it has to play ball with
all possible use cases that the various software titles require. Given the open
ecosystem of the free software world, and the Linux based ones in particular, 
managing such a policy is not for beginners. New policy development requires 
insight in the technology for which the policy is created, as well as knowledge
of how the reference policy works.&lt;/p&gt;
&lt;p&gt;Compare this to the Android environment. Applications have to follow more
rigid guidelines before they are accepted on Android systems. Communication
between applications and services is governed through Intents and Activities
which are managed by the &lt;a href="http://www.cubrid.org/blog/dev-platform/binder-communication-mechanism-of-android-processes/"&gt;Binder&lt;/a&gt;
application. Interactions with the user are based on well defined interfaces.
Heck, the Android OS even holds a number of permissions that applications
have to subscribe to before they can use it.&lt;/p&gt;
&lt;p&gt;Such an environment is much easier to create policies for, because it allows
policies to be created almost on-the-fly, with the application permissions
being mapped to predefined SELinux rules. Because the freedom of
implementations is limited (in order to create a manageable environment which
is used by millions of devices over the world) policies can be made more
strictly and yet enjoy the static nature of the environment: no continuous
updates on existing policies, something that Linux distributions have to do
on an almost daily basis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aiming for a policy development ecosystem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Having SELinux active on Android shows that one should not confuse SELinux
with its policies. SELinux is a nice security subsystem in the Linux kernel,
and can be used and tuned to cover whatever use case is given to it. The slow
adoption of SELinux by Linux distributions might be attributed to its lack
of policy diversification, which results in few ecosystems where additional
(and perhaps innovative) policies could be developed.&lt;/p&gt;
&lt;p&gt;It is however a huge advantage that a reference policy exists, so that
distributions can enjoy a working policy without having to put resources
into its own policy development and maintenance. Perhaps we should try to
further enhance the existing policies while support new policy ecosystems
and development initiatives.&lt;/p&gt;
&lt;p&gt;The maturation of the &lt;a href="https://github.com/SELinuxProject/cil/wiki"&gt;CIL&lt;/a&gt;
language by the &lt;a href="https://github.com/SELinuxProject/selinux"&gt;SELinux userland libraries and tools&lt;/a&gt;
might be a good catalyst for this. At one point, policies will need to be
migrated to CIL (although this can happen gradually as the userland utilities
can deal with CIL and other languages such as the legacy &lt;code&gt;.pp&lt;/code&gt; files 
simultaneously) and there are a few developers considering a renewal
of the reference policy. This would make use of the new benefits of the CIL
language and implementation: some restrictions that where applicable to the legacy
format no longer holds on CIL, such as rules which previously were only allowed
in the base policy which can now be made part of the modules as well.&lt;/p&gt;
&lt;p&gt;But next to renewing existing policies, there is plenty of room left for
innovative policy ideas and developments. The &lt;a href="http://selinuxproject.org/page/PolicyLanguage"&gt;SELinux language&lt;/a&gt;
is very versatile, and just like with programming languages we notice that only
a few set of constructs are used. Some applications might even benefit from
using SELinux as their decision and enforcement system (something that
&lt;a href="https://wiki.postgresql.org/wiki/SEPostgreSQL_Introduction"&gt;SEPostgreSQL&lt;/a&gt; has
tried).&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://freecomputerbooks.com/The-SELinux-Notebook-The-Foundations.html"&gt;SELinux Notebook&lt;/a&gt; by
Richard Haines is an excellent resource for developers that want to work more
closely with the SELinux language constructs. Just skimming through this resource
also shows how very open SELinux itself is, and that most of the users'
experience with SELinux is based on a singular policy implementation. This is
a prime reason why having a more open policy ecosystem makes perfect sense.&lt;/p&gt;
&lt;p&gt;If you don't like a particular car, do you ditch driving at all? No, you try out
another car. Let's create other cars in the SELinux world as well.&lt;/p&gt;</content><category term="SELinux"></category><category term="selinux"></category><category term="policy"></category><category term="cil"></category></entry><entry><title>Testing with permissive domains</title><link href="https://blog.siphos.be/2015/05/testing-with-permissive-domains/" rel="alternate"></link><published>2015-05-18T13:40:00+02:00</published><updated>2015-05-18T13:40:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-05-18:/2015/05/testing-with-permissive-domains/</id><summary type="html">&lt;p&gt;When testing out new technologies or new setups, not having (proper)
SELinux policies can be a nuisance. Not only are the number of SELinux
policies that are available through the standard repositories limited,
some of these policies are not even written with the same level of
confinement that an administrator …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When testing out new technologies or new setups, not having (proper)
SELinux policies can be a nuisance. Not only are the number of SELinux
policies that are available through the standard repositories limited,
some of these policies are not even written with the same level of
confinement that an administrator might expect. Or perhaps the
technology to be tested is used in a completely different manner.&lt;/p&gt;
&lt;p&gt;Without proper policies, any attempt to start such a daemon or
application might or will cause permission violations. In many cases,
developers or users tend to disable SELinux enforcing then so that they
can continue playing with the new technology. And why not? After all,
policy development is to be done &lt;em&gt;after&lt;/em&gt; the technology is understood.&lt;/p&gt;


&lt;p&gt;But completely putting the system in permissive mode is overshooting. It
is much easier to make a very simple policy to start with, and then mark
the domain as a permissive domain. What happens is that the software
then, after transitioning into the "simple" domain, is not part of the
SELinux enforcements anymore whereas the rest of the system remains in
SELinux enforcing mode.&lt;/p&gt;
&lt;p&gt;For instance, create a minuscule policy like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(testdom, 1.0)

type testdom_t;
type testdom_exec_t;
init_daemon_domain(testdom_t, testdom_exec_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Mark the executable for the daemon as &lt;code&gt;testdom_exec_t&lt;/code&gt; (after building
and loading the minuscule policy):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# chcon -t testdom_exec_t /opt/something/bin/daemond
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, tell SELinux that &lt;code&gt;testdom_t&lt;/code&gt; is to be seen as a permissive
domain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~# semanage permissive -a testdom_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When finished, don't forget to remove the permissive bit
(&lt;code&gt;semanage permissive -d testdom_t&lt;/code&gt;) and unload/remove the SELinux
policy module.&lt;/p&gt;
&lt;p&gt;And that's it. If the daemon is now started (through a standard init
script) it will run as &lt;code&gt;testdom_t&lt;/code&gt; and everything it does will be
logged, but not enforced by SELinux. That might even help in
understanding the application better.&lt;/p&gt;</content><category term="SELinux"></category><category term="permissive"></category><category term="policy"></category><category term="selinux"></category><category term="semanage"></category><category term="test"></category></entry><entry><title>Use change management when you are using SELinux to its fullest</title><link href="https://blog.siphos.be/2015/04/use-change-management-when-you-are-using-selinux-to-its-fullest/" rel="alternate"></link><published>2015-04-30T20:58:00+02:00</published><updated>2015-04-30T20:58:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2015-04-30:/2015/04/use-change-management-when-you-are-using-selinux-to-its-fullest/</id><summary type="html">&lt;p&gt;If you are using SELinux on production systems (with which I mean
systems that you offer services with towards customers or other parties
beyond you, yourself and your ego), please consider proper change
management if you don't do already. SELinux is a very sensitive security
subsystem - not in the sense …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you are using SELinux on production systems (with which I mean
systems that you offer services with towards customers or other parties
beyond you, yourself and your ego), please consider proper change
management if you don't do already. SELinux is a very sensitive security
subsystem - not in the sense that it easily fails, but because it is
very fine-grained and as such can easily stop applications from running
when their behavior changes just a tiny bit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sensitivity of SELinux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SELinux is a wonderful security measure for Linux systems that can
prevent successful exploitation of vulnerabilities or misconfigurations.
Of course, it is not the sole security measure that systems should take.
Proper secure configuration of services, least privilege accounts,
kernel-level mitigations such as grSecurity and more are other measures
that certainly need to be taken if you really find system security to be
a worthy goal to attain. But I'm not going to talk about those others
right now. What I am going to focus on is SELinux, and how sensitive it
is to changes.&lt;/p&gt;
&lt;p&gt;An important functionality of SELinux to understand is that it
segregates the security control system itself (the SELinux subsystem)
from its configuration (the policy). The security control system itself
is relatively small, and focuses on enforcement of the policy and
logging (either because the policy asks to log something, or because
something is prevented, or because an error occurred). The most
difficult part of handling SELinux on a system is not enabling or
interacting with it. No, it is its policy.&lt;/p&gt;
&lt;p&gt;The policy is also what makes SELinux so darn sensitive for small system
changes (or behavior that is not either normal, or at least not allowed
through the existing policy). Let me explain with a small situation that
I recently had.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case in point: Switching an IP address&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A case that beautifully shows how sensitive SELinux can be is an IP
address change. My systems all obtain their IP address (at least for
IPv4) from a DHCP system. This is of course acceptable behavior as
otherwise my systems would never be able to boot up successfully anyway.
The SELinux policy that I run also allows this without any hindrance. So
that was not a problem.&lt;/p&gt;
&lt;p&gt;Yet recently I had to switch an IP address for a system in production.
All the services I run are set up in a dual-active mode, so I started
with the change by draining the services to the second system, shutting
down the service and then (after reconfiguring the DHCP system to now
provide a different IP address) reload the network configuration. And
then it happened - the DHCP client just stalled.&lt;/p&gt;
&lt;p&gt;As the change failed, I updated the DHCP system again to deliver the old
IP address and then reloaded the network configuration on the client.
Again, it failed. Dumbstruck, I looked at the AVC denials and lo and
behold, I notice a &lt;code&gt;dig&lt;/code&gt; process running in a DHCP client related domain
that is trying to do UDP binds, which the policy (at that time) did not
allow. But why now suddenly, after all - this system was running happily
for more than a year already (and with occasional reboots for kernel
updates).&lt;/p&gt;
&lt;p&gt;I won't bore you with the investigation. It boils down to the fact that
the DHCP client detected a change compared to previous startups, and was
configured to run a few hooks as additional steps in the IP lease setup.
As these hooks were never ran previously, the policy was never
challenged to face this. And since the address change occurred a revert
to the previous situation didn't work either (as its previous state
information was already deleted).&lt;/p&gt;
&lt;p&gt;I was able to revert the client (which is a virtual guest in KVM) to the
situation right before the change (thank you &lt;code&gt;savevm&lt;/code&gt; and &lt;code&gt;loadvm&lt;/code&gt;
functionality) so that I could work on the policy first in a
non-production environment so that the next change attempt was
successful.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Change management&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The previous situation might be "solved" by temporarily putting the DHCP
client domain in permissive mode just for the change and then back. But
that is ignoring the issue, and unless you have perfect operational
documentation that you always read before making system or configuration
changes, I doubt that you'll remember this for the next time.&lt;/p&gt;
&lt;p&gt;The case is also a good example on the sensitivity of SELinux. It is not
just when software is being upgraded. Every change (be it in
configuration, behavior or operational activity) might result in a
situation that is new for the loaded SELinux policy. As the default
action in SELinux is to deny everything, this will result in unexpected
results on the system. Sometimes very visible (no IP address obtained),
sometimes hidden behind some weird behavior (hostname correctly set but
not the domainname) or perhaps not even noticed until far later. Compare
it to the firewall rule configurations: you might be able to easily
confirm that standard flows are still passed through, but how are you
certain that fallback flows or one-in-a-month connection setups are not
suddenly prevented from happening.&lt;/p&gt;
&lt;p&gt;A somewhat better solution than just temporarily disabling SELinux
access controls for a domain is to look into proper change management.
Whenever a change has to be done, make sure that you&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can easily revert the change back to the previous
    situation (backups!)&lt;/li&gt;
&lt;li&gt;have tested the change on a non-vital (preproduction) system first&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These two principles are pretty vital when you are serious about using
SELinux in production. I'm not talking about a system that hardly has
any fine-grained policies, like where most of the system's services are
running in "unconfined" domains (although that's still better than not
running with SELinux at all), but where you are truly trying to put a
least privilege policy in place for all processes and services.&lt;/p&gt;
&lt;p&gt;Being able to revert a change allows you to quickly get a service up and
running again so that customers are not affected by the change (and
potential issues) for long time. First fix the service, then fix the
problem. If you are an engineer like me, you might rather focus on the
problem (and a permanent, correct solution) first. But that's wrong -
always first make sure that the customers are not affected by it. Revert
and put the service back up, and then investigate so that the next
change attempt will not go wrong anymore.&lt;/p&gt;
&lt;p&gt;Having a multi-master setup might give some more leeway into
investigating issues (as the service itself is not disrupted) so in the
case mentioned above I would probably have tried fixing the issue
immediately anyway if it wasn't policy-based. But most users do not have
truly multi-master service setups.&lt;/p&gt;
&lt;p&gt;Being able to test (and retest) changes in non-production also allows
you to focus on automation (so that changes can be done faster and in a
repeated, predictable and qualitative manner), regression testing as
well as change accumulation testing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;You don't have time for that?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Be honest with yourself. If you support services for others (be it in a
paid-for manner or because you support an organization in your free
time) you'll quickly learn that service availability is one of the most
qualitative aspects of what you do. No matter what mess is behind it,
most users don't see all that. All they see is the service itself (and
its performance / features). If a change you wanted to make made a
service unavailable for hours, users will notice. And if the change
wasn't communicated up front or it is the n-th time that this downtime
occurs, they will start asking questions you rather not hear.&lt;/p&gt;
&lt;p&gt;Using a non-production environment is not that much of an issue if the
infrastructure you work with supports bare metal restores, or
snapshot/cloning (in case of VMs). After doing those a couple of times,
you'll easily find that you can create a non-production environment from
the production one. Or, you can go for a permanent non-production
environment (although you'll need to take care that this environment is
at all times representative for the production systems).&lt;/p&gt;
&lt;p&gt;And regarding qualitative changes, I really recommend to use a
configuration management system. I recently switched from Puppet to
Saltstack and have yet to use the latter to its fullest set (most of
what I do is still scripted), but it is growing on me and I'm pretty
convinced that I'll have the majority of my change management scripts
removed by the end of this year towards Saltstack-based configurations.
And that'll allow me to automate changes and thus provide a more
qualitative service offering.&lt;/p&gt;
&lt;p&gt;With SELinux, of course.&lt;/p&gt;</content><category term="SELinux"></category><category term="change management"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>D-Bus and SELinux</title><link href="https://blog.siphos.be/2014/06/d-bus-and-selinux/" rel="alternate"></link><published>2014-06-30T20:07:00+02:00</published><updated>2014-06-30T20:07:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-06-30:/2014/06/d-bus-and-selinux/</id><summary type="html">&lt;p&gt;After a &lt;a href="http://blog.siphos.be/2014/06/d-bus-quick-recap/"&gt;post about
D-Bus&lt;/a&gt; comes the
inevitable related post about SELinux with D-Bus.&lt;/p&gt;
&lt;p&gt;Some users might not know that D-Bus is an SELinux-aware application.
That means it has SELinux-specific code in it, which has the D-Bus
behavior based on the SELinux policy (and might not necessarily honor
the "permissive …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After a &lt;a href="http://blog.siphos.be/2014/06/d-bus-quick-recap/"&gt;post about
D-Bus&lt;/a&gt; comes the
inevitable related post about SELinux with D-Bus.&lt;/p&gt;
&lt;p&gt;Some users might not know that D-Bus is an SELinux-aware application.
That means it has SELinux-specific code in it, which has the D-Bus
behavior based on the SELinux policy (and might not necessarily honor
the "permissive" flag). This code is used as an additional
authentication control within D-Bus.&lt;/p&gt;
&lt;p&gt;Inside the SELinux policy, a &lt;em&gt;dbus&lt;/em&gt; permission class is supported, even
though the Linux kernel doesn't do anything with this class. The class
is purely for D-Bus, and it is D-Bus that checks the permission
(although work is being made to &lt;a href="https://lwn.net/Articles/580194/"&gt;implement D-Bus in kernel
(kdbus)&lt;/a&gt;). The class supports two
permission checks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;acquire_svc&lt;/em&gt; which tells the domain(s) allowed to "own" a service
    (which might, thanks to the SELinux support, be different from the
    domain itself)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;send_msg&lt;/em&gt; which tells which domain(s) can send messages to a
    service domain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inside the D-Bus security configuration (the &lt;code&gt;busconfig&lt;/code&gt; XML file,
remember) a service configuration might tell D-Bus that the service
itself is labeled differently from the process that owned the service.
The default is that the service inherits the label from the domain, so
when &lt;code&gt;dnsmasq_t&lt;/code&gt; registers a service on the system bus, then this
service also inherits the &lt;code&gt;dnsmasq_t&lt;/code&gt; label.&lt;/p&gt;
&lt;p&gt;The necessary permission checks for the &lt;code&gt;sysadm_t&lt;/code&gt; user domain to send
messages to the dnsmasq service, and the dnsmasq service itself to
register it as a service:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow dnsmasq_t self:dbus { acquire_svc send_msg };
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For the &lt;code&gt;sysadm_t&lt;/code&gt; domain, the two rules are needed as we usually not
only want to send a message to a D-Bus service, but also receive a reply
(which is also handled through a &lt;em&gt;send_msg&lt;/em&gt; permission but in the
inverse direction).&lt;/p&gt;
&lt;p&gt;However, with the following XML snippet inside its service configuration
file, owning a certain resource is checked against a different label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;busconfig&amp;gt;
  &amp;lt;selinux&amp;gt;
    &amp;lt;associate
      own=&amp;quot;uk.org.thekelleys.dnsmasq&amp;quot;
      context=&amp;quot;system_u:object_r:dnsmasq_dbus_t:s0&amp;quot; /&amp;gt;
  &amp;lt;/selinux&amp;gt;
&amp;lt;/busconfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this, the rules would become as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow dnsmasq_t dnsmasq_dbus_t:dbus acquire_svc;
allow dnsmasq_t self:dbus send_msg;
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that &lt;em&gt;only&lt;/em&gt; the access for acquiring a service based on a name
(i.e. owning a service) is checked based on the different label. Sending
and receiving messages is still handled by the domains of the processes
(actually the labels of the connections, but these are always the
process domains).&lt;/p&gt;
&lt;p&gt;I am not aware of any policy implementation that uses a different label
for owning services, and the implementation is more suited to "force"
D-Bus to only allow services with a correct label. This ensures that
other domains that might have enough privileges to interact with D-Bus
and own a service cannot own these particular services. After all, other
services don't usually have the privileges (policy-wise) to
&lt;em&gt;acquire_svc&lt;/em&gt; a service with a different label than their own label.&lt;/p&gt;</content><category term="SELinux"></category><category term="busconfig"></category><category term="d-bus"></category><category term="dbus"></category><category term="linux"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>If things are weird, check for policy.29</title><link href="https://blog.siphos.be/2014/04/if-things-are-weird-check-for-policy-29/" rel="alternate"></link><published>2014-04-17T21:01:00+02:00</published><updated>2014-04-17T21:01:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-04-17:/2014/04/if-things-are-weird-check-for-policy-29/</id><summary type="html">&lt;p&gt;Today we analyzed a weird issue one of our SELinux users had with their
system. He had a denial when calling &lt;strong&gt;audit2allow&lt;/strong&gt;, informing us that
&lt;code&gt;sysadm_t&lt;/code&gt; had no rights to read the SELinux policy. This is a known
issue that has been resolved in our current SELinux policy repository
but …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today we analyzed a weird issue one of our SELinux users had with their
system. He had a denial when calling &lt;strong&gt;audit2allow&lt;/strong&gt;, informing us that
&lt;code&gt;sysadm_t&lt;/code&gt; had no rights to read the SELinux policy. This is a known
issue that has been resolved in our current SELinux policy repository
but which needs to be pushed to the tree (which is my job, sorry about
that). The problem however is when he added the policy - it didn't work.&lt;/p&gt;
&lt;p&gt;Even worse, &lt;strong&gt;sesearch&lt;/strong&gt; told us that the policy has been modified
correctly - but it still doesn't work. Check your policy with
&lt;strong&gt;sestatus&lt;/strong&gt; and &lt;strong&gt;seinfo&lt;/strong&gt; and they're all saying things are working
well. And yet ... things don't. Apparently, all policy changes are
ignored.&lt;/p&gt;
&lt;p&gt;The reason? There was a &lt;code&gt;policy.29&lt;/code&gt; file in &lt;code&gt;/etc/selinux/mcs/policy&lt;/code&gt;
which was always loaded, even though the user already edited
&lt;code&gt;/etc/selinux/semanage.conf&lt;/code&gt; to have &lt;code&gt;policy-version&lt;/code&gt; set to 28.&lt;/p&gt;
&lt;p&gt;It is already a problem that we need to tell users to edit
&lt;code&gt;semanage.conf&lt;/code&gt; to a fixed version (because binary version 29 is not
supported by most Linux kernels as it has been very recently introduced)
but having &lt;strong&gt;load_policy&lt;/strong&gt; (which is called by &lt;strong&gt;semodule&lt;/strong&gt; when a
policy needs to be loaded) loading a stale &lt;code&gt;policy.29&lt;/code&gt; file is just...
disappointing.&lt;/p&gt;
&lt;p&gt;Anyway - if you see weird behavior, check both the &lt;code&gt;semanage.conf&lt;/code&gt; file
(and set &lt;code&gt;policy-version = 28&lt;/code&gt;) as well as the contents of your
&lt;code&gt;/etc/selinux/*/policy&lt;/code&gt; directory. If you see any &lt;code&gt;policy.*&lt;/code&gt; that isn't
version 28, delete them.&lt;/p&gt;</content><category term="SELinux"></category><category term="load_policy"></category><category term="policy"></category><category term="selinux"></category><category term="semanage"></category></entry><entry><title>Proof of concept for USE enabled policies</title><link href="https://blog.siphos.be/2014/03/proof-of-concept-for-use-enabled-policies/" rel="alternate"></link><published>2014-03-31T18:33:00+02:00</published><updated>2014-03-31T18:33:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-03-31:/2014/03/proof-of-concept-for-use-enabled-policies/</id><summary type="html">&lt;p&gt;&lt;em&gt;tl;dr:&lt;/em&gt; Some (&lt;code&gt;-9999&lt;/code&gt;) policy ebuilds now have &lt;code&gt;USE&lt;/code&gt; support for
building in (or leaving out) SELinux policy statements.&lt;/p&gt;
&lt;p&gt;One of the "problems" I have been facing since I took on the maintenance
of SELinux policies within Gentoo Hardened is the (seeming) inability to
make a "least privilege" policy that …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;tl;dr:&lt;/em&gt; Some (&lt;code&gt;-9999&lt;/code&gt;) policy ebuilds now have &lt;code&gt;USE&lt;/code&gt; support for
building in (or leaving out) SELinux policy statements.&lt;/p&gt;
&lt;p&gt;One of the "problems" I have been facing since I took on the maintenance
of SELinux policies within Gentoo Hardened is the (seeming) inability to
make a "least privilege" policy that suits the flexibility that Gentoo
offers. As a quick recap: SELinux policies describe the "acceptable
behavior" of an application (well, domain to be exact), often known as
the "normalized behavior" in the security world. When an application
(which runs within a SELinux domain) wants to perform some action which
is not part of the policy, then this action is denied.&lt;/p&gt;
&lt;p&gt;Some applications can have very broad acceptable behavior. A web server
for instance might need to connect to a database, but that is not the
case if the web server only serves static information, or dynamic
information that doesn't need a database. To support this, SELinux has
&lt;em&gt;booleans&lt;/em&gt; through which optional policy statements can be enabled or
disabled. So far so good.&lt;/p&gt;
&lt;p&gt;Let's look at a second example: ALSA. When ALSA enabled applications
want to access the sound devices, they use IPC resources to
"collaborate" around the sound subsystem (semaphores and shared memory
to be exact). Semaphores inherit the type of the domain that first
created the semaphore (so if &lt;strong&gt;mplayer&lt;/strong&gt; creates it, then the semaphore
has the &lt;code&gt;mplayer_t&lt;/code&gt; context) whereas shared memory usually gets the
tmpfs-related type (&lt;code&gt;mplayer_tmpfs_t&lt;/code&gt;). When a second application wants
to access the sound device as well, it needs access to the semaphore and
shared memory. Assuming this second application is the browser, then
&lt;code&gt;mozilla_t&lt;/code&gt; needs access to semaphores by &lt;code&gt;mplayer_t&lt;/code&gt;. And the same for
&lt;code&gt;chromium_t&lt;/code&gt;. Or &lt;code&gt;java_t&lt;/code&gt; applications that are ALSA-enabled. And
&lt;code&gt;alsa_t&lt;/code&gt;. And all other applications that are ALSA enabled.&lt;/p&gt;
&lt;p&gt;In Gentoo, ALSA support can be made optional through &lt;code&gt;USE="alsa"&lt;/code&gt;. If a
user decides not to use ALSA, then it doesn't make sense to allow all
those domains access to each others' semaphores and shared memory. And
although SELinux booleans can help, this would mean that for each
application domain, something like the following policy would need to
be, optionally, allowed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# For the mplayer_t domain:
optional_policy(`
  tunable_policy(`use_alsa&amp;#39;,`
    mozilla_rw_semaphores(mplayer_t)
    mozilla_rw_shm(mplayer_t)
    mozilla_tmpfs_rw_files(mplayer_t)
  &amp;#39;)
&amp;#39;)

optional_policy(`
  tunable_policy(`use_alsa&amp;#39;,`
    chromium_rw_semaphores(mplayer_t)
    chromium_rw_shm(mplayer_t)
    chromium_tmpfs_rw_files(mplayer_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And this for all domains that are ALSA-enabled. Every time a new
application is added that knows ALSA, the same code needs to be added to
all policies. And this only uses a single SELinux boolean (whereas
Gentoo supports &lt;code&gt;USE="alsa"&lt;/code&gt; on per-package level), although we can
create separate booleans for each domain if we want to. Not that that
will make it more manageable.&lt;/p&gt;
&lt;p&gt;One way of dealing with this would be to use attributes. Say we have a
policy like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;attribute alsadomain;
attribute alsatmpfsfile;

allow alsadomain alsadomain:sem rw_sem_perms;
allow alsadomain alsadomain:shm rw_shm_perms;
allow alsadomain alsatmpfsfile:file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By assigning the attribute to the proper domains whenever ALSA support
is needed, we can toggle this more easily:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# In alsa.if
interface(`alsa_domain&amp;#39;,`
  gen_require(`
    attribute alsadomain;
    attribute alsatmpfsfile;
  &amp;#39;)
  typeattribute $1 alsadomain;
  typeattribute $2 alsatmpfsfile;
&amp;#39;)


# In mplayer.te
optional_policy(`
  tunable_policy(`use_alsa&amp;#39;,`
    alsa_domain(mplayer_t, mplayer_tmpfs_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That would solve the problem of needlessly adding more calls in a policy
for every ALSA application. And hey, we can probably live with either a
global boolean (&lt;code&gt;use_alsa&lt;/code&gt;) or per-domain one (&lt;code&gt;mplayer_use_alsa&lt;/code&gt;) and
toggle this according to our needs.&lt;/p&gt;
&lt;p&gt;Sadly, the above is not possible: one cannot define &lt;code&gt;typeattribute&lt;/code&gt;
assignments inside a &lt;code&gt;tunable_policy&lt;/code&gt; code: attributes are part of the
non-conditional part of a SELinux policy. The solution would be to
create build-time conditionals (rather than run-time):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ifdef(`use_alsa&amp;#39;,`
  optional_policy(`
    alsa_domain(mplayer_t, mplayer_tmpfs_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This does mean that &lt;code&gt;use_alsa&lt;/code&gt; has to be known when the policy is built.
For Gentoo, that's not that bad, as policies are part of separate
packages, like &lt;code&gt;sec-policy/selinux-mplayer&lt;/code&gt;. So what I now added was
USE-enabled build-time decisions that trigger this code. The
&lt;code&gt;selinux-mplayer&lt;/code&gt; package has &lt;code&gt;IUSE="alsa"&lt;/code&gt; which will enable, if set,
the &lt;code&gt;use_alsa&lt;/code&gt; build-time conditional.&lt;/p&gt;
&lt;p&gt;As a result, we now support a better, fine-grained privilege setting
inside the SELinux policy which is triggered through the proper USE
flags.&lt;/p&gt;
&lt;p&gt;Is this a perfect solution? No, but it is manageable and known to Gentoo
users. It isn't perfect, because it listens to the USE flag setting for
the &lt;code&gt;selinux-mplayer&lt;/code&gt; package (and of course globally set USE flags) but
doesn't "detect" that the firefox application (for which the policy is
meant) is or isn't built with &lt;code&gt;USE="alsa"&lt;/code&gt;. So users/administrators will
need to keep this in mind when using package-local USE flag definitions.&lt;/p&gt;
&lt;p&gt;Also, this will make it a bit more troublesome for myself to manage the
SELinux policy for Gentoo (as upstream will not use this setup, and as
such patches from upstream might need a few manual corrections before
they apply to our tree). However, I gladly take that up if it means my
system will have somewhat better confinement.&lt;/p&gt;</content><category term="Gentoo"></category><category term="alsa"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>How does foo_t get this privilege?</title><link href="https://blog.siphos.be/2014/01/how-does-foo_t-get-this-privilege/" rel="alternate"></link><published>2014-01-05T04:14:00+01:00</published><updated>2014-01-05T04:14:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-05:/2014/01/how-does-foo_t-get-this-privilege/</id><summary type="html">&lt;p&gt;Today a question was raised how the unprivileged user domain &lt;code&gt;user_t&lt;/code&gt;
was allowed to write to &lt;code&gt;cgroup_t&lt;/code&gt; files. There is nothing obvious about
that in the &lt;code&gt;roles/unprivuser.te&lt;/code&gt; file, so what gives?&lt;/p&gt;
&lt;p&gt;I used a simple script (which I've been using for a while already)
called &lt;strong&gt;seshowtree&lt;/strong&gt; which presents …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Today a question was raised how the unprivileged user domain &lt;code&gt;user_t&lt;/code&gt;
was allowed to write to &lt;code&gt;cgroup_t&lt;/code&gt; files. There is nothing obvious about
that in the &lt;code&gt;roles/unprivuser.te&lt;/code&gt; file, so what gives?&lt;/p&gt;
&lt;p&gt;I used a simple script (which I've been using for a while already)
called &lt;strong&gt;seshowtree&lt;/strong&gt; which presents the SELinux rules for a particular
domain in a tree-like structure, expanding the interfaces as it finds
them. The script is far from perfect, but does enough to help me answer
such questions. If you're interested, the script is also available on my
&lt;a href="https://github.com/sjvermeu/small.coding/blob/master/se_scripts/seshowtree"&gt;github
small.coding&lt;/a&gt;
project.&lt;/p&gt;
&lt;p&gt;``` {lang="bash"}
~# seshowtree user roles/unprivuser.te &amp;gt; output.txt&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;In the resulting output, I search for the `cgroup_t` and work my way up,
which gives:

``` {lang=&amp;quot;bash&amp;quot;}
userdom_unpriv_user_template(user)
. userdom_common_user_template($1)
. . fs_rw_cgroup_files($1_t)
. . . rw_files_pattern($1, cgroup_t, cgroup_t)
. . . . allow $1 $3:file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So in this case, the user forgot to look into
&lt;code&gt;userdom_common_user_template&lt;/code&gt;, which is called by
&lt;code&gt;userdom_unpriv_user_template&lt;/code&gt; to find the path to this privilege. Of
course, that still doesn't explain why the privileges are assigned in
the first place. As the policy file itself does not contain the
necessary comments to deduce this, I had to ask the git repository for
more information:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{lang="bash"}
~$ git annotate userdomain.if&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In the end, it was a commit from 2010, informing me that "Common users
can read and write cgroup files (access governed by dac)". So the
privilege is by design, referring to the regular DAC permissions to
properly govern access to the files.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="selinux"></category><category term="seshowtree"></category></entry><entry><title>Private key handling and SELinux protection</title><link href="https://blog.siphos.be/2014/01/private-key-handling-and-selinux-protection/" rel="alternate"></link><published>2014-01-02T04:00:00+01:00</published><updated>2014-01-02T04:00:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2014-01-02:/2014/01/private-key-handling-and-selinux-protection/</id><summary type="html">&lt;p&gt;In this post I'll give some insight in a &lt;em&gt;possible&lt;/em&gt; SELinux policy for a
script I wrote.&lt;/p&gt;
&lt;p&gt;The script is a certificate authority handling script, in which I can
generate a private key (and certificate assigned to it), sign the
certificate either by itself (for the root CA key) or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I'll give some insight in a &lt;em&gt;possible&lt;/em&gt; SELinux policy for a
script I wrote.&lt;/p&gt;
&lt;p&gt;The script is a certificate authority handling script, in which I can
generate a private key (and certificate assigned to it), sign the
certificate either by itself (for the root CA key) or by another
previously created key (for subkeys), create certificates (such as user
certificates or device certificates) and sign them, sign certificate
requests, and revoke certificates.&lt;/p&gt;
&lt;p&gt;``` {lang="bash"}
export KEYLOC="/var/db/ca"&lt;/p&gt;
&lt;h1&gt;Create a root CA key for "genfic"&lt;/h1&gt;
&lt;h1&gt;(openssl questions and other output not shown)&lt;/h1&gt;
&lt;p&gt;certcli.sh -r genfic&lt;/p&gt;
&lt;h1&gt;Create a subkey, signed by the "genfic" key, for users&lt;/h1&gt;
&lt;p&gt;certcli.sh -p genfic -c genfic-user&lt;/p&gt;
&lt;h1&gt;Create a user certificate&lt;/h1&gt;
&lt;p&gt;certcli.sh -p genfic-user -R /var/db/ca/myUserId&lt;/p&gt;
&lt;h1&gt;Sign a certificate&lt;/h1&gt;
&lt;p&gt;certcli.sh -p genfic-user -s /var/db/ca/requests/someUser.csr&lt;/p&gt;
&lt;h1&gt;Revoke a certificate&lt;/h1&gt;
&lt;p&gt;certcli.sh -p genfic-user -x myuser@genfic.com&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;From a security point of view, I currently focus on two types:

-   `ca_private_key_t` is for the private key and should not be
    accessible by anyone, anywhere, anytime, except through the
    management script itself (which will run as `ca_cli_t`).
-   `ca_misc_t` is for the other related files, such as certificates,
    revocation lists, serial information, etc. If this would be &amp;quot;for
    real&amp;quot; I&amp;#39;d probably make a bit more types for this depending on the
    accesses, but for this post this suffices.

In order to provide the necessary support policy-wise, the following
types also are declared:

-   `ca_cli_exec_t` as the entrypoint for the script
-   `ca_misc_tmp_t` as the temporary file type used by OpenSSL when
    handling certificates (it is not used for the private key afaics,
    but it should still be sufficiently - and perhaps even equally
    well - protected like the private key

So let&amp;#39;s start with this.

``` {lang=&amp;quot;perl&amp;quot;}
policy_module(ca, 1.0.0)

# CA management script and domain
type ca_cli_t;
type ca_cli_exec_t;
domain_base_type(ca_cli_t)
fs_associate(ca_cli_exec_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Above, I declared the two types &lt;code&gt;ca_cli_t&lt;/code&gt; and &lt;code&gt;ca_cli_exec_t&lt;/code&gt;. Then,
two non-standard approaches were followed.&lt;/p&gt;
&lt;p&gt;Normally, application domains are granted through &lt;code&gt;application_type()&lt;/code&gt;,
&lt;code&gt;application_domain()&lt;/code&gt; or even &lt;code&gt;userdom_user_application_domain()&lt;/code&gt;.
Which interface you use depends on the privileges you want to grant on
the domain, but also which existing privileges should also be applicable
to the domain. Make sure you review the interfaces. For instance:&lt;/p&gt;
&lt;p&gt;``` {lang="bash"}&lt;/p&gt;
&lt;h1&gt;seshowif application_domain&lt;/h1&gt;
&lt;p&gt;interface(&lt;code&gt;application_type',&lt;/code&gt;
        gen_require(`
                attribute application_domain_type;
        ')&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    typeattribute $1 application_domain_type;

    # start with basic domain
    domain_type($1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;')&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;This means that the assigned domain (`ca_cli_t` in our example) would be
assigned the `application_domain_type` attribute, as well as the
`domain` attribute and other privileges. If we really want to prevent
any access to the `ca_cli_t` domain for handling the certificates, we
need to make sure that the lowest possible privileges are assigned.

The same is true for the file type `ca_cli_exec_t`. Making it through
`files_type()` interface would assign the `file_type` attribute to it,
and other domains might have access to `file_type`. So all I do here is
to allow the type `ca_cli_exec_t` to be associated on a file system.

Similarly, I define the remainder of file types:

``` {lang=&amp;quot;perl&amp;quot;}
type ca_private_key_t;
fs_associate(ca_private_key_t)

type ca_misc_tmp_t;
fs_associate(ca_misc_tmp_t)
fs_associate_tmpfs(ca_misc_tmp_t)

type ca_misc_t;
fs_associate(ca_misc_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, grant the CA handling script (which will run as &lt;code&gt;ca_cli_t&lt;/code&gt;) the
proper access to these types.&lt;/p&gt;
&lt;p&gt;``` {lang="perl"}
allow ca_cli_t ca_misc_t:dir create_dir_perms;
manage_files_pattern(ca_cli_t, ca_misc_t, ca_misc_t)&lt;/p&gt;
&lt;p&gt;allow ca_cli_t ca_private_key_t:dir create_dir_perms;
manage_files_pattern(ca_cli_t, ca_private_key_t, ca_private_key_t)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;This of course heavily depends on the script itself. Mine creates a
directory &amp;quot;private&amp;quot;, so needs the proper rights on the
`ca_private_key_t` type for directories as well. The &amp;quot;private&amp;quot; directory
is created in a generic directory (which is labeled as `ca_misc_t`) so I
can also create a file transition. This means that the SELinux policy
will automatically assign the `ca_private_key_t` type to a directory,
created in a directory with label `ca_misc_t`, if created by the
`ca_cli_t` domain:

``` {lang=&amp;quot;perl&amp;quot;}
filetrans_pattern(ca_cli_t, ca_misc_t, ca_private_key_t, dir, &amp;quot;private&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, &lt;code&gt;ca_cli_t&lt;/code&gt; is a domain used for a shell script, which in my case
also requires the following permissions:&lt;/p&gt;
&lt;p&gt;``` {lang="perl"}&lt;/p&gt;
&lt;h1&gt;Handling pipes between commands&lt;/h1&gt;
&lt;p&gt;allow ca_cli_t self:fifo_file rw_fifo_file_perms;&lt;/p&gt;
&lt;h1&gt;Shell script...&lt;/h1&gt;
&lt;p&gt;corecmd_exec_shell(ca_cli_t)&lt;/p&gt;
&lt;h1&gt;...which invokes regular binaries&lt;/h1&gt;
&lt;p&gt;corecmd_exec_bin(ca_cli_t)&lt;/p&gt;
&lt;h1&gt;Allow output on the screen&lt;/h1&gt;
&lt;p&gt;getty_use_fds(ca_cli_t)
userdom_use_user_terminals(ca_cli_t)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Now I still need to mark `ca_cli_exec_t` as an entrypoint for
`ca_cli_t`, meaning that the `ca_cli_t` domain can only be accessed
(transitioned to) through the execution of a file with label
`ca_cli_exec_t`:

``` {lang=&amp;quot;perl&amp;quot;}
allow ca_cli_t ca_cli_exec_t:file entrypoint;
allow ca_cli_t ca_cli_exec_t:file { mmap_file_perms ioctl lock };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Normally, the above is granted through the invocation of the
&lt;code&gt;application_domain(ca_cli_t, ca_cli_exec_t)&lt;/code&gt; but as mentioned before,
this would also assign attributes that I explicitly want to prevent in
this example.&lt;/p&gt;
&lt;p&gt;Next, the &lt;code&gt;openssl&lt;/code&gt; application, which the script uses extensively, also
requires additional permissions. As the &lt;code&gt;openssl&lt;/code&gt; command just runs in
the &lt;code&gt;ca_cli_t&lt;/code&gt; domain, I extend the privileges for this domain more:&lt;/p&gt;
&lt;p&gt;``` {lang="perl"}&lt;/p&gt;
&lt;h1&gt;Read access on /proc files&lt;/h1&gt;
&lt;p&gt;kernel_read_system_state(ca_cli_t)&lt;/p&gt;
&lt;h1&gt;Access to random devices&lt;/h1&gt;
&lt;p&gt;dev_read_rand(ca_cli_t)
dev_read_urand(ca_cli_t)&lt;/p&gt;
&lt;h1&gt;Regular files&lt;/h1&gt;
&lt;p&gt;files_read_etc_files(ca_cli_t)
miscfiles_read_localization(ca_cli_t)&lt;/p&gt;
&lt;h1&gt;/tmp access&lt;/h1&gt;
&lt;p&gt;fs_getattr_tmpfs(ca_cli_t)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Also, the following file transition is created: when OpenSSL creates a
temporary file in `/tmp`, this file should immediately be assigned the
`ca_misc_tmp_t` type:

``` {lang=&amp;quot;perl&amp;quot;}
# File transition in /tmp to ca_misc_tmp_t
files_tmp_filetrans(ca_cli_t, ca_misc_tmp_t, file)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this in place, the application works just fine - all I need to do
is have an initial location marked as &lt;code&gt;ca_misc_t&lt;/code&gt;. For now, none of the
users have the rights to do so, so I create three additional interfaces
to be used against other user domains.&lt;/p&gt;
&lt;p&gt;The first one is to allow user domains to use the CA script. This is
handled by the &lt;code&gt;ca_role()&lt;/code&gt; interface. In order to support such an
interface, let's first create the &lt;code&gt;ca_roles&lt;/code&gt; role attribute in the &lt;code&gt;.te&lt;/code&gt;
file:&lt;/p&gt;
&lt;p&gt;``` {lang="perl"}
attribute_role ca_roles;
role ca_roles types ca_cli_t;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Now I can define the `ca_role()` interface:

``` {lang=&amp;quot;bash&amp;quot;}
interface(`ca_role&amp;#39;,`
  gen_require(`
    attribute_role ca_roles;
    type ca_cli_t, ca_cli_exec_t;
    type ca_misc_t;
  &amp;#39;)

  # Allow the user role (like sysadm_r) the types granted to ca_roles
  roleattribute $1 ca_roles;

  # Read the non-private key files and directories
  allow $2 ca_misc_t:dir list_dir_perms;
  allow $2 ca_misc_t:file read_file_perms;

  # Allow to transition to ca_cli_t by executing a ca_cli_exec_t file
  domtrans_pattern($2, ca_cli_exec_t, ca_cli_t)

  # Look at the process info
  ps_process_pattern($2, ca_cli_t)

  # Output (and redirect) handling
  allow ca_cli_t $2:fd use;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This role allows to run the command, but we still don't have the rights
to create a &lt;code&gt;ca_misc_t&lt;/code&gt; directory. So another interface is created,
which is granted to &lt;em&gt;regular&lt;/em&gt; system administrators (as the &lt;code&gt;ca_role()&lt;/code&gt;
might be granted to non-admins as well, who can invoke the script
through &lt;code&gt;sudo&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;`` {lang="bash"}
interface(&lt;/code&gt;ca_sysadmin',&lt;code&gt;gen_require(&lt;/code&gt;
    type ca_misc_t;
    type ca_private_key_t;
  ')&lt;/p&gt;
&lt;p&gt;# Allow the user relabel rights on ca_misc_t
  allow $1 ca_misc_t:dir relabel_dir_perms;
  allow $1 ca_misc_t:file relabel_file_perms;&lt;/p&gt;
&lt;p&gt;# Allow the user to label /to/ ca_private_key_t (but not vice versa)
  allow $1 ca_private_key_t:dir relabelto_dir_perms;
  allow $1 ca_private_key_t:file relabelto_file_perms;&lt;/p&gt;
&lt;p&gt;# Look at regular file/dir info
  allow $1 ca_misc_t:dir list_dir_perms;
  allow $1 ca_misc_t:file read_file_perms;
')&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;The `ca_sysadmin()` interface can also be assigned to the `setfiles_t`
command so that relabel operations (and file system relabeling) works
correctly.

Finally, a real administrative interface is created that also has
relabel *from* rights (so any domain granted this interface will be able
- if Linux allows it and the type the operation goes to/from is allowed
- to change the type of private keys to a regular file). This one should
*only* be assigned to a rescue user (if any). Also, this interface is
allowed to label CA management scripts.

``` {lang=&amp;quot;bash&amp;quot;}
interface(`ca_admin&amp;#39;,`
  gen_require(`
    type ca_misc_t, ca_private_key_t;
    type ca_cli_exec_t;
  &amp;#39;)

  allow $1 { ca_misc_t ca_private_key_t }:dir relabel_dir_perms;
  allow $1 { ca_misc_t ca_private_key_t }:file relabel_file_perms;

  allow $1 ca_cli_exec_t:file relabel_file_perms;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So regular system administrators would be assigned the &lt;code&gt;ca_sysadmin()&lt;/code&gt;
interface as well as the &lt;code&gt;setfiles_t&lt;/code&gt; domain; CA handling roles would be
granted the &lt;code&gt;ca_role()&lt;/code&gt; interface. The &lt;code&gt;ca_admin()&lt;/code&gt; interface would only
be granted on the rescue (or super-admin).&lt;/p&gt;
&lt;p&gt;``` {lang="perl"}&lt;/p&gt;
&lt;h1&gt;Regular system administrators&lt;/h1&gt;
&lt;p&gt;ca_sysadmin(sysadm_t)
ca_sysadmin(setfiles_t)&lt;/p&gt;
&lt;h1&gt;Certificate administrator&lt;/h1&gt;
&lt;p&gt;ca_role(certadmin_r, certadmin_t)&lt;/p&gt;
&lt;h1&gt;Security administrator&lt;/h1&gt;
&lt;p&gt;ca_admin(secadm_t)
```&lt;/p&gt;</content><category term="SELinux"></category><category term="ca"></category><category term="certcli"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Gentoo SELinux policy release script</title><link href="https://blog.siphos.be/2013/12/gentoo-selinux-policy-release-script/" rel="alternate"></link><published>2013-12-11T18:37:00+01:00</published><updated>2013-12-11T18:37:00+01:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-12-11:/2013/12/gentoo-selinux-policy-release-script/</id><summary type="html">&lt;p&gt;A few months ago, I wrote a small script that aids in the creation of
new SELinux policy packages. The script is on the
&lt;a href="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-refpolicy.git;a=summary"&gt;repository&lt;/a&gt;
itself, in the &lt;code&gt;gentoo/&lt;/code&gt; subdirectory, and is called
&lt;code&gt;release-prepare.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reason for the script is that there are a number of steps to
perform …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few months ago, I wrote a small script that aids in the creation of
new SELinux policy packages. The script is on the
&lt;a href="http://git.overlays.gentoo.org/gitweb/?p=proj/hardened-refpolicy.git;a=summary"&gt;repository&lt;/a&gt;
itself, in the &lt;code&gt;gentoo/&lt;/code&gt; subdirectory, and is called
&lt;code&gt;release-prepare.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reason for the script is that there are a number of steps to
perform, one of which (tagging the release) I forgot to do too often. So
today I made a new release of the policy packages (2.20130424-r4) with
the script, and decided to blog about it as other developers in the
hardened team might one day be asked to make a release when I'm not
available.&lt;/p&gt;
&lt;p&gt;When the script is called, it spits out the usual help information.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sh release-prepare.sh -h
Usage: release-prepare.sh

Example: release-prepare.sh 2.20130424-r2 2.20130424-r3

The script will copy the ebuilds of the  towards the
 and update the string occurrences of that version
(mostly for the BASEPOL variable).

The following environment variables must be declared correctly for the script
to function properly:
  - GENTOOX86 should point to the gentoo-x86 checkout
    E.g. export GENTOOX86=&amp;quot;/home/user/dev/gentoo-x86&amp;quot;
  - HARDENEDREFPOL should point to the hardened-refpolicy.git checkout
    E.g. export HARDENEDREFPOL=&amp;quot;/home/user/dev/hardened-refpolicy&amp;quot;
  - REFPOLRELEASE should point to the current latest /release/ of the reference
    policy (so NOT to a checkout), extracted somewhere on the file system.
    E.g. export REFPOLRELEASE=&amp;quot;/home/user/local/refpolicy-20130424&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So first, we need to export three environment variables needed by the
script:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GENTOOX86&lt;/code&gt; points to the CVS checkout of the Portage tree. It is
    used to create new ebuilds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HARDENEDREFPOL&lt;/code&gt; is the git checkout of the policy repository. This
    one is used to read the changes from to generate a patch.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REFPOLRELEASE&lt;/code&gt; is an extracted &lt;code&gt;refpolicy-20130424.tar.gz&lt;/code&gt; (the
    upstream release of the reference policy). This extracted location
    is needed to generate the patch (the difference between our
    repository and the upstream release).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After setting the variables, the script does its magic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sh release-prepare.sh 2.20130424-r3 2.20130424-r4
Creating patch 0001-full-patch-against-stable-release.patch... done
Creating patch bundle for 2.20130424-r4... done
Copying patch bundle into /usr/portage/distfiles and dev.g.o... done
Removing old patchbundle references in Manifest (in case of rebuild)... done
Creating new ebuilds based on old version... done
Marking ebuilds as ~arch... done
Creating tag 2.20130424-r4 in our repository... done
The release has now been prepared.

Please go do the following to finish up:
- In /home/swift/dev/gentoo-x86/sec-policy go &amp;quot;cvs add&amp;quot; all the new ebuilds
- In /home/swift/dev/gentoo-x86/sec-policy run &amp;quot;repoman manifest&amp;quot; and &amp;quot;repoman full&amp;quot;

Then, before finally committing - do a run yourself, ensuring that the right
version is deployed of course:
- &amp;quot;emerge -1 sec-policy/selinux-aide
sec-policy/selinux-alsa
...
Only then do a &amp;#39;repoman commit -m &amp;#39;Release of 2.20130424-r4&amp;#39;&amp;#39;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The script performs the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It creates the patch with the difference between the main refpolicy
    release and our repository. Our repository closely follows the
    upstream release, but still contains quite a few changes that have
    not been upstreamed yet (due to history loss of the changes, or the
    changes are very gentoo-specific, or the changes still need to
    be improved). In the past, we maintained all the patches separately,
    but this meant that the deployment of the policy ebuilds took too
    long (around 100 patches being applied takes a while, and took more
    than 80% of the total deployment time on a regular server system).
    By using a single patch file, the deployment time is
    reduced drastically.&lt;/li&gt;
&lt;li&gt;It then compresses this patch file and stores it in
    &lt;code&gt;/usr/portage/distfiles&lt;/code&gt; (so that later &lt;code&gt;repoman manifest&lt;/code&gt; can take
    the file into account) as well as on my dev.gentoo.org location
    (where it is referenced). If other developers create a release, they
    will need to change this location (and the pointer in the ebuilds).&lt;/li&gt;
&lt;li&gt;Previous file references in the &lt;code&gt;Manifest&lt;/code&gt; files are removed, so
    that &lt;code&gt;repoman&lt;/code&gt; does not think the digest can be skipped.&lt;/li&gt;
&lt;li&gt;New ebuilds are created, copied from the previous version. In these
    ebuilds, the &lt;code&gt;KEYWORDS&lt;/code&gt; variable is updated to only contain
    &lt;code&gt;~arch&lt;/code&gt; keywords.&lt;/li&gt;
&lt;li&gt;A release tag is created in the git repository.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then the script tells the user to add the new files to the repository,
run &lt;code&gt;repoman manifest&lt;/code&gt; and &lt;code&gt;repoman full&lt;/code&gt; to verify the quality of the
ebuilds and generate the necessary digests. Then, and also after
testing, the created ebuilds can be committed to the repository.&lt;/p&gt;
&lt;p&gt;The last few steps have explicitly not been automated so the developer
has the chance to update the ebuilds (in case more than just the policy
contents has changed between releases) or do dry runs without affecting
the &lt;code&gt;gentoo-x86&lt;/code&gt; repository.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="hardened"></category><category term="policy"></category><category term="release"></category><category term="selinux"></category></entry><entry><title>Using CUSTOM_BUILDOPT in refpolicy for USE flag-alike functionality?</title><link href="https://blog.siphos.be/2013/08/using-custom_buildopt-in-refpolicy-for-use-flag-alike-functionality/" rel="alternate"></link><published>2013-08-16T09:17:00+02:00</published><updated>2013-08-16T09:17:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-08-16:/2013/08/using-custom_buildopt-in-refpolicy-for-use-flag-alike-functionality/</id><summary type="html">&lt;p&gt;As you are probably aware, Gentoo uses the &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;reference
policy&lt;/a&gt; as its base for
SELinux policies. Yes, we do customize it and not everything is already
pushed upstream (for instance, our approach to use &lt;code&gt;xdg_*_home_t&lt;/code&gt;
customizable types to further restrict user application access has been
sent up for comments …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As you are probably aware, Gentoo uses the &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;reference
policy&lt;/a&gt; as its base for
SELinux policies. Yes, we do customize it and not everything is already
pushed upstream (for instance, our approach to use &lt;code&gt;xdg_*_home_t&lt;/code&gt;
customizable types to further restrict user application access has been
sent up for comments a few times but we still need to iron it out
further) but all in all, we're pretty close to the upstream releases.
This is also visible when there are changes upstream as we very easily
integrate them back in our repository.&lt;/p&gt;
&lt;p&gt;But there are still a few things that I want to implement further, and
one of these things is perhaps too specific for Gentoo but would benefit
us (security-wise) in great detail: enabling domain privileges based on
USE flags. Allow me to quickly use an example to make this more
tangible.&lt;/p&gt;
&lt;p&gt;Consider the MPlayer application. As a media application, it of course
offers support for ALSA and PulseAudio (amongst other things). In the
SELinux policy, support for (and thus privileges related to) ALSA and
PulseAudio is handled through &lt;em&gt;optional_policy&lt;/em&gt; statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;optional_policy(`
  pulseaudio_tmpfs_content(mplayer_tmpfs_t)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This means that the rules defined in &lt;em&gt;pulseaudio_tmpfs_content&lt;/em&gt; are
executed if the dependencies match:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`pulseaudio_tmpfs_content&amp;#39;,`
        gen_require(`
                attribute pulseaudio_tmpfsfile;
        &amp;#39;)

        typeattribute $1 pulseaudio_tmpfsfile;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If the &lt;code&gt;pulseaudio_tmpfsfile&lt;/code&gt; attribute exists, then the
&lt;code&gt;mplayer_tmpfs_t&lt;/code&gt; type gets the &lt;code&gt;pulseaudio_tmpfsfile&lt;/code&gt; attribute
assigned to it.&lt;/p&gt;
&lt;p&gt;This is flexible, because if the server/workstation does not use
PulseAudio, then in Gentoo, no pulseaudio SELinux module will be loaded
and thus the attribute will not exist. However, Gentoo tries to be a bit
more flexible in this - it is very well possible to have PulseAudio
installed, but disable PulseAudio support in MPlayer (build mplayer with
USE="-pulseaudio"). The current definitions in the policy do not support
this flexibility: if the pulseaudio module is loaded, then the
privileges become active.&lt;/p&gt;
&lt;p&gt;One way SELinux supports a more flexible approach is to use conditionals
in the policy. One could create booleans that administrators can toggle
to enable / disable SELinux rules. For instance, in the mplayer policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tunable_policy(`allow_mplayer_execstack&amp;#39;,`
        allow mencoder_t self:process { execmem execstack };
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If an administrator toggles the &lt;code&gt;allow_mplayer_execstack&lt;/code&gt; boolean to
"on", then the mentioned &lt;code&gt;allow&lt;/code&gt; rule becomes active.&lt;/p&gt;
&lt;p&gt;Sadly, this approach is not fully usable for USE driven decisions. Not
all rules can be enclosed in &lt;code&gt;tunable_policy&lt;/code&gt; statements, and &lt;a href="http://oss.tresys.com/pipermail/refpolicy/2013-July/006452.html"&gt;assigning
attributes to a
type&lt;/a&gt;
is one of them (cfr our pulseaudio example). A recent discussion on the
reference policy mailinglist gave me two ideas to investigate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;See if we can support CIL (a new language for SELinux
    policy definitions) where such an approach would be easier&lt;/li&gt;
&lt;li&gt;Use build-time decisions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this post, I want to go through the &lt;em&gt;build-time decisions&lt;/em&gt; idea. The
reference policy supports build-time options using &lt;em&gt;ifdef&lt;/em&gt; constructs.
These look at parameters provided by the build system (M4/Makefile
based) to see if rules need to be activated or not. For type attribute
declarations, this is a valid approach. So one idea would be to
transform USE flags, if they are set, into &lt;code&gt;use_${USEFLAG}&lt;/code&gt;, and make
decisions based on this in the policy code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ifdef(`use_pulseaudio&amp;#39;,`
  optional_policy(`
    pulseaudio_tmpfs_content(mplayer_tmpfs_t)
  &amp;#39;)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can add in the USE flags, if set, through the &lt;code&gt;CUSTOM_BUILDOPT&lt;/code&gt;
parameter that the reference policy provides. So introducing this is not
that difficult. The only thing I'm currently a bit weary about is the
impact on the policy files themselves (which is why I haven't done this
already) and the fact that USE flags on the "real" package are not know
to policy packages. In other words, if a user explicitly marks
&lt;code&gt;USE="-pulseaudio"&lt;/code&gt; on mplayer, but has &lt;code&gt;USE="pulseaudio"&lt;/code&gt; set as
general value, then the &lt;code&gt;selinux-mplayer&lt;/code&gt; package will still have
pulseaudio enabled.&lt;/p&gt;
&lt;p&gt;Still, I do like the idea. It would make it more consistent with what
Gentoo aims to do: if you do not want a certain support/feature in the
code, then why would the policy still have to allow it? With the proper
documentation towards administrators, I think this would be a good
approach.&lt;/p&gt;</content><category term="Gentoo"></category><category term="boolean"></category><category term="Gentoo"></category><category term="policy"></category><category term="selinux"></category><category term="use"></category><category term="useflag"></category></entry><entry><title>A SELinux policy for incron: finishing up</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-finishing-up/" rel="alternate"></link><published>2013-05-31T03:50:00+02:00</published><updated>2013-05-31T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-31:/2013/05/a-selinux-policy-for-incron-finishing-up/</id><summary type="html">&lt;p&gt;After 9 posts, it's time to wrap things up. You can review the final
results online
(&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.te.txt"&gt;incron.te&lt;/a&gt;,
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.if.txt"&gt;incron.if&lt;/a&gt; and
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.fc.txt"&gt;incron.fc&lt;/a&gt;) and
adapt to your own needs if you want. But we should also review what we
have accomplished so far...&lt;/p&gt;
&lt;p&gt;We built the start of an entire …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After 9 posts, it's time to wrap things up. You can review the final
results online
(&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.te.txt"&gt;incron.te&lt;/a&gt;,
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.if.txt"&gt;incron.if&lt;/a&gt; and
&lt;a href="http://dev.gentoo.org/~swift/blog/01/incron.fc.txt"&gt;incron.fc&lt;/a&gt;) and
adapt to your own needs if you want. But we should also review what we
have accomplished so far...&lt;/p&gt;
&lt;p&gt;We built the start of an entire policy for a daemon (the inotify cron
daemon) for two main types: the daemon itself, and its management
application &lt;strong&gt;incrontab&lt;/strong&gt;. We defined new types and contexts, we used
attributes, declared a boolean and worked with interfaces. That's a lot
to digest, and yet it is only a part of the various capabilities that
SELinux offers.&lt;/p&gt;
&lt;p&gt;The policy isn't complete though. We defined a type called
&lt;code&gt;incron_initrc_exec_t&lt;/code&gt; but don't really use it further. In practice, we
would need to define an additional interface (probably named
&lt;em&gt;incron_admin&lt;/em&gt;) that allows users and roles to manage &lt;em&gt;incron&lt;/em&gt; without
needing to grant this user/role &lt;code&gt;sysadm_r&lt;/code&gt; privileges. I leave that up
to you as an exercise for now, but I'll post more about admin interfaces
and how to work with them on a system in the near future.&lt;/p&gt;
&lt;p&gt;We also made a few assumptions and decisions while building the policy
that might not be how you yourself would want to build the policy.
SELinux is a MAC system, but the policy language is very flexible. You
can use an entirely different approach in policies if you want. For
instance, &lt;em&gt;incron&lt;/em&gt; supports launching the &lt;strong&gt;incrond&lt;/strong&gt; as a command-line,
foreground process. This could help users run &lt;strong&gt;incrond&lt;/strong&gt; under their
privileges for their own files - we did not consider this case in our
design. Although most policies try to capture all use cases of an
application, there will be cases when a policy developer did either not
consider the use case or found that it infringed with his own principles
on policy development (and allowed activities on a system).&lt;/p&gt;
&lt;p&gt;In Gentoo Hardened, I try to write down the principles and policies that
we follow in a &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-policy.xml"&gt;Gentoo Hardened SELinux Development
Policy&lt;/a&gt;
document. As decisions need to be taken, such a document might help find
common consensus on how to approach SELinux policy development further,
and I seriously recommend that you consider writing up a similar
document yourself, especially if you are going to develop policies for a
larger organization.&lt;/p&gt;
&lt;p&gt;One of the deficiencies of the current policy is that it worked with the
unmodified &lt;em&gt;incron&lt;/em&gt; version. If we would patch &lt;em&gt;incron&lt;/em&gt; so that it could
change context on executing the incrontab files of a user, then we can
start making use of the default context approach (and perhaps even
enhance with PAM services). In that case, user incrontabs could be
launched entirely from the users' context (like &lt;code&gt;user_u:user_r:user_t&lt;/code&gt;)
instead of the &lt;code&gt;system_u:system_r:incrond_t&lt;/code&gt; or transitioned
&lt;code&gt;system_u:system_r:whatever_t&lt;/code&gt; contexts. Having user provided commands
executed in the system context is a security risk, so in our policy we
would &lt;em&gt;not&lt;/em&gt; grant the &lt;em&gt;incron_role&lt;/em&gt; to untrusted users - probably only
to &lt;code&gt;sysadm_t&lt;/code&gt; and even then he probably would be better with using the
&lt;code&gt;/etc/incron.d&lt;/code&gt; anyway.&lt;/p&gt;
&lt;p&gt;The downside of patching code however is that this is only viable if
upstream wants to support this - otherwise we would need to maintain the
patches ourselves for a long time, creating delays in releases (upstream
released a new version and we still need to reapply and refactor
patches) and removing precious (human) resources from other, Gentoo
Hardened/SELinux specific tasks (like bugfixing and documentation
writing ;-)&lt;/p&gt;
&lt;p&gt;Still, the policy returned a fairly good view on how policies &lt;em&gt;can&lt;/em&gt; be
developed. And as I said, there are still other things that weren't
discussed, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build-time decisions, which can change policies based on build
    options of the policy. In the reference policy, this is most often
    used for distribution-specific choices: if Gentoo would use one
    approach and Redhat another, then the differences would be separated
    through &lt;code&gt;ifdef(`distro_gentoo',`...')&lt;/code&gt; and
    &lt;code&gt;ifdef(`distro_redhat',`...')&lt;/code&gt; calls.&lt;/li&gt;
&lt;li&gt;Some calls might only be needed if another policy is loaded. I think
    all calls made currently are part of base modules, so can be
    expected to be available at all times. But if we would need
    something like &lt;em&gt;icecast_signal(incrond_t)&lt;/em&gt;, then we would need to
    put that call inside a &lt;code&gt;optional_policy(`...')&lt;/code&gt; statement.
    Otherwise, our policy would fail to load because the &lt;em&gt;icecast&lt;/em&gt;
    SELinux policy isn't loaded.&lt;/li&gt;
&lt;li&gt;We could even introduce specific statements like &lt;em&gt;dontaudit&lt;/em&gt; or
    &lt;em&gt;neverallow&lt;/em&gt; to fine-tune the policy. Note though that &lt;em&gt;neverallow&lt;/em&gt;
    is a compile-time statement: it is not a way to negate &lt;em&gt;allow&lt;/em&gt;
    rules: if there is one &lt;em&gt;allow&lt;/em&gt; that would violate the &lt;em&gt;neverallow&lt;/em&gt;,
    then that module just refuses to build.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Furthermore, if you want to create policies to be pushed upstream to the
reference policy project, you will need to look into the
&lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide"&gt;StyleGuide&lt;/a&gt;
and
&lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming"&gt;InterfaceNaming&lt;/a&gt;
documents as those define the order that rules should be placed and the
name syntax for interfaces. I have been contributing a lot to the
reference policy and I still miss a few of these, so for me they are not
that obvious. But using a common style is important as it allows for
simple patching, code comparison and even allows us to easily read
through complex policies.&lt;/p&gt;
&lt;p&gt;If you don't want to contribute it, but still use it on your Gentoo
system, you can use a simple ebuild to install the files. Create an
ebuild (for instance &lt;code&gt;selinux-incron&lt;/code&gt;), put the three files in the
&lt;code&gt;files/&lt;/code&gt; subdirectory, and use the following ebuild code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Copyright 1999-2013 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header$
EAPI=&amp;quot;4&amp;quot;

IUSE=&amp;quot;&amp;quot;
MODS=&amp;quot;incron&amp;quot;
BASEPOL=&amp;quot;2.20130424-r1&amp;quot;
POLICY_FILES=&amp;quot;incron.te incron.fc incron.if&amp;quot;

inherit selinux-policy-2

DESCRIPTION=&amp;quot;SELinux policy for incron, the inotify cron daemon&amp;quot;

KEYWORDS=&amp;quot;~amd64 ~x86&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When installed, the interface files will be published as well and can
then be used by other modules (something we couldn't do in the past few
posts) or by the &lt;strong&gt;selocal&lt;/strong&gt; tool.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: using booleans</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-using-booleans/" rel="alternate"></link><published>2013-05-30T03:50:00+02:00</published><updated>2013-05-30T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-30:/2013/05/a-selinux-policy-for-incron-using-booleans/</id><summary type="html">&lt;p&gt;After using a default set of directories to watch, and &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/"&gt;allowing admins
to mark other
types&lt;/a&gt;
as such as well, let's consider another approach for making the policy
more flexible: booleans. The idea now is that a boolean called
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; enables &lt;strong&gt;incrond&lt;/strong&gt; to be
notified on changes on all possible …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After using a default set of directories to watch, and &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-marking-types-eligible-for-watching/"&gt;allowing admins
to mark other
types&lt;/a&gt;
as such as well, let's consider another approach for making the policy
more flexible: booleans. The idea now is that a boolean called
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; enables &lt;strong&gt;incrond&lt;/strong&gt; to be
notified on changes on all possible non-security related files (the
latter is merely an approach, you can define other sets as well if you
want, including all possible files).&lt;/p&gt;
&lt;p&gt;Booleans in SELinux policy can be generated in the &lt;code&gt;incron.te&lt;/code&gt; file as
follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## &amp;lt;desc&amp;gt;
## &amp;lt;p&amp;gt;
##      Determine whether incron can watch all non-security
##      file types
## &amp;lt;/p&amp;gt;
## &amp;lt;/desc&amp;gt;
gen_tunable(incron_notify_non_security_files, false)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this boolean in place, the policy can be enhanced with code like
the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tunable_policy(`incron_notify_non_security_files&amp;#39;,`
        files_read_non_security_files(incrond_t)
        files_read_all_dirs_except(incrond_t)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This code tells SELinux that, &lt;em&gt;if&lt;/em&gt; the
&lt;em&gt;incron_notify_non_security_files&lt;/em&gt; boolean is set (which by default
is not the case), then &lt;code&gt;incrond_t&lt;/code&gt; is able to read non security files.&lt;/p&gt;
&lt;p&gt;Let's try to watch for changes in the AIDE log directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail audit.log
type=AVC msg=audit(1368777675.597:28611): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;log&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=13 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_log_t tclass=dir
type=AVC msg=audit(1368777675.597:28612): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;log&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=13 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:var_log_t tclass=dir

# tail cron.log
May 17 10:01:15 test incrond[11704]: access denied on /var/log/aide - events will be discarded silently

# getsebool incron_notify_non_security_files
incron_notify_non_security_files --&amp;gt; off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's enable the boolean and try again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# setsebool incron_notify_non_security_files on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Reloading the incrontab tables now works, and the notifications work as
well.&lt;/p&gt;
&lt;p&gt;As you can see, once a policy is somewhat working, policy developers are
considering the various "use cases" of an application, trying to write
down policies that can be used by the majority of users, without
granting too many rights automatically.&lt;/p&gt;</content><category term="SELinux"></category><category term="boolean"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: default set</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-default-set/" rel="alternate"></link><published>2013-05-28T03:50:00+02:00</published><updated>2013-05-28T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-28:/2013/05/a-selinux-policy-for-incron-default-set/</id><summary type="html">&lt;p&gt;I finished the last post a bit with a
&lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/"&gt;cliffhanger&lt;/a&gt;
as &lt;strong&gt;incrond&lt;/strong&gt; is still not working properly, and we got a few denials
that needed to be resolved; here they are again for your convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I finished the last post a bit with a
&lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-incrond-daemon/"&gt;cliffhanger&lt;/a&gt;
as &lt;strong&gt;incrond&lt;/strong&gt; is still not working properly, and we got a few denials
that needed to be resolved; here they are again for your convenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368734110.912:28353): avc:  denied  { getattr } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/home/user/test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
type=AVC msg=audit(1368734110.913:28354): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test2&amp;quot; dev=&amp;quot;dm-0&amp;quot; ino=16 scontext=system_u:system_r:incrond_t tcontext=user_u:object_r:user_home_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The permission we are looking for here is
&lt;em&gt;userdom_list_user_home_content&lt;/em&gt;, but this is only for when we want
to watch a user home directory. What if we want to watch a server upload
directory? Or a cache directory? We might need to have &lt;strong&gt;incrond&lt;/strong&gt; have
the proper accesses on all directories. But then again, &lt;em&gt;all&lt;/em&gt; does sound
a bit... much, doesn't it? So let's split it up in three waves:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;incrond_t&lt;/code&gt; domain will support a minimal set of types that it
    can watch, based on common approaches&lt;/li&gt;
&lt;li&gt;I will introduce an interface that allows other modules to mark
    specific types as being "watch-worthy"&lt;/li&gt;
&lt;li&gt;A boolean will be set to allow &lt;code&gt;incrond_t&lt;/code&gt; to watch a very large set
    of types (just in case the admin trusts it sufficiently)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's first consider a decent minimal set. Within most SELinux policies,
two types are often used for public access (or for uploading of data).
These types are &lt;code&gt;public_content_t&lt;/code&gt; and &lt;code&gt;public_content_rw_t&lt;/code&gt;, and is
used for instance for FTP definitions (upload folders), HTTP servers and
such. So we introduce the proper rights to watch that data. There is an
interface available called &lt;em&gt;miscfiles_read_public_files&lt;/em&gt; but let's
first see if that interface isn't too broad (after all, watching might
not be the same as reading).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# This is only to temporarily check if the rights of the interface are too broad or not
# You can set this using &amp;quot;selocal&amp;quot; or in a module (in which case you&amp;#39;ll need to &amp;#39;require&amp;#39;
# the two types)
allow incrond_t public_content_t:dir { read getattr };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After editing the incrontab to watch a directory labeled with
&lt;code&gt;public_content_t&lt;/code&gt;, we now get the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 08:46:12 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 08:46:12 test incrond[11281]: cannot exec process: Operation not permitted
May 17 08:46:12 test incrond[9716]: cannot send SIGCHLD token to notification pipe

# tail audit.log
type=AVC msg=audit(1368773172.313:28386): avc:  denied  { setgid } for  pid=11281 comm=&amp;quot;incrond&amp;quot; capability=6  scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=capability
type=AVC msg=audit(1368773172.314:28387): avc:  denied  { read } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;pipe:[14027]&amp;quot; dev=&amp;quot;pipefs&amp;quot; ino=14027 scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=fifo_file
type=AVC msg=audit(1368773172.315:28388): avc:  denied  { write } for  pid=9716 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;pipe:[14027]&amp;quot; dev=&amp;quot;pipefs&amp;quot; ino=14027 scontext=system_u:system_r:incrond_t tcontext=system_u:system_r:incrond_t tclass=fifo_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As the incrontab is a user incrontab, we can expect &lt;code&gt;incrond_t&lt;/code&gt; to
require setuid and setgid privileges. Also, the &lt;em&gt;fifo_file&lt;/em&gt; access is
after forking (notice the difference in PID values) and most likely to
communicate to the master process. So let's allow those:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t self:capability { setuid setgid };
allow incrond_t self:fifo_file { read write };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With that set, we get the following upon triggering a file write:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 08:52:46 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 08:52:46 test incrond[11338]: cannot exec process: Permission denied

# tail audit.log
type=AVC msg=audit(1368773566.606:28394): avc:  denied  { read } for  pid=11338 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;ngroups_max&amp;quot; dev=&amp;quot;proc&amp;quot; ino=5711 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:sysctl_kernel_t tclass=file
type=AVC msg=audit(1368773566.607:28395): avc:  denied  { search } for  pid=11338 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;bin&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=1048578 scontext=system_u:system_r:incrond_t tcontext=system_u:object_r:bin_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;ngroups_max&lt;/code&gt; pseudo-file (in &lt;code&gt;/proc/sys/kernel&lt;/code&gt;) returns the
maximum number of supplementary group IDs per process, and is consulted
through the &lt;em&gt;initgroups()&lt;/em&gt; method provided by a system library, so it
&lt;em&gt;might&lt;/em&gt; make sense to allow it. For now though, I will not enable it (as
reading &lt;code&gt;sysctl_kernel_t&lt;/code&gt; exposes a lot of other system information) but
I might be forced to do so later if things don't work out well. The
&lt;em&gt;search&lt;/em&gt; privilege on &lt;code&gt;bin_t&lt;/code&gt; is needed to find the script that I have
prepared (&lt;code&gt;/usr/local/bin/test&lt;/code&gt;) to be executed, so I add in a
&lt;em&gt;corecmd_search_bin&lt;/em&gt; and retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 09:02:55 test incrond[9716]: (user) CMD (/usr/local/bin/test)
May 17 09:02:55 test incrond[11427]: cannot exec process: Permission denied

# tail audit.log
type=AVC msg=audit(1368774175.646:28441): avc:  denied  { read } for  pid=11427 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;sh&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=131454 scontext=system_u:system_r:incrond_t tcontext=root:object_r:bin_t tclass=lnk_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Still not there yet apparently. The &lt;strong&gt;incrond&lt;/strong&gt; forked process wants to
execute the script, but to do so it has to follow a symbolic link
labeled &lt;code&gt;bin_t&lt;/code&gt;. This is because the script points to &lt;code&gt;#!/bin/sh&lt;/code&gt; which
is a symlink to the system shell. We need to follow this link before the
execution can occur; only after execution will the transition from
&lt;code&gt;incrond_t&lt;/code&gt; to &lt;code&gt;system_cronjob_t&lt;/code&gt; be done.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corecmd_read_bin_symlinks(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With that set in the policy, the watch works, &lt;strong&gt;incrond&lt;/strong&gt; properly
launches the command and the command properly transitions into
&lt;code&gt;system_cronjob_t&lt;/code&gt; as we defined earlier (I check this by echo'ing the
output of &lt;strong&gt;id -Z&lt;/strong&gt; into a temporary file).&lt;/p&gt;
&lt;p&gt;So we are left with the (temporary) rights we granted on
&lt;code&gt;public_content_t&lt;/code&gt;. Consider the rules we had versus the rules applied
with &lt;em&gt;miscfiles_read_public_files&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrond_t public_content_t:dir { read getattr };

# miscfiles_read_public_files
allow $1 { public_content_t public_content_rw_t }:dir list_dir_perms;
read_files_pattern($1, { public_content_t public_content_rw_t }, { public_content_t public_content_rw_t })
read_lnk_files_pattern($1, { public_content_t public_content_rw_t }, { public_content_t public_content_rw_t })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The rights here seem to bemore than what we need. Playing around a bit
with the directories reveals that &lt;strong&gt;incrond&lt;/strong&gt; requires a bit more. For
instance, when you create additional directories (subdirectories) and
want to match multiple ones:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# tail cron.log
May 17 09:16:08 test incrond[11704]: access denied on /var/www/test/* - events will be discarded silently
May 17 09:16:08 test incrond[11704]: cannot create watch for user user: (13) Permission denied

# tail audit.log
type=AVC msg=audit(1368774968.416:28504): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1488 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=dir
type=AVC msg=audit(1368774968.416:28505): avc:  denied  { search } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;test&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1488 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Similarly if you want to watch on a particular file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368775274.655:28552): avc:  denied  { getattr } for  pid=11704 comm=&amp;quot;incrond&amp;quot; path=&amp;quot;/var/www/test/testfile&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1709 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=file
type=AVC msg=audit(1368775274.655:28553): avc:  denied  { read } for  pid=11704 comm=&amp;quot;incrond&amp;quot; name=&amp;quot;testfile&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=1709 scontext=system_u:system_r:incrond_t tcontext=root:object_r:public_content_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So it looks like &lt;em&gt;miscfiles_read_public_files&lt;/em&gt; isn't that bad after
all.&lt;/p&gt;
&lt;p&gt;All we are left with is the access to &lt;code&gt;ngroups_max&lt;/code&gt;. We can ignore the
calls and make sure they don't show up in standard auditing using
&lt;em&gt;kernel_dontaudit_read_kernel_sysctls&lt;/em&gt; or we can allow it with
&lt;em&gt;kernel_read_kernel_sysctls&lt;/em&gt;. I'm going to take the former approach
for my system, but your own idea might be different.&lt;/p&gt;
&lt;p&gt;I tested all this with user incrontabs (as those are the "most"
advanced) but one can easily test with system incrontabs as well
(placing one in &lt;code&gt;/etc/incron.d&lt;/code&gt;). Just be aware that &lt;em&gt;incrond&lt;/em&gt; will take
the first match and will not seek other matches. So if a system
incrontab watches &lt;code&gt;/var/www&lt;/code&gt; and another line (or user incrontab)
watches &lt;code&gt;/var/www/localhost/upload&lt;/code&gt; it is very well possible that only
the &lt;code&gt;/var/www&lt;/code&gt; watch is triggered.&lt;/p&gt;
&lt;p&gt;So right now, our &lt;code&gt;incrond_t&lt;/code&gt; policy looks like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrond policy
#

allow incrond_t self:capability { setgid setuid };

allow incrond_t incron_spool_t:dir list_dir_perms;
allow incrond_t incron_spool_t:file read_file_perms;

allow incrond_t self:fifo_file { read write };

allow incrond_t incrond_var_run_t:file manage_file_perms;
files_pid_filetrans(incrond_t, incrond_var_run_t, file)

kernel_dontaudit_read_kernel_sysctls(incrond_t)

corecmd_read_bin_symlinks(incrond_t)
corecmd_search_bin(incrond_t)

files_search_spool(incrond_t)

logging_send_syslog_msg(incrond_t)

auth_use_nsswitch(incrond_t)

miscfiles_read_localization(incrond_t)
miscfiles_read_public_files(incrond_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next on the agenda is another interface to make other types
"watch-worthy".&lt;/p&gt;</content><category term="SELinux"></category><category term="booleans"></category><category term="incrond"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: new types and transitions</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-new-types-and-transitions/" rel="alternate"></link><published>2013-05-26T03:50:00+02:00</published><updated>2013-05-26T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-26:/2013/05/a-selinux-policy-for-incron-new-types-and-transitions/</id><summary type="html">&lt;p&gt;So I've shown the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/"&gt;iterative approach
used&lt;/a&gt;
to develop policies. Again, please be aware that this is my way of
developing policies, other policy developers might have a different
approach. We were working on the &lt;strong&gt;incrontab&lt;/strong&gt; command, so let's
continue with trying to create a new user incrontab:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;So I've shown the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/"&gt;iterative approach
used&lt;/a&gt;
to develop policies. Again, please be aware that this is my way of
developing policies, other policy developers might have a different
approach. We were working on the &lt;strong&gt;incrontab&lt;/strong&gt; command, so let's
continue with trying to create a new user incrontab:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
cannot create temporary file: Permission denied

# tail audit.log
type=AVC msg=audit(1368709633.285:28211): avc:  denied  { setgid } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; capability=6  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368709633.285:28212): avc:  denied  { setuid } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; capability=7  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368709633.287:28213): avc:  denied  { search } for  pid=8159 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=3927 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:tmp_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The requests for the setuid and setgid capabilities are needed for the
application to safely handle the user incrontabs. Note that SELinux does
not "remove" the setuid bit on the binary itself, but does govern the
related capabilities. Since this is required, we will add these
capabilities to the policy. We also notice that &lt;strong&gt;incrontab&lt;/strong&gt; searched
in the &lt;code&gt;/tmp&lt;/code&gt; location.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t self:capability { setuid setgid };
...
files_search_tmp(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the next round of iteration, we notice the same error message with
the following denial:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368728433.521:28215): avc:  denied  { write } for  pid=8913 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;/&amp;quot; dev=&amp;quot;tmpfs&amp;quot; ino=3927 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:tmp_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It is safe to assume here that the process wants to create a temporary
file (if it is a directory, we will find out later and can adapt). But
when temporary files are created, we better make those files a specific
type, like &lt;code&gt;incrontab_tmp_t&lt;/code&gt;. So we define that on top of the policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type incrontab_tmp_t;
files_tmp_file(incrontab_tmp_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Also, we need to allow the &lt;code&gt;incrontab_t&lt;/code&gt; domain write privileges into
the &lt;code&gt;tmp_t&lt;/code&gt; labeled directory, but with an automatic file transition
towards &lt;code&gt;incrontab_tmp_t&lt;/code&gt; for every file written. This is done through
the &lt;em&gt;files_tmp_filetrans&lt;/em&gt; method:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;files_tmp_filetrans(incrontab_t, incrontab_tmp_t, file)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What this sais is that, if a domain &lt;code&gt;incrontab_t&lt;/code&gt; wants to create a
&lt;code&gt;file&lt;/code&gt; inside &lt;code&gt;tmp_t&lt;/code&gt;, then this file is automatically labeled
&lt;code&gt;incrontab_tmp_t&lt;/code&gt;. With SELinux, you can make this more precise: if you
know what the file name would be, then you can add that as a fourth
argument. However, this does not seem necessary now since we definitely
want all files created in &lt;code&gt;tmp_t&lt;/code&gt; to become &lt;code&gt;incrontab_tmp_t&lt;/code&gt;. All that
rests us is to allow &lt;strong&gt;incrontab&lt;/strong&gt; to actually manage those files:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t incrontab_tmp_t:file manage_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With those in place, let's look at the outcome:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
editor finished with error: No such file or directory

# tail audit.log
type=AVC msg=audit(1368729268.465:28217): avc:  denied  { search } for  pid=8981 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;bin&amp;quot; dev=&amp;quot;dm-3&amp;quot; ino=524289 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:bin_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Considering that here, &lt;strong&gt;incrontab&lt;/strong&gt; is going to launch the users
&lt;code&gt;$EDITOR&lt;/code&gt; application to allow him (or her) to create an incrontab, we
need to allow &lt;code&gt;incrontab_t&lt;/code&gt; not only search privileges inside &lt;code&gt;bin_t&lt;/code&gt;
directories, but also execute rights:
&lt;em&gt;corecmd_exec_bin(incrontab_t)&lt;/em&gt;. We choose here to execute the editor
inside the existing domain (&lt;code&gt;incrontab_t&lt;/code&gt;) instead of creating a
different domain for the editor for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If we would create a separate domain for the editor, the editor
    would eventually need to have major permissions, depending on when
    it is used. Editors can be used to modify the sudoers files, passwd
    files, the &lt;code&gt;/etc/selinux/config&lt;/code&gt; file, etc. Instead, it makes much
    more sense to just be able to launch the editor in the current
    domain (which is much more confined to its specific purpose)&lt;/li&gt;
&lt;li&gt;The additional privileges needed to launch the editor are usually
    very slim, or even nonexistent. It generally only makes sense if, by
    executing it, the existing domain would need many more privileges,
    because then a new (confined) domain keeps the privileges for the
    current domain low.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's see if things work now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e
(Editor opened, so I added in an incrontab line. Upon closing:)
cannot move temporary table: Permission denied

# tail audit.log
type=AVC msg=audit(1368729825.673:28237): avc:  denied  { dac_read_search } for  pid=9030 comm=&amp;quot;incrontab&amp;quot; capability=2  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
type=AVC msg=audit(1368729825.673:28237): avc:  denied  { dac_override } for  pid=9030 comm=&amp;quot;incrontab&amp;quot; capability=1  scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=capability
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From a quick look through &lt;strong&gt;ps&lt;/strong&gt;, I notice that the application runs as
the user (luckily, otherwise I could use the editor to escape and get a
root shell) after which it tries to do something. Of course, it makes
sense that it wants to move this newly created incrontab file somewhere
in &lt;code&gt;/var/spool/incron&lt;/code&gt; so we grant it the permission to
&lt;code&gt;dac_read_search&lt;/code&gt; (which is lower than &lt;code&gt;dac_override&lt;/code&gt; as &lt;a href="http://blog.siphos.be/2013/05/the-weird-audit_access-permission/"&gt;explained
before&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t self:capability { dac_read_search setuid setgid };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On to the next failure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -e 
cannot move temporary table: Permission denied

# tail audit.log
type=AVC msg=audit(1368730155.706:28296): avc:  denied  { write } for  pid=9088 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;incron&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=19725 scontext=user_u:user_r:incrontab_t tcontext=root:object_r:incron_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now the application wants to write this file there. Now remember we
already have &lt;code&gt;search_dir_perms&lt;/code&gt; permissions into &lt;code&gt;incron_spool_t&lt;/code&gt;? We
need to expand those with read/write permissions into the directory, and
manage permissions on files (manage because users should be able to
create, modify and delete their files). These two permissions are
combined in the &lt;em&gt;manage_files_pattern&lt;/em&gt; interface, and makes the search
one obsolete:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;manage_files_pattern(incrontab_t, incron_spool_t, incron_spool_t)

$ incrontab -e
...
table updated
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally! And looking at the other options in &lt;strong&gt;incrontab&lt;/strong&gt;, it seems
that the policy for &lt;code&gt;incrontab_t&lt;/code&gt; is finally complete, and looks like
so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;###########################################
#
# incrontab policy
#

allow incrontab_t self:capability { setuid setgid dac_read_search };

manage_files_pattern(incrontab_t, incron_spool_t, incron_spool_t)

allow incrontab_t incrontab_tmp_t:file manage_file_perms;
files_tmp_filetrans(incrontab_t, incrontab_tmp_t, file)

corecmd_exec_bin(incrontab_t)

domain_use_interactive_fds(incrontab_t)

files_search_spool(incrontab_t)
files_search_tmp(incrontab_t)

auth_use_nsswitch(incrontab_t)

userdom_use_user_terminals(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next on the agenda: the &lt;code&gt;incrond_t&lt;/code&gt; domain.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: basic set for incrontab</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/" rel="alternate"></link><published>2013-05-25T03:50:00+02:00</published><updated>2013-05-25T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-25:/2013/05/a-selinux-policy-for-incron-basic-set-for-incrontab/</id><summary type="html">&lt;p&gt;Now that our &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/"&gt;regular user is
allowed&lt;/a&gt;
to execute &lt;strong&gt;incrontab&lt;/strong&gt;, let's fire it up and look at the denials to
build up the policy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That doesn't show much does it? Well, if you look into the &lt;code&gt;audit.log&lt;/code&gt;
(or &lt;code&gt;avc.log&lt;/code&gt;) file, you'll notice a lot of denials …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Now that our &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/"&gt;regular user is
allowed&lt;/a&gt;
to execute &lt;strong&gt;incrontab&lt;/strong&gt;, let's fire it up and look at the denials to
build up the policy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That doesn't show much does it? Well, if you look into the &lt;code&gt;audit.log&lt;/code&gt;
(or &lt;code&gt;avc.log&lt;/code&gt;) file, you'll notice a lot of denials. If you are
developing a policy, it is wise to clear the entire log and reproduce
the "situation" so you get a proper idea of the scope.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# cd /var/log/audit
# &amp;gt; audit.log
# tail -f audit.log | grep AVC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now let's run &lt;strong&gt;incrontab --help&lt;/strong&gt; again and look at the denials:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368707274.429:28180): avc:  denied  { read write } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=user_u:object_r:user_tty_device_t tclass=chr_file
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
type=AVC msg=audit(1368707274.429:28180): avc:  denied  { use } for  pid=7742 comm=&amp;quot;incrontab&amp;quot; path=&amp;quot;/dev/tty2&amp;quot; dev=&amp;quot;devtmpfs&amp;quot; ino=1042 scontext=user_u:user_r:incrontab_t tcontext=system_u:system_r:getty_t tclass=fd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can start piping this information into &lt;strong&gt;audit2allow&lt;/strong&gt; to generate
policy statements, but I personally prefer not to use &lt;strong&gt;audit2allow&lt;/strong&gt;
for building new policies. For one, it is not intelligent enough to
deduce if a denial should be fixed by allowing it, or by relabeling or
even by creating a new type. Instead, it always grants it. Second, it
does not know if a denial is cosmetic (and thus can be ignored) or not.&lt;/p&gt;
&lt;p&gt;This latter is also why I don't run domains in permissive mode to see
the majority of denials first and to build from those: you might see
denials that are actually never triggered when running in enforcing
mode. So let's look at the access to &lt;code&gt;/dev/tty2&lt;/code&gt;. Given that this is a
user application where we expect output to the screen, we want to grant
it the proper access. With &lt;strong&gt;sefindif&lt;/strong&gt; as
&lt;a href="http://blog.siphos.be/2013/05/commandline-selinux-policy-helper-functions/"&gt;documented&lt;/a&gt;
before, we can look for the proper interfaces we need. I look for
&lt;code&gt;user_tty_device_t&lt;/code&gt; with &lt;code&gt;rw&lt;/code&gt; (commonly used for read-write):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif user_tty_device_t.*rw
system/userdomain.if: template(`userdom_base_user_template&amp;#39;,`
system/userdomain.if:   allow $1_t user_tty_device_t:chr_file { setattr rw_chr_file_perms };
system/userdomain.if: interface(`userdom_use_user_ttys&amp;#39;,`
system/userdomain.if:   allow $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_use_user_terminals&amp;#39;,`
system/userdomain.if:   allow $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_dontaudit_use_user_terminals&amp;#39;,`
system/userdomain.if:   dontaudit $1 user_tty_device_t:chr_file rw_term_perms;
system/userdomain.if: interface(`userdom_dontaudit_use_user_ttys&amp;#39;,`
system/userdomain.if:   dontaudit $1 user_tty_device_t:chr_file rw_file_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Two of these look interesting: &lt;em&gt;userdom_use_user_ttys&lt;/em&gt; and
&lt;em&gt;userdom_use_user_terminals&lt;/em&gt;. Looking at the API documentation (or
the rules defined therein using &lt;strong&gt;seshowif&lt;/strong&gt;) reveals that
&lt;em&gt;userdom_use_user_terminals&lt;/em&gt; is needed if you also want the
application to work when invoked through a devpts terminal, which is
probably also something our user(s) want to do, so we'll add that. The
second one - using the file descriptor that has the &lt;code&gt;getty_t&lt;/code&gt; context -
is related to this, but not granted through the
&lt;em&gt;userdom_use_user_ttys&lt;/em&gt;. We could grant &lt;em&gt;getty_use_fds&lt;/em&gt; but my
experience tells me that &lt;em&gt;domain_use_interactive_fds&lt;/em&gt; is more likely
to be needed: the application inherits and uses a file descriptor
currently owned by &lt;code&gt;getty_t&lt;/code&gt; but it could be from any of the other
domains that has such file descriptors. For instance, if you grant the
&lt;em&gt;incron_role&lt;/em&gt; to &lt;code&gt;sysadm_r&lt;/code&gt;, then a user that switched roles through
&lt;strong&gt;newrole&lt;/strong&gt; will see denials for using a file descriptor owned by
&lt;code&gt;newrole_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Experience is an important aspect in developing policies. If you would
go through with &lt;em&gt;getty_use_fds&lt;/em&gt; it would work as well, and you'll
probably hit the above mentioned experience later when you try the
application through a few different paths (such as within a screen
session or so). When you &lt;em&gt;think&lt;/em&gt; that the target context (in this case
&lt;code&gt;getty_t&lt;/code&gt;) could be a placeholder (so other types are likely to be
needed as well), make sure you check which attributes are assigned to
the type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seinfo -tgetty_t -x
   getty_t
      privfd
      mcssetcats
      mlsfileread
      mlsfilewrite
      application_domain_type
      domain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of the above ones, &lt;code&gt;privfd&lt;/code&gt; is the important one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif privfd.*use
kernel/domain.if: interface(`domain_use_interactive_fds&amp;#39;,`
kernel/domain.if:       allow $1 privfd:fd use;
kernel/domain.if: interface(`domain_dontaudit_use_interactive_fds&amp;#39;,`
kernel/domain.if:       dontaudit $1 privfd:fd use;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So let's update &lt;code&gt;incron.te&lt;/code&gt; accordingly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
type incron_spool_t;
files_type(incron_spool_t)

###########################################
#
# incrontab policy
#

userdom_use_user_terminals(incrontab_t)
domain_use_interactive_fds(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Rebuild the policy and load it in memory.&lt;/p&gt;
&lt;p&gt;If we now run &lt;strong&gt;incrontab&lt;/strong&gt; we get the online help as we expected. Let's
now look at the currently installed incrontabs (there shouldn't be any
of course):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot determine current user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the denials, we notice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type=AVC msg=audit(1368708632.060:28192): avc:  denied  { create } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; scontext=user_u:user_r:incrontab_t tcontext=user_u:user_r:incrontab_t tclass=unix_stream_socket
type=AVC msg=audit(1368708632.060:28194): avc:  denied  { read } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;nsswitch.conf&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=393768 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:etc_t tclass=file
type=AVC msg=audit(1368708632.062:28196): avc:  denied  { read } for  pid=7968 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;passwd&amp;quot; dev=&amp;quot;dm-2&amp;quot; ino=394223 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:etc_t tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's first focus on &lt;code&gt;nsswitch.conf&lt;/code&gt; and &lt;code&gt;passwd&lt;/code&gt;. Although both require
read access to &lt;code&gt;etc_t&lt;/code&gt; files, it might be wrong to just add in
&lt;em&gt;files_read_etc&lt;/em&gt; (which is what &lt;strong&gt;audit2allow&lt;/strong&gt; is probably going to
suggest). For nsswitch, there is a special interface available:
&lt;em&gt;auth_use_nsswitch&lt;/em&gt;. It is very, very likely that you'll need this
one, especially if you want to share the policy with others who might
not have all of the system databases in local files (as &lt;code&gt;etc_t&lt;/code&gt; files).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;...
domain_use_interactive_fds(incrontab_t)
auth_use_nsswitch(incrontab_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's retry:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot read table for &amp;#39;user&amp;#39;: Permission denied

# tail audit.log
type=AVC msg=audit(1368708893.260:28199): avc:  denied  { search } for  pid=7997 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;spool&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=20 scontext=user_u:user_r:incrontab_t tcontext=system_u:object_r:var_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So we need to grant search privileges on &lt;code&gt;var_spool_t&lt;/code&gt;. This is offered
through &lt;em&gt;files_search_spool&lt;/em&gt;. Add it to the policy, rebuild and retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
cannot read table for &amp;#39;user&amp;#39;: Permission denied

# tail audit.log
type=AVC msg=audit(1368709146.426:28201): avc:  denied  { search } for  pid=8046 comm=&amp;quot;incrontab&amp;quot; name=&amp;quot;incron&amp;quot; dev=&amp;quot;dm-4&amp;quot; ino=19725 scontext=user_u:user_r:incrontab_t tcontext=root:object_r:incron_spool_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For this one, no interface exists yet. We might be able to create one
for ourselves, but as long as other domains don't need it, we can just
add it locally in our policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow incrontab_t incron_spool_t:dir search_dir_perms;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Adding raw allow rules in a policy is, according to the &lt;a href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide"&gt;refpolicy
styleguide&lt;/a&gt;,
only allowed if the policy module defines both the source and the
destination type of the rule. If you look into other policies you might
also find that you can use the &lt;em&gt;search_dirs_patter&lt;/em&gt; call. However,
that one only makes sense if you need to do this on top of another
directory - just look at the definition of &lt;em&gt;search_dirs_pattern&lt;/em&gt;. So
with this permission set, let's retry.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ incrontab -l
no table for user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Great, we have successfully updated the policy until the commands
worked. In the next post, we'll enhance it even further while creating
new incrontabs.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="incrontab"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>A SELinux policy for incron: our first interface</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-our-first-interface/" rel="alternate"></link><published>2013-05-24T03:50:00+02:00</published><updated>2013-05-24T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-24:/2013/05/a-selinux-policy-for-incron-our-first-interface/</id><summary type="html">&lt;p&gt;The next step after having &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/"&gt;a basic
skeleton&lt;/a&gt;
is to get &lt;strong&gt;incrontab&lt;/strong&gt; running. We know however that everything invoked
from the main daemon will be running with the rights of the daemon
context (unless we would patch the source code, but that is beyond the
scope of this set of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The next step after having &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/"&gt;a basic
skeleton&lt;/a&gt;
is to get &lt;strong&gt;incrontab&lt;/strong&gt; running. We know however that everything invoked
from the main daemon will be running with the rights of the daemon
context (unless we would patch the source code, but that is beyond the
scope of this set of posts). As a result, we probably do not want
everyone to be able to launch commands through this application.&lt;/p&gt;
&lt;p&gt;What we want to do is to limit who can invoke &lt;strong&gt;incrontab&lt;/strong&gt; and, as
such, limit who can decide what is invoked through &lt;strong&gt;incrond&lt;/strong&gt;. First of
all, we define a &lt;em&gt;role attribute&lt;/em&gt; called &lt;code&gt;incrontab_roles&lt;/code&gt;. Every role
that gets this attribute assigned will be able to transition to the
&lt;code&gt;incrontab_t&lt;/code&gt; domain.&lt;/p&gt;
&lt;p&gt;We can accomplish this by editing the &lt;code&gt;incron.te&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(incron, 0.2)

# Declare the incrontab_roles attribute
attribute_role incrontab_roles;

...
type incrontab_t;
type incrontab_exec_t;
application_domain(incrontab_t, incrontab_exec_t)
# Allow incrontab_t for all incrontab_roles 
role incrontab_roles types incrontab_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, we need something where we can allow user domains to call
incrontab. This will be done through an interface. Let's look at
&lt;code&gt;incron.if&lt;/code&gt; with one such interface in it: the &lt;em&gt;incron_role&lt;/em&gt; interface.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;## inotify-based cron-like daemon

#########################################
## &amp;lt;summary&amp;gt;
##      Role access for incrontab
## &amp;lt;/summary&amp;gt;
## &amp;lt;param name=&amp;quot;role&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      Role allowed access.
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
## &amp;lt;param name=&amp;quot;domain&amp;quot;&amp;gt;
##      &amp;lt;summary&amp;gt;
##      User domain for the role.
##      &amp;lt;/summary&amp;gt;
## &amp;lt;/param&amp;gt;
#
interface(`incron_role&amp;#39;,`
        gen_require(`
                attribute_role incrontab_roles;
                type incrontab_exec_t, incrontab_t;
        &amp;#39;)

        roleattribute $1 incrontab_roles;

        domtrans_pattern($2, incrontab_exec_t, incrontab_t)

        ps_process_pattern($2, incrontab_t)
        allow $2 incrontab_t:process signal;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The comments in the file are somewhat special: if the comments start
with two hashes (&lt;code&gt;##&lt;/code&gt;) then it is taken into account while building the
policy documentation in &lt;code&gt;/usr/share/doc/selinux-base-*&lt;/code&gt;. The interface
itself, &lt;em&gt;incron_role&lt;/em&gt;, grants a user role and domain the necessary
privileges to transition to the &lt;code&gt;incrontab_t&lt;/code&gt; domain as well as read
process information (as used through &lt;strong&gt;ps&lt;/strong&gt;, hence the name of the
pattern being &lt;code&gt;ps_process_pattern&lt;/code&gt;) and send a standard signal to it.
Most of the time, you can use &lt;code&gt;signal_perms&lt;/code&gt; here but from looking at
the application we see that the application is setuid root, so we don't
want to grant too many privileges by default if they are not needed.&lt;/p&gt;
&lt;p&gt;With this interface file created, we can rebuild the module and load it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile incron.pp
# semodule -i incron.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But how to assign this interface to users? Well, what we want to do is
something like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;incron_role(user_r, user_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When interfaces are part of the policy provided by the distribution, the
definitions of it are stored in the proper location and you can easily
add it. For instance, in Gentoo, if you want to allow the &lt;code&gt;user_r&lt;/code&gt; role
and &lt;code&gt;user_t&lt;/code&gt; domain the &lt;em&gt;cron_role&lt;/em&gt; access (and assuming it doesn't
have so already), then you can call &lt;strong&gt;selocal&lt;/strong&gt; as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal -a &amp;quot;cron_role(user_r, user_t)&amp;quot; -c &amp;quot;Granting user_t cron access&amp;quot; -Lb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, because the interface is currently not known yet, we need to
create a second small policy that does this. Create a file (called
&lt;code&gt;localuser.te&lt;/code&gt; or so) with the following content:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(localuser, 0.1)

gen_require(`
        type user_t;
        role user_r;
&amp;#39;)

incron_role(user_r, user_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now build the policies and load them. We'll now just build and load all
the policies in the current directory (which will be the incron and
localuser ones):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile
# semodule -i *.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can now verify that the user is allowed to transition to the
&lt;code&gt;incrontab_t&lt;/code&gt; domain:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# seinfo -ruser_r -x | grep incron
         incrontab_t
# sesearch -s user_t -t incrontab_exec_t -AdCTS
Found 1 semantic av rules:
   allow user_t incrontab_exec_t : file { read getattr execute open } ;

Found 1 semantic te rules:
   type_transition user_t incrontab_exec_t : process incrontab_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Great, let's get to our first failure to resolve... in the next post ;-)&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="interface"></category><category term="policy"></category></entry><entry><title>A SELinux policy for incron: the basic skeleton</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/" rel="alternate"></link><published>2013-05-23T03:50:00+02:00</published><updated>2013-05-23T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-23:/2013/05/a-selinux-policy-for-incron-the-basic-skeleton/</id><summary type="html">&lt;p&gt;So, in the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/"&gt;previous
post&lt;/a&gt;
I talked about &lt;em&gt;incron&lt;/em&gt; and why I think moving it into the existing cron
policy would not be a good idea. It works, somewhat, but is probably not
that future-proof. So we're going to create our own policy for it.&lt;/p&gt;
&lt;p&gt;In SELinux, policies are generally …&lt;/p&gt;</summary><content type="html">&lt;p&gt;So, in the &lt;a href="http://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/"&gt;previous
post&lt;/a&gt;
I talked about &lt;em&gt;incron&lt;/em&gt; and why I think moving it into the existing cron
policy would not be a good idea. It works, somewhat, but is probably not
that future-proof. So we're going to create our own policy for it.&lt;/p&gt;
&lt;p&gt;In SELinux, policies are generally written through 3 files:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a &lt;em&gt;type enforcement&lt;/em&gt; file that contains the SELinux rules applicable
    to the domain(s) related to the application (in our example,
    &lt;em&gt;incron&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;file context&lt;/em&gt; file that tells the SELinux utilities how the files
    and directories offered by the application should be labeled&lt;/li&gt;
&lt;li&gt;an &lt;em&gt;interface definition&lt;/em&gt; file that allows other SELinux policy
    modules to gain rights offered through the (to be written) &lt;em&gt;incron&lt;/em&gt;
    policy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We now need to create a skeleton for the policy. This skeleton will
define the types related to the application. Such types can be the
domains for the processes (the context of the &lt;strong&gt;incrond&lt;/strong&gt; and perhaps
also &lt;strong&gt;incrontab&lt;/strong&gt; applications), the contexts for the directories (if
any) and files, etc.&lt;/p&gt;
&lt;p&gt;So let's take a look at the content of the &lt;em&gt;incron&lt;/em&gt; package. On Gentoo,
we can use &lt;strong&gt;qlist incron&lt;/strong&gt; for this. In the output of &lt;strong&gt;qlist&lt;/strong&gt;, I
added comments to show you how contexts can be (easily) deduced.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Application binary for managing user crontabs. We want to give this a specific
# context because we want the application (which will manage the incrontabs in
# /var/spool/incron) in a specific domain
/usr/bin/incrontab  ## incrontab_exec_t

# General application information files, do not need specific attention
# (the default context is fine)
/usr/share/doc/incron-0.5.10/README.bz2
/usr/share/doc/incron-0.5.10/TODO.bz2
/usr/share/doc/incron-0.5.10/incron.conf.example.bz2
/usr/share/doc/incron-0.5.10/CHANGELOG.bz2
/usr/share/man/man8/incrond.8.bz2
/usr/share/man/man5/incron.conf.5.bz2
/usr/share/man/man5/incrontab.5.bz2
/usr/share/man/man1/incrontab.1.bz2

# Binary for the incrond daemon. This definitely needs its own context, since
# it will be launched from an init script and we do not want it to run in the
# initrc_t domain.
/usr/sbin/incrond ## incrond_exec_t

# This is the init script for the incrond daemon. If we want to allow 
# some users the rights to administer incrond without needing to grant
# those users the sysadm_r role, we need to give this file a different
# context as well.
/etc/init.d/incrond ## incrond_initrc_exec_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this information at hand, and the behavior of the application we
know from the previous post, can lead to the following &lt;code&gt;incron.fc&lt;/code&gt; file,
which defines the file contexts for the application.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/incron.d(/.*)?     gen_context(system_u:object_r:incron_spool_t,s0)

/etc/rc\.d/init\.d/incrond      --      gen_context(system_u:object_r:incrond_initrc_exec_t,s0)

/usr/bin/incrontab      --      gen_context(system_u:object_r:incrontab_exec_t,s0)

/usr/sbin/incrond       --      gen_context(system_u:object_r:incrond_exec_t,s0)

/var/spool/incron(/.*)?         gen_context(system_u:object_r:incron_spool_t,s0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The syntax of this file closely follows the syntax that &lt;strong&gt;semanage
fcontext&lt;/strong&gt; takes - at least for the regular expressions in the
beginning. The last column is specifically for policy development to
generate a context based on the policies' requirements: an MCS/MLS
enabled policy will get the trailing sensitivity with it, but when
MCS/MLS is disabled then it is dropped. The middle column is to specify
if the label should only be set on regular files (&lt;code&gt;--&lt;/code&gt;), directories
(&lt;code&gt;-d&lt;/code&gt;), sockets (&lt;code&gt;-s&lt;/code&gt;), symlinks (&lt;code&gt;-l&lt;/code&gt;), etc. If it is omitted, it
matches whatever class the path matches.&lt;/p&gt;
&lt;p&gt;The second file needed for the skeleton is the &lt;code&gt;incron.te&lt;/code&gt; file, which
would look like so. I added in inline comments here to explain why
certain lines are prepared, but generally this is omitted when the
policy is &lt;a href="http://oss.tresys.com/projects/refpolicy/"&gt;upstreamed&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;policy_module(incron, 0.1)
# The above line declares that this file is a SELinux policy file. Its name
# is incron, so the file should saved as incron.te

# First, we declare the incrond_t domain, used for the &amp;quot;incrond&amp;quot; process.
# Because it is launched from an init script, we tell the policy that
# incrond_exec_t (the context of incrond), when launched from init, should
# transition to incrond_t.
#
# Basically, the syntax here is:
# type 
# type 
# 
type incrond_t;
type incrond_exec_t;
init_daemon_domain(incrond_t, incrond_exec_t)

# Next we declare that the incrond_initrc_exec_t is an init script context
# so that init can execute it (remember, SELinux is a mandatory access control
# system, so if we do not tell that init can execute it, it won&amp;#39;t).
type incrond_initrc_exec_t;
init_script_file(incrond_initrc_exec_t)

# We also create the incrontab_t domain (for the &amp;quot;incrontab&amp;quot; application), which
# is triggered through the incrontab_exec_t labeled file. This again follows a bit
# the syntax as we used above, but now the interface call is &amp;quot;application_domain&amp;quot;.
type incrontab_t;
type incrontab_exec_t;
application_domain(incrontab_t, incrontab_exec_t)

# Finally we declare the spool type as well (incron_spool_t) and tell SELinux that
# it will be used for regular files.
type incron_spool_t;
files_type(incron_spool_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Knowing which interface calls, like &lt;em&gt;init_daemon_domain&lt;/em&gt; and
&lt;em&gt;application_domain&lt;/em&gt;, we should use is not obvious at first. Most of
this can be gathered from existing policies. Other frequently occurring
interfaces to be used immediately at the skeleton side are (examples for
a &lt;code&gt;foo_t&lt;/code&gt; domain):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;logging_log_file(foo_log_t)&lt;/em&gt; to inform SELinux that the context
    is used for logging purposes. This allows generic log-related
    daemons to do "their thing" with the file.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_tmp_file(foo_tmp_t)&lt;/em&gt; to identify the context as being
    used for temporary files&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_tmpfs_file(foo_tmpfs_t)&lt;/em&gt; for tmpfs files (which could be
    shared memory)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_pid_file(foo_var_run_t)&lt;/em&gt; for PID files (and other run
    metadata files)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_config_file(foo_conf_t)&lt;/em&gt; for configuration files (often
    within &lt;code&gt;/etc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;files_lock_file(foo_lock_t)&lt;/em&gt; for lock files (often within
    &lt;code&gt;/run/lock&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We might be using these later as we progress with the policy (for
instance, the PID file is a very high candidate for needing to be
included). However, with the information currently at hand, we have our
first policy module ready for building. Save the type enforcement rules
in &lt;code&gt;incron.te&lt;/code&gt; and the file contexts in &lt;code&gt;incron.fc&lt;/code&gt; and you can then
build the SELinux policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# make -f /usr/share/selinux/strict/include/Makefile incron.pp
# semodule -i incron.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On Gentoo, you can then relabel the files and directories offered
through the package using &lt;strong&gt;rlpkg&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# rlpkg incron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next is to start looking at the &lt;strong&gt;incrontab&lt;/strong&gt; application.&lt;/p&gt;</content><category term="SELinux"></category><category term="fc"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category><category term="skeleton"></category><category term="te"></category></entry><entry><title>A SELinux policy for incron: what does it do?</title><link href="https://blog.siphos.be/2013/05/a-selinux-policy-for-incron-what-does-it-do/" rel="alternate"></link><published>2013-05-22T03:50:00+02:00</published><updated>2013-05-22T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-22:/2013/05/a-selinux-policy-for-incron-what-does-it-do/</id><summary type="html">&lt;p&gt;In this series of posts, we'll go through the creation of a SELinux
policy for
&lt;a href="http://inotify.aiken.cz/?section=incron&amp;amp;page=doc⟨=en"&gt;incron&lt;/a&gt;, a simple
inotify based cron-like application. I will talk about the various steps
that I would take in the creation of this policy, and give feedback when
certain decisions are taken and why. At …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this series of posts, we'll go through the creation of a SELinux
policy for
&lt;a href="http://inotify.aiken.cz/?section=incron&amp;amp;page=doc⟨=en"&gt;incron&lt;/a&gt;, a simple
inotify based cron-like application. I will talk about the various steps
that I would take in the creation of this policy, and give feedback when
certain decisions are taken and why. At the end of the series, we'll
have a hopefully well working policy.&lt;/p&gt;
&lt;p&gt;The first step in developing a policy is to know what the application
does and how/where it works. This allows us to check if its behavior
matches an existing policy (and as such might be best just added to this
policy) or if a new policy needs to be written. So, what does incron do?&lt;/p&gt;
&lt;p&gt;From the documentation, we know that &lt;em&gt;incron&lt;/em&gt; is a cron-like application
that, unlike cron, works with file system notification events instead of
time-related events. Other than that, it uses a similar way of working:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A daemon called &lt;strong&gt;incrond&lt;/strong&gt; is the run-time application that reads
    in the &lt;em&gt;incrontab&lt;/em&gt; files and creates the proper inotify watches.
    When a watch is triggered, it will execute the matching rule.&lt;/li&gt;
&lt;li&gt;The daemon looks at two definitions (incrontabs): one system-wide
    (in &lt;code&gt;/etc/incron.d&lt;/code&gt;) and one for users (in &lt;code&gt;/var/spool/incron&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The user tabfiles are managed through &lt;strong&gt;incrontab&lt;/strong&gt; (the command)&lt;/li&gt;
&lt;li&gt;Logging is done through syslog&lt;/li&gt;
&lt;li&gt;User commands are executed with the users' privileges (so the
    application calls &lt;em&gt;setuid()&lt;/em&gt; and &lt;em&gt;setgid()&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this, one can create a script to be executed when a file is
uploaded (or deleted) to/from a file server, or when a process coredump
occurred, or whatever automation you want to trigger when some file
system event occurred. Events are plenty and can be found in
&lt;code&gt;/usr/include/sys/inotify.h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, with this information, it is safe to assume that we might be able to
push incron in the existing &lt;em&gt;cron&lt;/em&gt; policy. After all, it defines the
contexts for all these and probably doesn't need any additional
tweaking. And this seems to work at first, but a few tests reveal that
the behavior is not that optimal.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# chcon -t crond_exec_t /usr/sbin/incrond
# chcon -t crontab_exec_t /usr/bin/incrontab
# chcon -R -t system_cron_spool_t /etc/incron.d
# chcon -t cron_log_t /var/log/cron.log
# chcon -R -t cron_spool_t /var/spool/incron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;System tables work somewhat, but all commands are executed in the
&lt;code&gt;crond_t&lt;/code&gt; domain, not in a &lt;code&gt;system_cronjob_t&lt;/code&gt; or related domain.&lt;br&gt;
User tables fail when dealing with files in the users directories,
since these too run in &lt;code&gt;crond_t&lt;/code&gt; and thus have no read access to the
user home directories.&lt;/p&gt;
&lt;p&gt;The problems we notice come from the fact that the application is very
simple in its code: it is not SELinux-aware (so it doesn't change the
runtime context) as most cron daemons are, and when it changes the user
id it does not call PAM, so we cannot trigger &lt;code&gt;pam_selinux.so&lt;/code&gt; to handle
context changes either. As a result, the entire daemon keeps running in
&lt;code&gt;crond_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is one reason why a separate domain could be interesting: we might
want to extend the rights of the daemon domain a bit, but don't want to
extend these rights to the other cron daemons (who also run in
&lt;code&gt;crond_t&lt;/code&gt;). Another reason is that the cron policy has a few booleans
that would not affect the behavior at all, making it less obvious for
users to troubleshoot. As a result, we'll go for the separate policy
instead - which will be for the next post.&lt;/p&gt;</content><category term="SELinux"></category><category term="incron"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Why oh why does a process run in unlabeled_t?</title><link href="https://blog.siphos.be/2013/05/why-oh-why-does-a-process-run-in-unlabeled_t/" rel="alternate"></link><published>2013-05-21T03:50:00+02:00</published><updated>2013-05-21T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-21:/2013/05/why-oh-why-does-a-process-run-in-unlabeled_t/</id><summary type="html">&lt;p&gt;If you notice that a process is running in the &lt;code&gt;unlabeled_t&lt;/code&gt; domain, the
first question to ask is how it got there.&lt;/p&gt;
&lt;p&gt;Well, one way is to have a process running in a known domain, like
&lt;code&gt;screen_t&lt;/code&gt;, after which the SELinux policy module that provides this
domain is removed from …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you notice that a process is running in the &lt;code&gt;unlabeled_t&lt;/code&gt; domain, the
first question to ask is how it got there.&lt;/p&gt;
&lt;p&gt;Well, one way is to have a process running in a known domain, like
&lt;code&gt;screen_t&lt;/code&gt;, after which the SELinux policy module that provides this
domain is removed from the system (or updated and the update does not
contain the &lt;code&gt;screen_t&lt;/code&gt; definition anymore):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test ~ # ps -eZ | grep screen
root:sysadm_r:sysadm_screen_t    5047 ?        00:00:00 screen
test ~ # semodule -r screen
test ~ # ps -eZ | grep screen
system_u:object_r:unlabeled_t    5047 ?        00:00:00 screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In permissive mode, this will be visible easily; in enforcing mode, the
domains you are running in might not be allowed to do anything with
&lt;code&gt;unlabeled_t&lt;/code&gt; files, directories and processes, so &lt;strong&gt;ps&lt;/strong&gt; might not show
it even though it still exists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test audit # ps -eZ | grep 5047
test audit # ls -dZ /proc/5047
ls: cannot access /proc/5047: Permission denied
test audit # tail audit.log | grep unlabeled
type=AVC msg=audit(1368698097.494:27806): avc:  denied  { getattr } for  pid=4137 comm=&amp;quot;bash&amp;quot; path=&amp;quot;/proc/5047&amp;quot; dev=&amp;quot;proc&amp;quot; ino=6677 scontext=root:sysadm_r:sysadm_t tcontext=system_u:object_r:unlabeled_t tclass=dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notice that, if you reload the module, the process becomes visible
again. That is because the process context itself (&lt;code&gt;screen_t&lt;/code&gt;) is
retained, but because the policy doesn't know it anymore, it shows it as
&lt;code&gt;unlabeled_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Basically, the moment the policy doesn't know how a label would be
(should be), it uses &lt;code&gt;unlabeled_t&lt;/code&gt;. The SELinux policy then defines how
this &lt;code&gt;unlabeled_t&lt;/code&gt; domain is handled. Processes getting into
&lt;code&gt;unlabeled_t&lt;/code&gt; is not that common though as there is no supported
transition to it. The above one is one way that this still can occur.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="selinux"></category><category term="unlabeled"></category></entry><entry><title>Commandline SELinux policy helper functions</title><link href="https://blog.siphos.be/2013/05/commandline-selinux-policy-helper-functions/" rel="alternate"></link><published>2013-05-18T03:50:00+02:00</published><updated>2013-05-18T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-18:/2013/05/commandline-selinux-policy-helper-functions/</id><summary type="html">&lt;p&gt;To work on SELinux policies, I use a couple of functions that I can call
on the shell (command line): &lt;strong&gt;seshowif&lt;/strong&gt;, &lt;strong&gt;sefindif&lt;/strong&gt;, &lt;strong&gt;seshowdef&lt;/strong&gt;
and &lt;strong&gt;sefinddef&lt;/strong&gt;. The idea behind the methods is that I want to search
(&lt;em&gt;find&lt;/em&gt;) for an interface (&lt;em&gt;if&lt;/em&gt;) or definition (&lt;em&gt;def&lt;/em&gt;) that contains a
particular method or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;To work on SELinux policies, I use a couple of functions that I can call
on the shell (command line): &lt;strong&gt;seshowif&lt;/strong&gt;, &lt;strong&gt;sefindif&lt;/strong&gt;, &lt;strong&gt;seshowdef&lt;/strong&gt;
and &lt;strong&gt;sefinddef&lt;/strong&gt;. The idea behind the methods is that I want to search
(&lt;em&gt;find&lt;/em&gt;) for an interface (&lt;em&gt;if&lt;/em&gt;) or definition (&lt;em&gt;def&lt;/em&gt;) that contains a
particular method or call. Or, if I know what the interface or
definition is, I want to see it (&lt;em&gt;show&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;For instance, to find the name of the interface that allows us to define
file transitions from the &lt;code&gt;postfix_etc_t&lt;/code&gt; label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefindif filetrans.*postfix_etc
contrib/postfix.if: interface(`postfix_config_filetrans&amp;#39;,`
contrib/postfix.if:     filetrans_pattern($1, postfix_etc_t, $2, $3, $4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Or to show the content of the &lt;em&gt;corenet_tcp_bind_http_port&lt;/em&gt;
interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seshowif corenet_tcp_bind_http_port
interface(`corenet_tcp_bind_http_port&amp;#39;,`
        gen_require(`
                type http_port_t;
        &amp;#39;)

        allow $1 http_port_t:tcp_socket name_bind;
        allow $1 self:capability net_bind_service;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For the definitions, this is quite similar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sefinddef socket.*create
obj_perm_sets.spt:define(`create_socket_perms&amp;#39;, `{ create rw_socket_perms }&amp;#39;)
obj_perm_sets.spt:define(`create_stream_socket_perms&amp;#39;, `{ create_socket_perms listen accept }&amp;#39;)
obj_perm_sets.spt:define(`connected_socket_perms&amp;#39;, `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }&amp;#39;)
obj_perm_sets.spt:define(`create_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read nlmsg_write }&amp;#39;)
obj_perm_sets.spt:define(`rw_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read nlmsg_write }&amp;#39;)
obj_perm_sets.spt:define(`r_netlink_socket_perms&amp;#39;, `{ create_socket_perms nlmsg_read }&amp;#39;)
obj_perm_sets.spt:define(`client_stream_socket_perms&amp;#39;, `{ create ioctl read getattr write setattr append bind getopt setopt shutdown }&amp;#39;)

$ seshowdef manage_files_pattern
define(`manage_files_pattern&amp;#39;,`
        allow $1 $2:dir rw_dir_perms;
        allow $1 $3:file manage_file_perms;
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I have these defined in my &lt;code&gt;~/.bashrc&lt;/code&gt; (they are simple
&lt;a href="http://dev.gentoo.org/~swift/blog/01/selinux-funcs.txt"&gt;functions&lt;/a&gt;) and
are used on a daily basis here ;-) If you want to learn a bit more on
developing SELinux policies for Gentoo, make sure you read the &lt;a href="http://www.gentoo.org/proj/en/hardened/selinux-development.xml"&gt;Gentoo
Hardened SELinux
Development&lt;/a&gt;
guide.&lt;/p&gt;</content><category term="SELinux"></category><category term="bash"></category><category term="definition"></category><category term="functions"></category><category term="interface"></category><category term="policy"></category><category term="selinux"></category><category term="support"></category></entry><entry><title>Overriding the default SELinux policies</title><link href="https://blog.siphos.be/2013/05/overriding-the-default-selinux-policies/" rel="alternate"></link><published>2013-05-15T03:50:00+02:00</published><updated>2013-05-15T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-15:/2013/05/overriding-the-default-selinux-policies/</id><summary type="html">&lt;p&gt;Extending SELinux policies with additional rules is easy. As SELinux
uses a &lt;em&gt;deny by default&lt;/em&gt; approach, all you need to do is to &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file"&gt;create a
policy
module&lt;/a&gt;
that contains the additional (allow) rules, load that and you're all
set. But what if you want to remove some rules?&lt;/p&gt;
&lt;p&gt;Well, sadly …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Extending SELinux policies with additional rules is easy. As SELinux
uses a &lt;em&gt;deny by default&lt;/em&gt; approach, all you need to do is to &lt;a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Creating_your_own_policy_module_file"&gt;create a
policy
module&lt;/a&gt;
that contains the additional (allow) rules, load that and you're all
set. But what if you want to remove some rules?&lt;/p&gt;
&lt;p&gt;Well, sadly, SELinux does not support deny rules. Once an allow rule is
loaded in memory, it cannot be overturned anymore. Yes, you can disable
the module itself that provides the rules, but you cannot selectively
disable rules. So what to do?&lt;/p&gt;
&lt;p&gt;Generally, you can disable the module that contains the rules you want
to disable, and load a custom module that defines everything the
original module did, except for those rules you don't like. For
instance, if you do not want the &lt;code&gt;skype_t&lt;/code&gt; domain to be able to
read/write to the video device, create your own skype-providing module
(&lt;em&gt;myskype&lt;/em&gt;) with the exact same content (except for the module name at
the first line) as the original skype module, except for the video
device:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dev_read_sound(skype_t)
# dev_read_video_dev(skype_t)
dev_write_sound(skype_t)
# dev_write_video_dev(skype_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Load in this policy, and you now have the &lt;code&gt;skype_t&lt;/code&gt; domain without the
video access. You will get post-install failures when Gentoo pushes out
an update to the policy though, since it will attempt to reload the
&lt;code&gt;skype.pp&lt;/code&gt; file (through the &lt;code&gt;selinux-skype&lt;/code&gt; package) and fail because
it declares types and attributes already provided (by &lt;em&gt;myskype&lt;/em&gt;). You
can &lt;a href="http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=3&amp;amp;chap=5#doc_chap1"&gt;exclude the
package&lt;/a&gt;
from being updated, which works as long as no packages depend on it. Or
live with the post-install failure ;-) But there might be a simpler
approach: &lt;em&gt;epatch_user&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Recently, I added in support for &lt;em&gt;epatch_user&lt;/em&gt; in the policy ebuilds.
This allows users to create patches against the policy source code that
we use and put them in &lt;code&gt;/etc/portage/patches&lt;/code&gt; in the directory of the
right category/package. For module patches, the working directory used
is within the &lt;code&gt;policy/modules&lt;/code&gt; directory of the policy checkout. For
base, it is below the policy checkout (in other words, the patch will
need to use the &lt;code&gt;refpolicy/&lt;/code&gt; directory base). But because of how
&lt;em&gt;epatch_user&lt;/em&gt; works, any patch taken from the base will work as it will
start stripping directories up to the fourth one.&lt;/p&gt;
&lt;p&gt;This approach is also needed if you want to exclude rules from
interfaces rather than from the &lt;code&gt;.te&lt;/code&gt; file: create a small patch and put
it in &lt;code&gt;/etc/portage/patches&lt;/code&gt; for the &lt;code&gt;sec-policy/selinux-base&lt;/code&gt; package
(as this provides the interfaces).&lt;/p&gt;</content><category term="Gentoo"></category><category term="ebuild"></category><category term="epatch_user"></category><category term="Gentoo"></category><category term="override"></category><category term="patch"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>SECMARK and SELinux</title><link href="https://blog.siphos.be/2013/05/secmark-and-selinux/" rel="alternate"></link><published>2013-05-13T03:50:00+02:00</published><updated>2013-05-13T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-13:/2013/05/secmark-and-selinux/</id><summary type="html">&lt;p&gt;When using SECMARK, the administrator configures the &lt;strong&gt;iptables&lt;/strong&gt; or
&lt;strong&gt;netfilter&lt;/strong&gt; rules to add a label to the packet data structure (on the
host itself) that can be governed through SELinux policies. Unlike peer
labeling, here the labels assigned to the network traffic is completely
locally defined. Consider the following command …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When using SECMARK, the administrator configures the &lt;strong&gt;iptables&lt;/strong&gt; or
&lt;strong&gt;netfilter&lt;/strong&gt; rules to add a label to the packet data structure (on the
host itself) that can be governed through SELinux policies. Unlike peer
labeling, here the labels assigned to the network traffic is completely
locally defined. Consider the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# iptables -t mangle -A INPUT -p tcp --src 192.168.1.2 --dport 443
  -j SECMARK --selctx system_u:object_r:myauth_packet_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this command, packets that originate from the &lt;em&gt;192.168.1.2&lt;/em&gt; host
and arrive on port 443 (typically used for HTTPS traffic) are marked as
&lt;code&gt;myauth_packet_t&lt;/code&gt;. SELinux policy writers can then allow domains to
receive this type of packets (or send) through the &lt;em&gt;packet&lt;/em&gt; class:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Allow sockets with mydomain_t context to receive packets labeled myauth_packet_t
allow mydomain_t myauth_packet_t:packet recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The SELinux policy modules enable this through the
&lt;em&gt;corenet_sendrecv_&amp;lt;type&amp;gt;_{client,server}_packets&lt;/em&gt; interfaces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_sendrecv_http_client_packets(mybrowser_t)
# allow mybrowser_t http_client_packet_t:packet { send recv };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As a common rule, packets are marked as client packets or server
packets, depending on the role of the &lt;em&gt;domain&lt;/em&gt;. In the above example,
the domain is a browser, so acts as a web client. So, it needs to send
and receive &lt;code&gt;http_client_packet_t&lt;/code&gt;. A web server on the other hand would
need to send and receive &lt;code&gt;http_server_packet_t&lt;/code&gt;. Note that the packets
that are sent over the wire do not have any labels assigned to them -
this is all local to the system. So even when the source and destination
use SELinux with SECMARK, on the source server the packets might be
labeled as &lt;code&gt;http_client_packet_t&lt;/code&gt; whereas on the target they are seen as
&lt;code&gt;http_server_packet_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As far as I know, when you want to use SECMARK, you will need to set the
contexts with &lt;strong&gt;iptables&lt;/strong&gt; yourself (there is no default labeling), so
knowing about the above convention is important.&lt;/p&gt;
&lt;p&gt;Again, Paul Moore has &lt;a href="http://paulmoore.livejournal.com/4281.html"&gt;more
information&lt;/a&gt; about this.&lt;/p&gt;</content><category term="SELinux"></category><category term="policy"></category><category term="secmark"></category><category term="selinux"></category></entry><entry><title>Peer labeling in SELinux policy</title><link href="https://blog.siphos.be/2013/05/peer-labeling-in-selinux-policy/" rel="alternate"></link><published>2013-05-12T03:50:00+02:00</published><updated>2013-05-12T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-12:/2013/05/peer-labeling-in-selinux-policy/</id><summary type="html">&lt;p&gt;Allow me to start with an important warning: I don't have much hands-on
experience with the remainder of this post. Its based on the few
resources I found on the Internet and a few tests done locally which
I've investigated in my attempt to understand SELinux policy writing for
networking …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Allow me to start with an important warning: I don't have much hands-on
experience with the remainder of this post. Its based on the few
resources I found on the Internet and a few tests done locally which
I've investigated in my attempt to understand SELinux policy writing for
networking stuff.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, let's look into &lt;em&gt;peer labeling&lt;/em&gt;. As
mentioned in my &lt;a href="http://blog.siphos.be/2013/05/selinux-policy-and-network-controls/"&gt;previous
post&lt;/a&gt;,
SELinux supports some more advanced networking security features than
the default socket restrictions. I mentioned SECMARK and NetLabel
before, but NetLabel is actually part of the family of &lt;em&gt;peer&lt;/em&gt; labeling
technologies.&lt;/p&gt;
&lt;p&gt;With this technology approach, all participating systems in the network
must support the same labeling method. NetLabel supports CIPSO
(&lt;a href="https://tools.ietf.org/html/draft-ietf-cipso-ipsecurity-01"&gt;Commerial IP Security
Option&lt;/a&gt;)
where hosts label their network traffic to be part of a particular
"Domain of Interpretation". The labels are used by the hosts to identify
where a packet should be for. NetLabel, within Linux, is then used to
translate those CIPSO labels. SELinux itself labels the incoming sockets
based on the NetLabel information and the context of the listening
socket, resulting in a context that is governed policy-wise through the
&lt;em&gt;peer&lt;/em&gt; class. Since this is based on the information in the packet
instead of defined on the system itself, this allows remote systems to
have a say in how the packets are labeled.&lt;/p&gt;
&lt;p&gt;Another peer technology is the &lt;em&gt;Labeled IPSec&lt;/em&gt; one. In this case the
labels are fully provided by the remote system. I think they are based
on the security association within the IPSec setup.&lt;/p&gt;
&lt;p&gt;In both cases, in the SELinux policies, three definitions are important
to keep an eye out on: &lt;em&gt;interface&lt;/em&gt; definitions, &lt;em&gt;node&lt;/em&gt; definitions and
&lt;em&gt;peer&lt;/em&gt; definitions.&lt;/p&gt;
&lt;p&gt;Interface definitions allow users to (mainly) set the sensitivity that
is allowed to pass the interface. Using &lt;strong&gt;semanage interface&lt;/strong&gt; this can
be controlled by the user. One can also assign a different context to
the interface - by default, this is &lt;code&gt;netif_t&lt;/code&gt;. The permissions that are
checked on the traffic is &lt;em&gt;ingress&lt;/em&gt; (incoming) and &lt;em&gt;egress&lt;/em&gt; (outgoing)
traffic, and most policies set this through the following call (comment
shows the underlying SELinux rules, where &lt;em&gt;tcp_send&lt;/em&gt; and &lt;em&gt;tcp_recv&lt;/em&gt;
are - I think - obsolete):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_sendrecv_generic_if(something_t)
# allow something_t netif_t:netif { tcp_send tcp_recv egress ingress };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Node definitions define which targets (nodes, which can be IP addresses
or subnets) traffic meant for a particular socket is allow to originate
from (&lt;em&gt;recvfrom&lt;/em&gt;) or sent to (&lt;em&gt;sendto&lt;/em&gt;). Again, users can define their
own node types and manage them using &lt;strong&gt;semanage node&lt;/strong&gt;. The default node
I already covered in the previous post (&lt;code&gt;node_t&lt;/code&gt;) and is allowed by most
policies by default through the following call (where the &lt;em&gt;tcp_send&lt;/em&gt;
and &lt;em&gt;tcp_recv&lt;/em&gt; are probably deprecated as well):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_sendrecv_generic_node(something_t)
# allow something_t node_t:node { tcp_send tcp_recv sendto recvfrom };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, peer definitions are based on the labels from the traffic. If
the system uses NetLabel, then the target label will always be
&lt;code&gt;netlabel_peer_t&lt;/code&gt; since the workings of CIPSO are mainly (only?) mapped
towards sensitivity labels (in MLS policy). As a result, SELinux always
displays the peer as being &lt;code&gt;netlabel_peer_t&lt;/code&gt;. In case of Labeled IPSec,
this isn't the case as the peer label is transmitted by the peer itself.&lt;/p&gt;
&lt;p&gt;For NetLabel support, policies generally include two methods - one is to
support unlabeled traffic (only needed the moment you have support for
labeled traffic) and one is to allow the NetLabel'ed traffic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_all_recvfrom_unlabeled(something_t)
# allow something_t unlabeled_t:peer recv;
corenet_all_recvfrom_netlabel(something_t)
# allow something_t netlabel_peer_t:peer recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In case of IPSec for instance, the peer will have a provided label, as
is shown by the call for accepting hadoop traffic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;hadoop_recvfrom(something_t)
# allow something_t hadoop_t:peer recv;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, this alone is not sufficient for labeled IPSec. We also need to
allow the domain to be allowed to send anything towards an IPSec
security association. There is an interface called
&lt;em&gt;corenet_tcp_recvfrom_labeled&lt;/em&gt; that takes two arguments which,
amongst other things, enables &lt;em&gt;sendto&lt;/em&gt; towards its association.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_recvfrom_labeled(some_t, thing_t)
# allow { some_t thing_t} self:association sendto;
# allow some_t thing_t:peer recv;
# allow thing_t some_t:peer recv;
# corenet_tcp_recvfrom_netlabel(some_t)
# corenet_tcp_recvfrom_netlabel(thing_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This interface is usually called within a &lt;em&gt;*_tcp_connect()&lt;/em&gt; interface
for a particular domain, like with the &lt;em&gt;mysql_tcp_connect&lt;/em&gt; example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;interface(`mysql_tcp_connect&amp;#39;,`
        gen_require(`
                type mysqld_t;
        &amp;#39;)

        corenet_tcp_recvfrom_labeled($1, mysqld_t)
        corenet_tcp_sendrecv_mysqld_port($1) # deprecated
        corenet_tcp_connect_mysqld_port($1)
        corenet_sendrecv_mysqld_client_packets($1)
&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When using peer labeling, the domain that is allowed something is based
on the socket context of the application. Also, the rules when using
peer labeling are &lt;em&gt;in addition to&lt;/em&gt; the rules mentioned before
("standard" networking control): &lt;em&gt;name_bind&lt;/em&gt; and &lt;em&gt;name_connect&lt;/em&gt; are
always checked.&lt;/p&gt;
&lt;p&gt;For more information, make sure you check &lt;a href="http://paulmoore.livejournal.com"&gt;Paul Moore's
blog&lt;/a&gt;, such as the
&lt;a href="http://paulmoore.livejournal.com/2128.html?nojs=1"&gt;egress/ingress&lt;/a&gt;
information. And if you know of resources that show this in a more
practical setting (above is mainly to work with the SELinux policy) I'm
all ears.&lt;/p&gt;</content><category term="SELinux"></category><category term="cipso"></category><category term="ipsec"></category><category term="peer"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>SELinux policy and network controls</title><link href="https://blog.siphos.be/2013/05/selinux-policy-and-network-controls/" rel="alternate"></link><published>2013-05-11T03:50:00+02:00</published><updated>2013-05-11T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-05-11:/2013/05/selinux-policy-and-network-controls/</id><summary type="html">&lt;p&gt;Let's talk about how SELinux governs network streams (and how it
reflects this into the policy).&lt;/p&gt;
&lt;p&gt;When you don't do fancy stuff like SECMARK or netlabeling, then the
classes that you should keep an eye on are &lt;em&gt;tcp_socket&lt;/em&gt; and
&lt;em&gt;udp_socket&lt;/em&gt; (depending on the protocol). There used to be &lt;em&gt;node&lt;/em&gt; and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Let's talk about how SELinux governs network streams (and how it
reflects this into the policy).&lt;/p&gt;
&lt;p&gt;When you don't do fancy stuff like SECMARK or netlabeling, then the
classes that you should keep an eye on are &lt;em&gt;tcp_socket&lt;/em&gt; and
&lt;em&gt;udp_socket&lt;/em&gt; (depending on the protocol). There used to be &lt;em&gt;node&lt;/em&gt; and
&lt;em&gt;netif&lt;/em&gt; as well, but the support (enforcement) for these have been
&lt;a href="http://lists.openwall.net/netdev/2009/03/27/144"&gt;removed a while ago&lt;/a&gt;
for the "old style" network control enforcement. The concepts are still
available though, and I believe they take effect when netlabeling is
used. But let's first look at the regular networking aspects.&lt;/p&gt;
&lt;p&gt;The idea behind the regular network related permissions are that you
define either daemon-like behavior (which "binds" to a port) or
client-like behavior (which "connects" to a port). Consider an FTP
daemon (domain &lt;code&gt;ftpd_t&lt;/code&gt;) versus FTP client (example domain &lt;code&gt;ncftp_t&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In case of a daemon, the policy would contain the following (necessary)
rules:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_bind_generic_node(ftpd_t) # Somewhat legacy but still needed
corenet_tcp_bind_ftp_port(ftpd_t)
corenet_tcp_bind_ftp_data_port(ftpd_t)
corenet_tcp_bind_all_unreserved_ports(ftpd_t) # In case of passive mode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gets translated to the following "real" SELinux statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;allow ftpd_t node_t:tcp_socket node_bind;
allow ftpd_t ftp_port_t:tcp_socket name_bind;
allow ftpd_t ftp_data_port_t:tcp_socket name_bind;
allow ftpd_t unreserved_port_type:tcp_socket name_bind;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I mention that &lt;em&gt;corenet_tcp_bind_generic_node&lt;/em&gt; as being somewhat
legacy. When you use netlabeling, you can define different nodes (a
"node" in that case is a label assigned to an IP address or IP subnet)
and as such define policy-wise where daemons can bind on (or clients can
connect to). However, without netlabel, the only node that you get to
work with is &lt;code&gt;node_t&lt;/code&gt; which represents any possible node. Also, the use
of passive mode within the ftp policy is governed through the
&lt;em&gt;ftpd_use_passive_mode&lt;/em&gt; boolean.&lt;/p&gt;
&lt;p&gt;For a client, the following policy line would suffice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_connect_ftp_port(ncftp_t)
# allow ncftp_t ftp_port_t:tcp_socket name_connect;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Well, I lied. Because of how FTP works, if you use active connections,
you need to allow the client to bind on an unreserved port, and allow
the server to connect to unreserved ports (cfr code snippet below), but
you get the idea.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;corenet_tcp_connect_all_unreserved_ports(ftpd_t)

corenet_tcp_bind_generic_node(ncftp_t)
corenet_tcp_bind_all_unreserved_ports(ncftp_t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the past, policy developers also had to include other lines, but
these have by time become obsolete (&lt;em&gt;corenet_tcp_sendrecv_ftp_port&lt;/em&gt;
for instance). These methods defined the ability to send and receive
messages on the port, but this is no longer controlled this way. If you
need such controls, you will need to look at SELinux and SECMARK (which
uses packets with the &lt;em&gt;packet&lt;/em&gt; class) or netlabel (which uses the &lt;em&gt;peer&lt;/em&gt;
class and peer types to send or receive messages from).&lt;/p&gt;
&lt;p&gt;And that'll be for a different post.&lt;/p&gt;</content><category term="SELinux"></category><category term="networking"></category><category term="policy"></category><category term="selinux"></category></entry><entry><title>Introducing selocal for small SELinux policy enhancements</title><link href="https://blog.siphos.be/2013/04/introducing-selocal-for-small-selinux-policy-enhancements/" rel="alternate"></link><published>2013-04-21T03:50:00+02:00</published><updated>2013-04-21T03:50:00+02:00</updated><author><name>Sven Vermeulen</name></author><id>tag:blog.siphos.be,2013-04-21:/2013/04/introducing-selocal-for-small-selinux-policy-enhancements/</id><summary type="html">&lt;p&gt;When working with a SELinux-enabled system, administrators will
eventually need to make small updates to the existing policy. Instead of
building their own full policy (always an option, but most likely not
maintainable in the long term) one or more SELinux policy modules are
created (most distributions use a modular …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When working with a SELinux-enabled system, administrators will
eventually need to make small updates to the existing policy. Instead of
building their own full policy (always an option, but most likely not
maintainable in the long term) one or more SELinux policy modules are
created (most distributions use a modular approach to the SELinux policy
development) which are then loaded on their target systems.&lt;/p&gt;
&lt;p&gt;In the past, users had to create their own policy module by creating
(and maintaining) the necessary &lt;code&gt;.te&lt;/code&gt; file(s), building the proper &lt;code&gt;.pp&lt;/code&gt;
files and loading it in the active policy store. In Gentoo, from
&lt;code&gt;policycoreutils-2.1.13-r11&lt;/code&gt; onwards, a script is provided to the users
that hopefully makes this a bit more intuitive for regular users:
&lt;strong&gt;selocal&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As the name implies, &lt;strong&gt;selocal&lt;/strong&gt; aims to provide an interface for
handling &lt;em&gt;local&lt;/em&gt; policy updates that do not need to be packaged or
distributed otherwise. It is a command-line application that you feed
single policy rules at one at a time. Each rule can be accompanied with
a single-line comment, making it obvious for the user to know why he
added the rule in the first place.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --help
Usage: selocal [] []

Command can be one of:
  -l, --list            List the content of a SELinux module
  -a, --add             Add an entry to a SELinux module
  -d, --delete          Remove an entry from a SELinux module
  -M, --list-modules    List the modules currently known by selocal
  -u, --update-dep      Update the dependencies for the rules
  -b, --build           Build the SELinux module (.pp) file (requires privs)
  -L, --load            Load the SELinux module (.pp) file (requires privs)

Options can be one of:
  -m, --module          Module name to use (default: selocal)
  -c, --comment        Comment (with --add)

The option -a requires that a rule is given, like so:
  selocal -a &amp;quot;dbadm_role_change(staff_r)&amp;quot;
The option -d requires that a line number, as shown by the --list, is given, like so:
  selocal -d 12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's say that you need to launch a small script you written as a
daemon, but you want this to run while you are still in the &lt;em&gt;staff_t&lt;/em&gt;
domain (it is a user-sided daemon you use personally). As regular
&lt;em&gt;staff_t&lt;/em&gt; isn't allowed to have processes bind on generic ports/nodes,
you need to enhance the SELinux policy a bit. With &lt;strong&gt;selocal&lt;/strong&gt;, you can
do so as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --add &amp;quot;corenet_tcp_bind_generic_node(staff_t)&amp;quot; --comment &amp;quot;Launch local webserv.py daemon&amp;quot;
# selocal --add &amp;quot;corenet_tcp_bind_generic_port(staff_t)&amp;quot; --comment &amp;quot;Launch local webserv.my daemon&amp;quot;
# selocal --build --load
(some output on building the policy module)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When finished, the local policy is enhanced with the two mentioned
rules. You can query which rules are currently stored in the policy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --list
12: corenet_tcp_bind_generic_node(staff_t) # Launch local webserv.py daemon
13: corenet_tcp_bind_generic_port(staff_t) # Launch local webserv.py daemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you need to delete a rule, just pass the line number:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# selocal --delete 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Having this tool around also makes it easier to test out changes
suggested through bugreports. When I test such changes, I add in the bug
report ID as the comment so I can track which settings are still local
and which ones have been pushed to our policy repository. Underlyingly,
&lt;strong&gt;selocal&lt;/strong&gt; creates and maintains the necessary policy file in
&lt;path&gt;\~/.selocal&lt;/path&gt; and by default uses the &lt;em&gt;selocal&lt;/em&gt; policy module
name.&lt;/p&gt;
&lt;p&gt;I hope this tool helps users with their quest on using SELinux. Feedback
and comments are always appreciated! It is a small bash script and might
still have a few bugs in it, but I have been using it for a few months
so most quirks should be handled.&lt;/p&gt;</content><category term="Gentoo"></category><category term="Gentoo"></category><category term="policy"></category><category term="selinux"></category><category term="selocal"></category></entry></feed>